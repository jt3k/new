{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"ef8190c6-d57a-58b6-bff0-35894e777686","excerpt":"Метрики загрузки страницы Что все они означают? Измерение производительности загрузки страницы — это сложная задача. Чтобы сделать её проще…","html":"<h1>Метрики загрузки страницы</h1>\n<p>Что все они означают?</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2218/1*APIpb-0RXtZ9sN2aJQgqFQ.png\"></p>\n<p>Измерение производительности загрузки страницы — это сложная задача. Чтобы сделать её проще, <a href=\"https://medium.com/google-developers\">инженеры компании *Google</a>* вместе с сообществом работают над прогрессивными веб-метриками, или ПВМ.</p>\n<p>Что такое ПВМ и зачем они нужны? Для начала, давайте сделаем небольшой экскурс в историю браузерных метрик. Некоторое время назад мы имели всего две точки (события) для измерения производительности:</p>\n<ol>\n<li>\n<p>DOMContentLoaded срабатывает, когда страница загрузилась, но скрипты только начали выполняться.</p>\n</li>\n<li>\n<p>Событие load срабатывает, когда страница полностью загрузилась и пользователь может полностью с ней взаимодействовать.</p>\n</li>\n</ol>\n<p>Если взглянуть на <a href=\"https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=drive://0ByCYpYcHF12_YjBGUTlJR2gzcHc\">трейс сайта *Reddit</a>* (<em>Chrome DevTools</em> помогает нам, помечая эти точки синей и красной линиями), мы можем увидеть почему эти метрики не так полезны, как хотелось бы.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2152/1*VTyhl1PZdQxqAdCW3eXXMg.png\" alt=\"Трейс сайта *Reddit*.\"><em>Трейс сайта *Reddit</em>.*</p>\n<blockquote>\n<p>Сегодня мы видим, что window.onload не отражает восприятие пользователя, как это было когда-то. <a href=\"https://www.stevesouders.com/blog/2013/05/13/moving-beyond-window-onload/\">Стивен Саудерс</a></p>\n</blockquote>\n<p>Конечно. Так же понятны и недостатки DOMContentLoaded во время парсинга и компиляции <em>JavaScript</em>: выполнение этих операций для больших скриптов может занять достаточно много времени. Например, на мобильных устройствах. Упомянутый выше трейс был замерян в условиях эмуляции <em>3G</em> и показал разницу 10 секунд между DOMContentLoaded и load.</p>\n<p>С другой стороны, load сработал очень поздно, чтобы можно было проанализировать узкие места в производительности загрузки страницы. И главный вопрос: как пользователи <em>воспринимают</em> загрузку страницы** **с момента старта до полной загрузки?</p>\n<p>Почему это восприятие так важно? Читайте подробнее <a href=\"https://developers.google.com/web/updates/2017/06/user-centric-performance-metrics\">в статье разработчиков *Chrome</a>*, где ещё раз подчеркивается проблема load.</p>\n<p>Рассмотрим график: ось <em>X</em> показывает время загрузки, ось <em>Y</em> — количество пользователей, которые ожидали какое-то время. Далеко не для всех пользователей загрузка страницы происходит меньше, чем за 2 секунды.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2800/1*gw7eB5MF4SDAk1TGHSUlkg.png\"></p>\n<p>Если вернуться к нашему трейсу, то событие load, которое заняло 17 секунд, ничего нам не говорит о том, как пользователь воспринял загрузку страницы. Что он видел все эти 17 секунд: пустую страницу, частично загруженную? Был ли загруженный контент заблокирован, так что пользователь не мог поставить курсор в поле или прокрутить страницу?</p>\n<p>Имея ответы на эти вопросы вы можете:</p>\n<ol>\n<li>\n<p>Улучшить ощущения от работы сайта;</p>\n</li>\n<li>\n<p>Привлечь больше пользователей к вашему приложению;</p>\n</li>\n<li>\n<p>Увеличить выгоду для владельца продукта (пользователи, заказчики, деньги).</p>\n</li>\n</ol>\n<p>Поэтому ребята из команды <em>Chrome</em> попробовали прочитать мысли пользователей и предугадать какие же вопросы они себе задают во время загрузки страницы:</p>\n<ol>\n<li>\n<p>**Что происходит? **Произошла ли навигация успешно;</p>\n</li>\n<li>\n<p>**Это то, что мне нужно? **Отрендерилась ли страница, достаточно ли там контента, с которым можно взаимодействовать;</p>\n</li>\n<li>\n<p>**Уже можно пользоваться? **Можно ли, наконец, взаимодействовать со страницей или она всё ещё занята;</p>\n</li>\n<li>\n<p>**Это восхитительно? **Испытывал ли пользователь негативный опыт зависания скролла, анимация, медленных шрифтов.</p>\n</li>\n</ol>\n<p>Если события DOMContentLoaded и load не могут ответить на эти вопросы, то кто может?</p>\n<h2>Прогрессивные веб-метрики</h2>\n<p>ПВМ — список метрик, цель которых помочь разработчикам определять узкие места в производительности загрузки страницы. В отличие от событий DOMContentLoaded и load, ПВМ предоставляют разработчикам более детальную информацию.</p>\n<p>Давайте начнем разбираться с каждой из метрик на примере трейса <em>Reddit</em>, который мы упоминали выше.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2856/1*-zjNpHphoKaaZJgG7omu2w.png\"></p>\n<h2>Первая отрисовка</h2>\n<p><em>First Paint (FP)</em></p>\n<p>Я немного слукавил, говоря что у нас есть только две метрики. <em>Chrome DevTools</em> также предоставляют ещё одну метрку — первая отрисовка. Это момент когда страница только начала отрисовываться. Говоря другими словами — это время, когда пользователь видит пустую страницу впервые. Подробнее читайте <a href=\"https://github.com/w3c/paint-timing\">в спецификации</a>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*QtXNkY2vUWEj5NvZbiRtOg.png\" alt=\"Первая отрисовка сайта [MSN](https://www.msn.com/).\"><em>Первая отрисовка сайта <a href=\"https://www.msn.com/\">MSN</a>.</em></p>\n<p>Чтобы понять, как это работает, можно взглянуть на графический слой (<em>GraphicsLayer</em>) в <em>Chromium</em>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*rzyN24hIkj74TpJj93qsVg.png\" alt=\"Упрощённый графический слой.\"><em>Упрощённый графический слой.</em></p>\n<p>Событие первой отрисовки срабатывает, когда только начался отрисовываться графический слой, но не картинки, <em>SVG</em> или <em>Canvas</em>. Эта метрика давала хоть какую-то информацию и её использовали сполна. Когда она ещё не была стандартизирована, использовались разные техники:</p>\n<ul>\n<li>\n<p>Привязывался requestAnimationFrame;</p>\n</li>\n<li>\n<p>Отлавливались загруженные <em>CSS</em>-ресурсы;</p>\n</li>\n<li>\n<p>Даже использовались события DOMContentLoaded и load.</p>\n</li>\n</ul>\n<p>Но несмотря на все усилия, она имеет низкое значение. Картинки, <em>SVG</em> или <em>Canvas</em> могут быть отрисованы задолго после срабатывания первой отрисовки под влиянием большого размера страницы, <em>CSS-</em> или <em>JS-</em>ресурсов.</p>\n<p>Первая отрисовка не считается частью ПВМ, но понимание процесса работы графического слоя поможет в дальнейшем разобраться с остальными метриками. Итак, другие метрики были нужны, чтобы отдавать информации об отрисовке контента.</p>\n<h2>Первая отрисовка контента</h2>\n<p><em>First Contentful Paint (FCP)</em></p>\n<p>Это время, когда пользователь видит что-то полезное, отрисованное на странице. То, что отличается от пустой страницы. Это может быть всё, что угодно: первая отрисовка текста, первая отрисовка <em>SVG</em> или первая отрисовка <em>Canvas</em>.</p>\n<p>В результате пользователь может задать вопрос: что происходит?** *<em>Начала ли страница загружаться после того, как я ввел адрес в строке браузера и нажал *Enter</em>?</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*UduDmCWTDefC6CHubA-lTQ.png\" alt=\"Первая отрисовка и первая полезная отрисовка.\"><em>Первая отрисовка и первая полезная отрисовка.</em></p>\n<p>В <em>Chromium</em> первая отрисовка контента срабатывает во время реальной отрисовки картинок, текста (кроме того, что ждёт загрузки шрифтов) или <em>Canvas</em>. В результате разница между первой отрисовкой и первой отрисовкой контента может занимать от миллисекунд до секунд. Потому иметь метрику которая отображает реальную отрисовку контента очень важно, <a href=\"https://docs.google.com/document/d/1kKGZO3qlBBVOSZTf-T8BOMETzk3bY15SC-jsMJWv4IE/edit#\">см. спецификацию</a>.</p>\n<h3>Чем она важна для разработчиков?</h3>\n<p>Если первая отрисовка контента занимает очень много времени то:</p>\n<ul>\n<li>\n<p>Возможно, есть проблемы на уровне соединения;</p>\n</li>\n<li>\n<p>Ресурсы (например, сама HTML-страница) очень тяжелые и чтобы их доставить нужно время.</p>\n</li>\n</ul>\n<p>Чтобы уменьшить влияние этих факторов, читайте <em>«<a href=\"https://hpbn.co/\">High Performance Browser Networking</a>»</em> Ильи Григорика о сетевой производительности.</p>\n<h2>Первая значимая отрисовка</h2>\n<p><em>First Meaningful Paint (FMP)</em></p>\n<p>Это время, когда весь главный контент появился на странице. В результате пользователь может оценить: это то, что мне нужно?</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2622/1*835Kq5Mzw87L8XRoXXyKIw.png\" alt=\"Первая отрисовка, первая отрисовка контента, первая значимая отрисовка.\"><em>Первая отрисовка, первая отрисовка контента, первая значимая отрисовка.</em></p>\n<p>Что считается главным контентом? Когда показаны:</p>\n<ul>\n<li>\n<p>Шапка и текст блога;</p>\n</li>\n<li>\n<p>Содержимое для поисковиков;</p>\n</li>\n<li>\n<p>Критичные для интернет-магазинов картинки.</p>\n</li>\n</ul>\n<p>Не считаются главным контентом:</p>\n<ul>\n<li>\n<p>Спиннер или что-то подобное;</p>\n</li>\n<li>\n<p>Невидимый текст или <em>FOUC</em>;</p>\n</li>\n<li>\n<p>Только навигация.</p>\n</li>\n</ul>\n<p>Первая значимая отрисовка — это отрисовка, которая следует за большим изменением раскладки. В реализации <em>Chromium</em>, отрисовка рассчитывается с использованием <a href=\"https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/layout/LayoutAnalyzer.h&#x26;sq=package:chromium&#x26;type=cs\">*LayoutAnalyzer</a>*, который запоминает все изменения раскладки и находит время того изменения, которое повлияло больше остальных. Это и будет первая значимая отрисовка, <a href=\"https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/edit\">см. спецификацию</a>.</p>\n<h3><strong>Чем она важна для разработчиков</strong>?</h3>\n<p>Если главный контент не был отрисован долгое время, значит очень много ресурсов (картинки, стили, шрифты, скрипты) имеют высокий приоритет загрузки и в результате блокируют первую значимую отрисовку</p>\n<p>Мне бы не хотелось копировать сюда все возможные техники, как этого можно избежать, потому вот вам ссылки:</p>\n<ul>\n<li>\n<p><a href=\"https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf\">Preload, Prefetch And Priorities in Chrome</a>, <a href=\"undefined\">Addy Osmani</a></p>\n</li>\n<li>\n<p><a href=\"https://css-tricks.com/the-critical-request/\">Critical Request</a>, <a href=\"undefined\">Ben Schwarz</a></p>\n</li>\n<li>\n<p><a href=\"https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3\">The State of the Web</a>, <a href=\"undefined\">Karolina Szczur</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/6m_E-mC0y3Y\">Practical Performance</a>, <a href=\"undefined\">Paul Irish</a> и <a href=\"undefined\">Sam Saccone</a></p>\n</li>\n</ul>\n<h2>Визуально готов</h2>\n<p><em>Visually Ready</em></p>\n<p>Метрика разрешает сказать что страничка выглядит «почти» загруженной, но браузер еще не закончил выполнять скрипты.</p>\n<h2>Задержка ввода</h2>\n<p><em>Estimated Input Latency</em></p>\n<p>Эта метрика определяет как плавно приложение реагирует на ввод пользователя. Но прежде чем рассказывать детали хотелось бы обратить внимание на терминологию.</p>\n<h3><strong>Длинные задачи</strong></h3>\n<p>Под капотом браузер оборачивает пользовательский ввод в интерфейсные задачи и складывает в очередь главного потока. Помимо этого, браузер должен парсить, компилировать. выполнять скрипты на странице (задачи приложения). Если время для каждой задачи приложения занимает много времени то интерфейсные задачи могут быть заблокированы пока не будет завершена задача приложения. Как результат страница может отвечать на пользовательский ввод с задержкой и быть «непривлекательной».</p>\n<p>Говоря простыми словами, длинные задачи** **— те, для которых парсинг, компиляция или выполнение скриптов занимает больше чем 50 миллисекунд, <a href=\"https://w3c.github.io/longtasks/\">см. спецификацию</a>.</p>\n<p><em>API</em> для длинных задач реализован в <em>Chrome</em> и используется для расчета занятости главного потока.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2170/1*gfsd1xrSI0-uvO1kEPWbDw.png\"></p>\n<p>Возвращаясь к задержке ввода: пользователи ожидают, что страница будет реагировать без задержек, но если главный поток занят обработкой каждой длинной задачи, то станет заметно замедление реакции на ввод. Ощущения от работы с приложением довольно важны, и чтобы избавиться от таких проблем, я рекомендую прочитать <em>«<a href=\"https://developers.google.com/web/fundamentals/performance/rail\">Measure Performance with the RAIL Model</a>»</em>.</p>\n<h2>Первое взаимодействие</h2>\n<p><em>First Interactive</em></p>\n<p><strong>Уже можно пользоваться?</strong> Да, именно этот вопрос задает пользователь когда видит визуально готовую страницу и хочет с ней взаимодействовать. Первое взаимодействие считается случившимся если удовлетворены все условия:</p>\n<ul>\n<li>\n<p>Произошла первая значимая отрисовка;</p>\n</li>\n<li>\n<p>Сработал <a href=\"https://developer.mozilla.org/ru/docs/Web/Events/DOMContentLoaded\">DOMContentLoaded</a>;</p>\n</li>\n<li>\n<p>Страница визуально готова на 85%.</p>\n</li>\n</ul>\n<p>Метрика первого взаимодействия разделена на две метрики:</p>\n<ol>\n<li>\n<p>Время до первого взаимодействия (TTFI)</p>\n</li>\n<li>\n<p>Время до первого последовательного взаимодействия (TTCI)</p>\n</li>\n</ol>\n<p><a href=\"https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/edit\">См. спецификацию</a>. Причины этого разделения:</p>\n<ul>\n<li>\n<p>Чтобы определить минимальное взаимодействие, когда интерфейс отвечает неплохо но возможные небольшие задержки;</p>\n</li>\n<li>\n<p>Когда приложение или страница полностью интерактивны и строго отвечает условиям <a href=\"https://developers.google.com/web/fundamentals/performance/rail\">*RAIL</a>*.</p>\n</li>\n</ul>\n<h2>Первое последовательное взаимодействие</h2>\n<p><em>Time to First Consistently Interactive (TTCI)</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*PjsJKmbhL-bjzO9IsOUWsg.png\"></p>\n<p>Используя реверсивный анализ, который подразумевает анализ трейса с конца, находится период, когда загрузка ресурсов неактивна на протяжении 5 секунд и в этот период отсутствуют длинные задачи. Такой период называется тихое окно <em>(quiet window). *Время после тихого окна</em> <em>и перед первой, с конца,</em> <em>длинной задачей будет временем до *первого последовательного взаимодействия</em>.</p>\n<h2>Время до первого взаимодействия</h2>\n<p><em>Time to First Interactive (TTFI)</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*6hOtyvMGRnvuhBd9Z4jvyg.png\"></p>\n<p>Определение этой метрики отличается от первого последовательного взаимодействия. Трейс анализируется со старта и до конца. После того, как произошла первая значимая отрисовка, находят тихое окно в 3 секунды. Этого достаточно, чтобы сказать, что страница интерактивна. Но в трейсе могут присутствовать одинокие задачи во время или после тихого окна.</p>\n<p>Одинокие задачи выполняются далеко после первой значимой отрисовки и изолированы периодом выполнения в 250 мс <em>(envelope size)</em> и одну секунду тишины до и после этого периода. Иногда одинокие задачи, время которых занимает больше 250 мс, могут сильно влиять на быстродействие страницы. Например:</p>\n<iframe src=\"https://medium.com/media/7b7d3ea0f81cea265117430ad6dbd13c\" frameborder=0></iframe>\n<h3><strong>Чем полезны эти метрики?</strong></h3>\n<p>Они полезны когда главный поток между метриками визуально готов и* *первое взаимодействие занимает достаточно долго:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*OXoC5qJELBO7ONNRTv2HbQ.png\"></p>\n<p>Это одно из сложных узких мест которе приходится исправлять. Для каждого случая оно индивидуально, потому я рекомендую почитать <a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/\">руководства Google об этом</a>, чтобы понимать как избежать таких проблем.</p>\n<h2>Визуально готово</h2>\n<p><em>Visually Complete</em></p>\n<p>Метрика* *визуальной готовности рассчитывается с помощью скриншотов на странице и сравнивает скриншоты состояний с применением <a href=\"https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index\">алгоритма индекса скорости</a>.</p>\n<p>Бывают случаи, когда метрику визуальной готовности измерить сложно, например если на странице есть «карусели» и другие подвижные элементы. Индекс скорости представляет медиану результатов метрик визуальной готовности. Чем меньше полученное значение тем лучше.</p>\n<p>Визуально готово на 100% — это финальная точка, когда мы можем сказать, доволен пользователь процессом загрузки или нет.</p>\n<h2>Выводы</h2>\n<p>Это были не все ПВМ, только самые важные из них. Ссылки на материалы, приведённые выше, могут вам пригодиться для более подробного изучения метри. Но ещё хотелось бы поделиться инструментами, которые помогут получить эти метрики:</p>\n<ul>\n<li>\n<p><a href=\"https://www.webpagetest.org/about\">Web Pagetest</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/GoogleChrome/lighthouse/\">Lighthouse</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/paulirish/pwmetrics\">Pwmetrics</a></p>\n</li>\n<li>\n<p><a href=\"https://calibreapp.com/\">Calibre</a></p>\n</li>\n<li>\n<p><a href=\"https://chromedevtools.github.io/timeline-viewer/\">DevTools Timeline Viewer</a></p>\n</li>\n</ul>\n<p>Если вы хотите делать замеры вручную, то это возможно с <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\">API PerformanceObserver</a>. Небольшой пример из спецификации:</p>\n<pre><code>**const** observer = **new** PerformanceObserver(list => {\n  list\n    .getEntries()\n    *// Get the values we are interested in*\n    .map(({ name, entryType, startTime, duration }) => {\n      **const** obj = {\n        \"Duration\": duration,\n        \"Entry Type\": entryType,\n        \"Name\": name,\n        \"Start Time\": startTime,\n      };\n      **return** JSON.stringify(obj, null, 2);\n    })\n    *// Display them to the console*\n    .forEach(console.log);\n  *// maybe disconnect after processing the events.*\n  observer.disconnect();\n});\n*// retrieve buffered events and subscribe to new events*\n*// for Resource-Timing and User-Timing*\nobserver.observe({\n  entryTypes: [\"resource\", \"mark\", \"measure\"],\n  buffered: true\n});\n</code></pre>\n<p><em>Автор <a href=\"https://medium.com/@denar90\">Артём Денисов</a>, редактура <a href=\"https://medium.com/@pepelsbey\">Вадима Макеева</a>.</em></p>","frontmatter":{"title":"Метрики загрузки страницы","date":"TODO"}}},"pageContext":{"slug":"/articles/performance-metrics/"}}