{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"3d67647a-2762-5d0c-b72e-993d37a9bee6","excerpt":"Паттерны загрузки веб-шрифтов Брэм Штайн  14 июня 2016 Загрузка веб-шрифтов может показаться сложной задачей. Однако, на самом деле, она…","html":"<h1>Паттерны загрузки веб-шрифтов</h1>\n<p><a href=\"https://www.bramstein.com/\">Брэм Штайн</a> 14 июня 2016</p>\n<p><em>Загрузка веб-шрифтов может показаться сложной задачей. Однако, на самом деле, она довольно проста, если вы будете использовать описанные ниже паттерны. Комбинируя их, вы сможете управлять загрузкой веб-шрифтов во всех браузерах.</em></p>\n<p>В этих паттернах используется <a href=\"https://github.com/bramstein/fontfaceobserver\">Font Face Observer</a>, простая и небольшая библиотека загрузки веб-шрифтов. Font Face Observer выбирает наиболее эффективный способ загрузки шрифта, основываясь на его браузерной поддержке, так что мы можем загружать шрифты, не беспокоясь о кроссбраузерности.</p>\n<ol>\n<li><a href=\"#part-1\">Обычная загрузка шрифтов</a></li>\n<li><a href=\"#part-2\">Загрузка группы шрифтов</a></li>\n<li><a href=\"#part-3\">Загрузка шрифтов с таймером</a></li>\n<li><a href=\"#part-4\">Приоритетная загрузка</a></li>\n<li><a href=\"#part-5\">Особое отображение шрифтов</a></li>\n<li><a href=\"#part-6\">Оптимизация для кэширования</a></li>\n</ol>\n<p>Невозможно посоветовать единый паттерн, который идеально подходил бы каждому. Внимательно изучите свой сайт, его аудиторию, и на основании этого выберите тот способ загрузки или их комбинацию, которые подойдут лучше всего.</p>\n<h2>Обычная загрузка шрифтов</h2>\n<p>Font Face Observer даёт вам возможность контролировать загрузку веб-шрифтов через простой интерфейс, основанный на промисах. Не имеет значения, откуда будут загружаться шрифты: вы можете размещать их как у себя, так и подключать через сервисы — <a href=\"https://www.google.com/fonts\">Google Fonts</a>, <a href=\"https://typekit.com/\">Typekit</a>, <a href=\"https://fonts.com/\">Fonts.com</a>, и <a href=\"http://www.webtype.com/\">Webtype</a>.</p>\n<p>Чтобы не перегружать паттерны лишним кодом, будем считать, что вы размещаете веб-шрифты у себя. Это означает, что в ваших CSS-файлах будет одно или несколько объявлений <code>@font-face</code>, в которых указано, какие шрифты нужно загрузить через Font Face Observer. Для краткости мы не будем объявлять каждое из подобных правил в коде, но будем считать, что они есть.</p>\n<pre><code>@font-face {\n    font-family: Output Sans;\n    src: url(output-sans.woff2) format('woff2'),\n         url(output-sans.woff) format('woff');\n}\n</code></pre>\n<p>Рассмотрим самую обычную задачу: вам надо загрузить один или несколько разных шрифтов. Создайте несколько экземпляров <code>FontFaceObserver</code>, по одному на каждый шрифт, и вызовите их метод <code>load</code>.</p>\n<pre><code>var output = new FontFaceObserver('Output Sans');\nvar input = new FontFaceObserver('Input Mono');\n\noutput.load().then(function () {\n    console.log('Загружен Output Sans');\n});\n\ninput.load().then(function () {\n    console.log('Загружен Input Mono');\n});\n</code></pre>\n<p>Этот способ загрузит каждый шрифт независимо от остальных. Это полезно, когда шрифты не связаны друг с другом, и мы ожидаем, что они отрисуются постепенно (т.е. как только загрузятся, так и отрисуются). В отличие от стандартного <a href=\"https://www.w3.org/TR/css-font-loading/\">API загрузки шрифтов</a> вы не передаёте URL шрифтов в Font Face Observer. Для загрузки шрифтов он использует объявления <code>@font-face</code>, уже доступные в CSS. Это позволяет загружать веб-шрифты вручную через JavaScript, предусмотрев постепенную деградацию к обычному CSS.</p>\n<h2>Загрузка групп шрифтов</h2>\n<p>Вы можете загружать несколько шрифтов одновременно, группируя их: вся группа либо загрузится полностью, либо выдаст ошибку. Это полезно использовать, когда загружаемые шрифты принадлежат к одному семейству, и вы не хотите, чтобы группа отрисовывалась, пока не загрузятся все шрифты из неё. Тем самым, браузер не будет отображать стили, пока шрифты представлены не полностью.</p>\n<pre><code>var normal = new FontFaceObserver('Output Sans');\nvar italic = new FontFaceObserver('Output Sans', {\n    style: 'italic'\n});\n\nPromise.all([\n    normal.load(),\n    italic.load()\n]).then(function () {\n    console.log('Загружено семейство Output Sans');\n});\n</code></pre>\n<p>Вы можете сгруппировать шрифты через <code>Promise.all</code>. Когда промис будет выполнен, мы будем знать, что все шрифты загружены. Если промис отклонён — как минимум один из шрифтов не смог загрузиться.</p>\n<p>Ещё один пример применения группировки шрифтов — уменьшение количества перекомпоновок страницы. Если вы загружаете и отрисовываете веб-шрифты постепенно, браузер будет выполнять перекомпоновку страницы множество раз, так как характеристики начертаний запасного и веб-шрифта различны. Группировка позволит сократить количество перекомпоновок до одной.</p>\n<h2>Загрузка шрифтов с таймером</h2>\n<p>Иногда шрифты загружаются очень долго. Это может стать проблемой, поскольку веб-шрифты отвечают за текст — главную часть контента вашей страницы. Невозможно ждать загрузки шрифтов бесконечно. Мы можем исправить это, добавив таймер к загрузке.</p>\n<p>Следующая вспомогательная функция создаёт таймеры, возвращающие промис, отклоняющийся по срабатыванию таймера.</p>\n<pre><code>function timer(time) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(reject, time);\n    });\n}\n</code></pre>\n<p>С помощью <code>Promise.race</code> мы можем заставить таймер и загрузку шрифта «соревноваться» друг с другом. Например, если загрузка завершилась до того, как сработал таймер, то шрифт победил, промис выполнен. А если раньше сработал таймер, промис отклонён.</p>\n<pre><code>var font = new FontFaceObserver('Output Sans');\n\nPromise.race([\n    timer(1000),\n    font.load()\n]).then(function () {\n    console.log('Загружен Output Sans');\n}).catch(function () {\n    console.log('Время на загрузку Output Sans истекло');\n});\n</code></pre>\n<p>В этом примере время загрузки шрифта ограничено одной секундой. Вместо того, чтобы работать с одним шрифтом, мы также можем назначить таймер целой группе шрифтов. Это позволит просто и эффективно ограничить время их загрузки.</p>\n<h2>Приоритетная загрузка</h2>\n<p>Обычно, для того, чтобы отрисовать первую половину экрана (<em>above the fold</em> — верхняя половина первого экрана сайта, которую надо отобразить максимально быстро, <em>прим. переводчика</em>), нужно лишь несколько шрифтов. Если загружать эти шрифты раньше других, менее важных, мы получим выигрыш в производительности сайта. Это называется приоритетной загрузкой.</p>\n<pre><code>var primary = new FontFaceObserver('Primary');\nvar secondary = new FontFaceObserver('Secondary');\n\nprimary.load().then(function () {\n    console.log('Загружен основной шрифт')\n\n    secondary.load().then(function () {\n        console.log('Загружен второстепенный шрифт')\n    });\n});\n</code></pre>\n<p>При использовании приоритетной загрузки второстепенный шрифт зависит от основного: если не загрузится основной шрифт, то не загрузится и второстепенный. Это может оказаться полезным.</p>\n<p>Например, можно применить приоритетную загрузку так: сначала загрузить небольшой основной шрифт, содержащий ограниченное число символов, а затем полный шрифт с большим количеством символов или стилей. Так как основной шрифт мал, он намного быстрее загрузится и отрисуется. А если основной шрифт не смог загрузиться, то, вполне возможно, не следует запрашивать и второстепенный — скорее всего, он тоже не загрузится.</p>\n<p>Такое использование приоритетной загрузки более подробно описано в статьях Зака Лезермана: <a href=\"https://www.zachleat.com/web/foft/\">Flash of Faux Text</a> и <a href=\"https://www.zachleat.com/web/web-font-data-uris/\">Web Font Anti-Patterns: Data URIs</a>.</p>\n<h2>Особое отображение шрифтов</h2>\n<p>Перед тем как браузер сможет показать веб-шрифт, он должен скачать его по сети. Обычно это занимает какое-то время, и каждый браузер по-разному ведёт себя во время скачивания веб-шрифтов: некоторые из них скрывают текст, а другие сразу же показывают его с помощью запасного шрифта. Обычно это называют <em>мельканием невидимого текста</em> (Flash Of Invisible Text, <em>FOIT</em>) и <em>мельканием текста без стилей</em> (Flash Of Unstyled Text, <em>FOUT</em>).</p>\n<figure>\n    \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 52.9054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABN0lEQVQoz4WS226DQAxE9/8/DJAqnrlEEFogXArhmlAghZ6slaptHjoPq8Ue2+NZ1KfG7QHu+773ff+uURTF5XLZtk1oXG4/oOI4TtO0aZrz+Qwbal3XrxpSX5blOI4Q3jSIwGw0lOM4QRAcDgfP8+AxlihBPn3fd133dDoxc5qm4/EIkzOKIoLLsijDMGzbtiyLEwbFeZ6bpsnniwYrEEQRjZgRhiEt0Luuq5I2vcam0bYt7ZMkGYYBwexGcJ7nruuu16sYJBao/Tfg0RIJlFHAXSxcNZD68QBZBQlJswY5ukKqqirLMnEbAvWkGEtT4QhNQWLJVgOrYGAmQcxDJ8qJEyQlTwCZFN3vbv+RLY+5P4GZ8iIA5zDlLltM+reY4RQzudBA3f0neZ48PSBWfbso/sm2cn4BDRVu24VPQgIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\" alt=\"FOUT &#x438; FOIT.\" title=\"\" src=\"/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-ce0d4.png\" srcset=\"/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-a6060.png 163w,\n/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-1a895.png 325w,\n/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-ce0d4.png 650w,\n/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-63d2a.png 975w,\n/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-87302.png 1300w,\n/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-6c20f.png 1480w\" sizes=\"(max-width: 650px) 100vw, 650px\">\n    </span>\n  </span>\n  \n    <figcaption>FOUT &#x438;&#xA0;FOIT.</figcaption>\n</figure>\n<p>Internet Explorer и Edge используют FOUT и отображают запасные шрифты, пока веб-шрифт не закончит свою загрузку. Все остальные браузеры используют FOIT и прячут текст во время загрузки веб-шрифтов.</p>\n<p>Для управления этим поведением ввели новое CSS-свойство, называемое <code>font-display</code> (<a href=\"https://tabatkins.github.io/specs/css-font-display/\">CSS Font Rendering Controls</a>). К сожалению, оно до сих пор находится в разработке и ещё не поддерживается ни одним браузером (на данный момент оно спрятано за флагом в Chrome и Opera). Однако мы можем реализовать аналогичное поведение во всех браузерах с помощью Font Face Observer.</p>\n<p>Вы можете обмануть браузеры, использующие FOIT, заставив их сразу же отрисовывать текст запасными шрифтами, используя только полностью загруженные шрифты из вашей цепочки. Если шрифт ещё не в цепочке (поскольку он загружается), браузеры не будут пытаться скрыть текст.</p>\n<p>Простейший способ сделать это — устанавливать на элемент <code>&#x3C;html></code> по классу на каждое из трёх состояний загрузки веб-шрифта: сам процесс загрузки, его завершение и ошибку. Класс <code>fonts-loading</code> устанавливается сразу, как начинается загрузка, <code>fonts-loaded</code> — когда шрифт загружен, и <code>fonts-failed</code> — если загрузка не удалась.</p>\n<pre><code>var font = new FontFaceObserver('Output Sans');\nvar html = document.documentElement;\n\nhtml.classList.add('fonts-loading');\n\nfont.load().then(function () {\n    html.classList.remove('fonts-loading');\n    html.classList.add('fonts-loaded');\n}).catch(function () {\n    html.classList.remove('fonts-loading');\n    html.classList.add('fonts-failed');\n});\n</code></pre>\n<p>При помощи этих классов и простого CSS вы можете кроссбраузерно использовать FOUT. Начнём с объявления запасных шрифтов для всех элементов, которым понадобятся веб-шрифты. Когда в <code>&#x3C;html></code> появляется класс <code>fonts-loaded</code>, мы применяем веб-шрифт, изменяя цепочку шрифтов для всех соответствующих элементов. Изменение правила в CSS заставит браузер загрузить веб-шрифт, однако, поскольку к этому моменту он уже будет загружен, перерисовка начнется практически мгновенно.</p>\n<pre><code>body {\n    font-family: Verdana, sans-serif;\n}\n\n.fonts-loaded body {\n    font-family: Output Sans, Verdana, sans-serif;\n}\n</code></pre>\n<p>Такой способ загрузки шрифтов может показаться вам похожим на технику прогрессивного улучшения. Так оно и есть: <em>мелькание текста без стилей</em> (FOUT) соответствует прогрессивному улучшению. Базовый вид в первую очередь отрисовывается запасными шрифтами, а затем улучшается веб-шрифтами.</p>\n<p>Реализация FOIT такая же простая. Когда веб-шрифты начинают загрузку, вы скрываете контент, использующий шрифты, а когда они загружены, вы показываете его снова. Не забывайте и об ошибке загрузки — контент должен быть доступен, даже если шрифты не смогли загрузиться.</p>\n<pre><code>.fonts-loading body {\n    visibility: hidden;\n}\n\n.fonts-loaded body,\n.fonts-failed body {\n    visibility: visible;\n}\n</code></pre>\n<p>Такой способ сокрытия контента кажется вам странным? Хорошо, если так. Этот паттерн следует применять только в очень специфичных случаях. Например, если у вас нет подходящего запасного шрифта, или вы точно знаете, что шрифт был закэширован ранее.</p>\n<h2>Оптимизация для кэширования</h2>\n<p>Все предыдущие паттерны позволяли вам регулировать когда и как загружаются шрифты. Однако, часто мы хотим, чтобы в зависимости от наличия или отсутствия шрифта в кэше сайт вёл себя по-разному. Например, если шрифт закэширован, нет необходимости отрисовывать текст сначала запасным шрифтом. Такого эффекта можно добиться сохранением в Session Storage статуса о том, был ли шрифт закэширован или нет.</p>\n<p>Когда шрифт загружен, мы устанавливаем флаг в Session Storage. Флаг сохраняется на протяжении всей сессии, и с его помощью мы можем определить, находится файл в браузерном кэше или нет.</p>\n<pre><code>var font = new FontFaceObserver('Output Sans');\n\nfont.load().then(function () {\n    sessionStorage.fontsLoaded = true;\n}).catch(function () {\n    sessionStorage.fontsLoaded = false;\n});\n</code></pre>\n<p>Теперь вы можете использовать эту информацию, чтобы изменить стратегию загрузки закэшированных шрифтов. Например, можно включить такой фрагмент JavaScript в элемент <code>&#x3C;head></code> вашей страницы, чтобы сразу же отрисовывать веб-шрифты.</p>\n<pre><code>if (sessionStorage.fontsLoaded) {\n    var html = document.documentElement;\n    html.classList.add('fonts-loaded');\n}\n</code></pre>\n<p>Если вы будете загружать шрифты этим способом, ваши посетители увидят FOUT только при первом посещении сайта, а при всех дальнейших переходах шрифт будет отрисовываться мгновенно. А значит, с одной стороны, вы сохраните выгоды, которые даёт прогрессивное улучшение, а с другой — сделаете сайт удобным, поскольку загрузка страниц будет меньше раздражать при повторных посещениях.</p>\n<p>Перевод оригинальной статьи «<a href=\"https://www.bramstein.com/writing/web-font-loading-patterns.html\">Web Font Loading Patterns</a>» Брэма Штайна. Перевод <a href=\"https://github.com/aalexeev239\">Андрея Алексеева</a>, редактура <a href=\"http://pepelsbey.net\">Вадима Макеева</a>.</p>","frontmatter":{"title":"Паттерны загрузки веб-шрифтов","date":"14 июня 2016"}}},"pageContext":{"slug":"/articles/web-font-loading-patterns/"}}