{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"5b479ddb-538d-50bc-85a2-8da9e9518ae7","excerpt":"Быстродействие фронтенда для дизайнеров и разработчиков Гарри Робертс  15 апреля 2013 Вряд ли кто-то будет отрицать, что быстродействие…","html":"<h1>Быстродействие фронтенда для дизайнеров и разработчиков</h1>\n<p><a href=\"http://csswizardry.com\">Гарри Робертс</a> 15 апреля 2013</p>\n<p>Вряд ли кто-то будет отрицать, что быстродействие — один из <em>ключевых</em> аспектов любого более-менее серьёзного веб-проекта: будь это маленький сайт-портфолио, мобильное веб-приложение, или полноценный проект интернет-магазина. Исследования, статьи и ваш собственный опыт подсказывают: чем быстрее, тем лучше.</p>\n<p>Быстродействие — это не только крайне важный, но и <em>невероятно</em> интересный предмет, и я все больше и больше увлекаюсь им и на работе (я вечно достаю на этот счет нашего ведущего специалиста по быстродействию), и в собственных проектах, и в рамках CSS Wizardry (здесь достаётся <a href=\"http://twitter.com/andydavies\">Энди Дэвису</a>).</p>\n<p>В этой гигантской статье я поделюсь с вами множеством быстрых, простых, но очень интересных вещей, которые я узнал о быстродействии: надеюсь, они пригодятся и веб-дизайнерам, и фронтенд-разработчикам, а вся эта статья послужит вводной для любого, кто хочет начать заниматься быстродействием и сделать свой фронтенд молниеносно быстрым. Все эти советы вы можете воплотить в жизнь сами, и <em>очень</em> просто. Нужно немножко хитрости и базовые знания о том, как работают браузеры — и всё, вы готовы обыграть систему!</p>\n<p>Здесь не будет кучи путаных графиков и трудноперевариваемых цифр. Вместо этого мы сделаем акцент на теории и приемах для повышения быстродействия, которые я освоил, читая, отслеживая, учась у коллег и экспериментируя (достаточно много времени я провел, просто уставившись в каскад отрисовки CSS Wizardry). Кроме того, я дам ссылки на другие статьи по теме, чтобы подчеркнуть какие-то ключевые моменты. Наслаждайтесь!</p>\n<p><strong>N.B.</strong> Чтобы эта статья была полезной, вам все-таки нужно немножко знать о быстродействии, но все незнакомые термины, которые будут упоминаться в этой статье, очень легко нагуглить!</p>\n<ol>\n<li>\n<p><a href=\"#section:the-basics\">Принципы</a></p>\n<ol>\n<li><a href=\"#section:styles-at-the-top-scripts-at-the-bottom\">Стили наверху, скрипты внизу</a></li>\n<li><a href=\"#section:make-fewer-requests\">Делайте меньше запросов</a></li>\n<li><a href=\"#section:maximising-parallelisation\">Максимальная параллелизация</a></li>\n</ol>\n</li>\n<li>\n<p><a href=\"#section:http-requests-and-dns-lookups\">HTTP-запросы и поиск DNS</a></p>\n<ol>\n<li><a href=\"#section:dns-prefetching\">Предзагрузка DNS</a></li>\n</ol>\n</li>\n<li><a href=\"#section:resource-prefetching\">Предзагрузка ресурсов</a></li>\n<li><a href=\"#section:css-and-performance\">CSS и быстродействие</a></li>\n<li><a href=\"#section:gzipping-and-minifying\">Минификация и gzip</a></li>\n<li>\n<p><a href=\"#section:optimising-images\">Оптимизация изображений</a></p>\n<ol>\n<li><a href=\"#section:spriting\">Спрайты</a></li>\n<li><a href=\"#section:retina-images\">Изображения для ретины</a></li>\n<li><a href=\"#section:progressive-jpgs\">JPG с прогрессивной загрузкой</a></li>\n<li><a href=\"#section:use-no-images-at-all\">Не используйте изображения вообще</a></li>\n</ol>\n</li>\n<li><a href=\"#section:further-reading\">Дальнейшее чтение</a></li>\n</ol>\n<h2>Принципы</h2>\n<p>Практически <em>все</em> дизайнеры и фронтенд-разработчики кое-что знают о быстродействии: например, что нужно делать как можно меньше запросов, оптимизировать изображения, размещать ссылки на стили в <code>&#x3C;head></code>, размещать JS-код перед <code>&#x3C;/body></code>, минимизировать JS и CSS, и т.п. Эти базовые вещи уже помогут вашим страницам загружаться быстрее. Но способов ускорить загрузку ещё много… очень много.</p>\n<p>Ещё очень важно помнить о том, что браузеры (из-за которых у нас каждый рабочий день болит голова) стали <em>очень</em> умными: много работы по оптимизации быстродействия они делают за вас, так что значительная часть рекомендаций сводится к тому, как наилучшим образом использовать эту работу. Многие ноу-хау по быстродействию касаются понимания, использования и настройки того, что браузер уже делает.</p>\n<h3>Стили наверху, скрипты внизу</h3>\n<p>Это простое правило, и следовать ему очень легко, но почему оно имеет такое значение? Если совсем кратко:</p>\n<ul>\n<li><strong>CSS блокирует отрисовку,</strong> поэтому вам нужно разобраться с ним как можно быстрее (то есть в верхней части документа, внутри <code>&#x3C;head></code>).</li>\n<li><strong>JS блокирует загрузки,</strong> так что вам нужно разобраться с ним в последнюю очередь, чтобы быть уверенным, что ваши JS-файлы не мешают загрузке других ресурсов на этой странице.</li>\n</ul>\n<p>CSS блокирует отрисовку, потому что браузеры отображают страницы методом прогрессивной развёртки: они отображают элементы по мере того, как получают их, и по порядку. Если стили находятся внизу страницы, браузер не может обработать этот CSS, пока не доберется до него. Так задумано для того, чтобы браузеру не приходилось перерисовывать стили в том случае, если они изменяют какой-то элемент, который был отображен выше на странице. Браузер не будет рендерить страницу, пока у него нет всей необходимой информации о стилях, и если вы размещаете эту информацию в нижней части документа, вы заставляете браузер ждать и блокируете тем самым отрисовку.</p>\n<p>Так что размещайте CSS в верхней части страницы, чтобы браузер мог начать отрисовку сразу.</p>\n<p>JavaScript блокирует загрузки по ряду причин (браузеры снова умничают), но для начала мы должны знать, как именно происходит загрузка ресурсов в браузерах: если коротко, браузер загружает столько ресурсов, сколько может загрузить <em>параллельно</em> с одного домена. Чем больше доменов задействовано, тем больше ресурсов могут одновременно загружаться параллельно.</p>\n<p>JavaScript прерывает этот процесс и блокирует параллельные загрузки с текущего и всех остальных доменов, потому что:</p>\n<ul>\n<li>Вызванный скрипт может изменить содержимое страницы, и значит, браузер должен разобраться с этим скриптом перед тем, как начать заниматься чем-то ещё. Для этого браузер просто останавливает загрузку всего остального, чтобы полностью сфокусироваться на скрипте.</li>\n<li>Обычно, чтобы скрипты работали, их нужно загружать в определенном порядке: например, нужно загрузить jQuery, а <em>потом</em> плагин. Ясно, что при параллельной загрузке скриптов, сперва загрузится плагин, а <em>только потом —</em> jQuery. Поэтому браузеры блокируют параллельную загрузку JavaScript-файлов.</li>\n</ul>\n<p>Итак, поскольку браузеры приостанавливают загрузки, пока подгружают JavaScript, ссылки на JavaScript-ресурсы следует помещать как можно ниже в документе. Вы наверняка видели пустые части страниц, потому что какой-то сторонний JS грузится веками и блокирует загрузку и обработку ресурсов для всего остального. Это и есть блокирование JavaScript.</p>\n<p>Однако, по всей видимости, современные браузеры стали ещё умнее. Я приведу здесь отрывочек из письма <a href=\"http://twitter.com/andydavies\">Энди Дэвиса</a>, потому что он объясняет все гораздо лучше, чем я:</p>\n<blockquote>\n<p>Современные браузеры загружают JS параллельно, и только отрисовка блокируется до тех пор, пока не исполнится скрипт (разумеется, перед этим браузер должен его загрузить).</p>\n<p>Загрузка скрипта часто осуществляется предзагрузчиком браузера.</p>\n<p>Когда браузер не может отрендерить страницу (например, ждет загрузки CSS или исполнения JS), предзагрузчик анализирует оставшийся код на странице и ищет ресурсы, которые может загрузить.</p>\n<p>Некоторые браузеры (например, Chrome) расставляют приоритеты в загрузке ресурсов: например, если в очередь на загрузку стоят скрипты и изображения, браузер сперва загрузит скрипты.</p>\n</blockquote>\n<p>Умно!</p>\n<p>Итак: для того, чтобы ваша страница могла начать отрисовку как можно быстрее, размещайте стили наверху. Чтобы избежать блокировки загружаемых ресурсов, размещайте скрипты внизу.</p>\n<h3>Делайте меньше запросов</h3>\n<p>Ещё одна совершенно очевидная и базовая оптимизация быстродействия: загружайте меньше. Каждый ресурс на странице — это лишний HTTP-запрос, на каждый ресурс, необходимый для отрисовки страницы, браузер отвлекается. Каждый из этих запросов может привести к поиску DNS, редиректам, обработке 404-й ошибки и т.п. Таким образом, каждый HTTP-запрос, который вы делаете, будь это запрос стилей, картинок, веб-шрифтов, JS-файла, чего угодно — потенциально весьма дорогостоящая операция. Минимизация количества этих запросов — один из самых простых способов оптимизировать быстродействие.</p>\n<p>Возвращаясь к браузерам и параллелизации: большинство браузеров будут загружать всего несколько ресурсов с каждого домена одновременно, а JS, как вы помните, блокирует эти загрузки в любом случае. Каждый HTTP-запрос, который вы делаете, должен быть оправдан, не смотрите на это сквозь пальцы.</p>\n<h3>Максимальная параллелизация</h3>\n<p>Для того, чтобы заставить браузер загружать больше ресурсов параллельно, вы можете отдавать их с разных доменов. Если браузер может загружать одновременно, например, только два ресурса с домена, то, раздавая ресурсы с двух доменов, вы сможете загружать одновременно четыре ресурса; с трёх — значит браузер может выжать шесть одновременных загрузок.</p>\n<p>У большого количества сайтов есть домены для статических ресурсов. Например, Twitter раздает статические ресурсы с <code>si0.twimg.com</code>:</p>\n<pre><code>&#x3C;link rel=\"stylesheet\"\n      href=\"https://si0.twimg.com/…/t1_core.bundle.css\"\n      type=\"text/css\" media=\"screen\">\n</code></pre>\n<p>Facebook использует <code>fbstatic-a.akamaihd.net</code>:</p>\n<pre><code>&#x3C;link rel=\"stylesheet\"\n      href=\"https://fbstatic-a.akamaihd.net/…/76f893pcD3j.css\">\n</code></pre>\n<p>Используя эти домены для статических ресурсов, Twitter и Facebook могут отдавать больше ресурсов параллельно: ресурсы с <code>twitter.com</code> и <code>si0.twimg.com</code> могут загружаться одновременно. Это очень простой способ получить большее количество одновременных загрузок ресурсов на вашей странице, и его можно улучшить, совместив с технологией CDN (она позволяет уменьшить сетевые задержки за счёт того, что ресурс отдается с наиболее подходящего <em>физического</em> сервера).</p>\n<p>Все это замечательно, но ниже мы обсудим, как загрузка ресурсов с поддоменов может при ряде обстоятельств навредить быстродействию.</p>\n<p>Итак, вот наши принципы быстродействия:</p>\n<ul>\n<li>Размещайте ссылки на стили наверху страницы</li>\n<li>Размещайте JavaScript внизу (насколько это возможно)</li>\n<li>Делайте как можно меньше HTTP-запросов</li>\n<li>Раздавая ресурсы с нескольких доменов, вы можете увеличить количество ресурсов, которые браузер будет загружать параллельно.</li>\n</ul>\n<h2>HTTP-запросы и поиск DNS</h2>\n<p>Каждый раз, когда вы делаете запрос на ресурс с какого-либо домена, браузер делает HTTP-запрос с соответствующими заголовками, сервер отвечает и посылает обратно ответ. Это, конечно, очень упрощенная модель процесса, но по-настоящему вам нужно знать только это. Так выглядит HTTP-запрос, и все ресурсы, которые вы запрашиваете, вы получите таким путём. Эти запросы и есть главное узкое место фронтенд-быстродействия: как говорилось выше, браузеры ограничены тем, сколько запросов они могут выполнять параллелльно. Вот почему мы часто используем поддомены: так можно одновременно выполнить большее количество запросов, распределенных по нескольким доменам.</p>\n<p>С этим, однако, есть и проблема — DNS-запросы. Каждый раз, когда делается запрос к <em>новому</em> домену (с холодного кэша), HTTP-запрос должен произвести довольно долгий DNS-запрос (между 20 и 120 мс). За это время исходящий запрос смотрит, где же, собственно, находится ресурс: интернет организован с помощью IP-адресов, на которые ссылаются доменные имена, которые, в свою очередь, управляются DNS.</p>\n<p>В обращение к каждому новому домену, с которого вы запрашиваете ресурсы, включена стоимость DNS-запроса, и вам нужно быть уверенным, что оно того стоит. Если вас сайт небольшой (как, например, CSS Wizardry), тогда вам, скорее всего, не стоит раздавать ресурсы с поддомена: браузер, вероятно, сможет скачать несколько ресурсов с одного домена без параллелизации быстрее, чем сделать DNS-запросы на несколько доменов и распараллелить загрузку ресурсов с них.</p>\n<p>Если у вас десять-пятнадцать ресурсов, вам следуем подумать о том, чтобы раздавать их <strong>с одного</strong> поддомена: скорее всего, лишний DNS-запрос стоит того, чтобы обеспечить лучшую параллелизацию этих ресурсов. Если у вас, например, 40 ресурсов, возможно, имеет смысл разделить их <em>на два</em> поддомена: два лишних DNS-запроса будут оправданной ценой за то, чтобы раздавать ваш сайт с целых трёх доменов.</p>\n<p>DNS-запросы достаточно дороги, так что вам нужно определить, что больше подходит для вашего сайта: издержки на DNS-запросы или просто раздача одного домена.</p>\n<p>Важно помнить, что, если HTML уже запрошен с домена, скажем, <code>foo.com</code>, DNS-запрос для этого хоста уже произошёл, так что дополнительные запросы к любому ресурсу на <code>foo.com</code> больше <em>не проходят</em> через DNS-запрос.</p>\n<h3>Предзагрузка DNS</h3>\n<p>Если вы, как и я, хотите, чтобы у вас на сайте был виджет Twitter, аналитика или какие-то веб-шрифты, то вам <em>нужно</em> будет ссылаться на внешние домены. Это означает, что вам <em>нужно</em> будет тратить время на DNS-запросы. Мой совет: не использовать какие попало виджеты, не обдумав заранее их влияние на быстродействие. Но если вы решили, что какой-то виджет вам <em>необходим</em>, полезно знать следующее.</p>\n<p>Поскольку эти ресурсы располагаются на других доменах, CSS для вашего веб-шрифта, например, будет загружаться параллельно с вашим собственным CSS, что в каком-то смысле хорошо, но скрипты всё равно будут блокировать браузер (<a href=\"http://css-tricks.com/thinking-async/\">если они не асинхронные</a>).</p>\n<p>На самом деле, проблема здесь заключается в DNS-запросах, связанных с внешними доменами. К счастью, есть очень быстрый и лёгкий способ ускорить этот процесс: предзагрузка DNS.</p>\n<p>Что делает предзагрузка DNS, понятно из названия; реализовать её очень просто. Если вам нужно запросить ресурсы, скажем, с <code>widget.foo.com</code>, вы можете предзагрузить DNS для этого поддомена, просто добавив в начале страницы в секции <code>&#x3C;head></code>:</p>\n<pre><code>&#x3C;head>\n    &#x3C;link rel=\"dns-prefetch\" href=\"//widget.foo.com\">\n&#x3C;/head>\n</code></pre>\n<p>Эта простая строчка объявит браузерам, которые поддерживают предзагрузку, что им стоит начать загружать DNS для этого домена за долю секунды до того, как это понадобится сделать для загрузки ресурса. Таким образом, когда браузер дойдёт до элемента <code>&#x3C;script></code>, запрашивающего виджет, DNS-запрос уже будет запущен. Так браузер чуть-чуть опережает события.</p>\n<p>Этот простой элемент <code>&#x3C;link></code> (<a href=\"https://github.com/csswizardry/csswizardry.github.com/blob/b52472cea6a0f087944afda750839d7c96fab7d3/_layouts/default.html#L7-L15\">я использую его на CSS Wizardry</a>) полностью обратно совместим и не отразится отрицательно на быстродействии. Думайте об этом, как о прогрессивном улучшении быстродействия.</p>\n<h3>Дальнейшее чтение</h3>\n<p><a href=\"http://calendar.perfplanet.com/2012/speed-up-your-site-using-prefetching/\">Speed Up Your Site Using Prefetching</a>.</p>\n<h2>Предзагрузка ресурсов</h2>\n<p>Вместе с предзагрузкой DNS очень полезно предзагружать все нужные вашему сайту ресурсы. Чтобы понять, что стоит предзагружать, сначала нужно разобраться, как и когда браузер <em>обычно</em> запрашивает ресурсы.</p>\n<p>Веб-шрифты и изображения, упомянутые в CSS, ведут себя точно так же: браузер начнет загружать их, как только наткнётся на ту часть HTML-кода, для которого они нужны. Как я уже говорил выше, браузеры очень умные, и здесь мы видим ещё одно подтверждение этому. Представьте себе, если бы браузеры загружали изображения из CSS, как только увидели в стилях следующее:</p>\n<pre><code>.page--home         { background-image: url(home.jpg); }\n.page--about        { background-image: url(about.jpg); }\n.page--portfolio    { background-image: url(portfolio.jpg); }\n.page--contact      { background-image: url(contact.jpg); }\n</code></pre>\n<p>Если бы браузер <em>не ждал,</em> пока дело дойдёт до HTML, требующего эти картинки, при заходе на главную страницу он бы скачивал все четыре изображения. Это крайне расточительное использование ресурсов, поэтому, перед тем, как скачивать картинку, браузер должен быть уверен, что она ему <em>определенно</em> нужна. Проблема здесь в том, соответственно, что загрузки не происходит до последнего момента.</p>\n<p>Если же мы полностью уверены, что какое-то изображение из CSS <em>точно</em> будет использоваться на каждой странице, мы можем обмануть браузер и заставить его скачать это изображение как можно раньше, ещё <em>до того,</em> как он доберется до HTML, которому оно требуется. Сделать это невероятно просто, но, в зависимости от того, как именно вы решите это сделать, это может быть немного грязным приёмом.</p>\n<p>Итак, грязный, но самый безопасный способ: поставить на каждой странице скрытый <code>&#x3C;div></code>, в котором при помощи элементов <code>&#x3C;img></code> с пустым атрибутом <code>alt</code> вставлены все изображения из CSS. Я поступил так со <a href=\"https://github.com/csswizardry/csswizardry.github.com/blob/b52472cea6a0f087944afda750839d7c96fab7d3/_layouts/default.html#L41-L44\">спрайтом на CSS Wizardry</a>; я знаю, что они используется на каждой странице, и поэтому с уверенностью могу предзагружать его в своем HTML. Браузеры замечательно обрабатывают теги <code>&#x3C;img></code>: предзагружая картинку, браузер обращается к ней очень рано, поэтому, заставив его загрузить спрайты с помощью тега <code>&#x3C;img></code> в разметке, мы добиваемся более ранней загрузки изображения, чем затребовал бы CSS. Таким образом, упомянув (скрытое) изображение в HTML, я ускоряю эту загрузку.</p>\n<p>Со вторым, более «чистым» способом, который очень похож на пример с предзагрузкой DNS, есть некоторая путаница:</p>\n<pre><code>&#x3C;link rel=\"prefetch\" href=\"sprite.png\">\n</code></pre>\n<p>Этот код прямо говорит браузеру, что нужно начать предзагружать мое изображение со спрайтами, вне зависимости от того решения, которые он может принять после обработки CSS.</p>\n<p>Путаница заключается в несогласованности между двумя статьями: <a href=\"https://developer.mozilla.org/en-US/docs/Link_prefetching_FAQ\">по этой статье с MDN</a> можно понять, что <code>prefetch</code> — подсказка для браузера, что, <em>может быть,</em> стоит предзагрузить ресурс, <em>если</em> браузер сейчас ничем не занят. Напротив, <a href=\"http://calendar.perfplanet.com/2012/speed-up-your-site-using-prefetching/\">в этой статье</a> с Planet Performance сказано, что браузер всегда будет предзагружать ресурсы, если он поддерживает синтаксис <code>rel=\"prefetch\"</code>, и не упоминается, что это будет сделано «в свободное время». Графики загрузки, на которые я смотрел, <em>вроде бы</em> подтверждают второй вариант, но странный глюк в WebKit, из-за которого нельзя наблюдать результаты предзагрузки, если у тебя открыт отладчик (привет, быстродействие Шредингера!), приводит к том, что я не могу быть уверенным на 100%. Буду <em>очень благодарен</em> за любые комментарии по этому поводу.</p>\n<p>Я уже говорил, что шрифты и изображения работают почти одинаково: сказанное выше относится и к файлам шрифтов, но шрифт нельзя загрузить в спрятанном <code>&#x3C;div></code>, нужно использовать <code>prefetch</code>.</p>\n<pre><code>&#x3C;link rel=\"prefetch\" href=\"webfont.woff\">\n</code></pre>\n<p>Проще говоря, мы делаем следующее: заставляем браузер скачать наш ресурс заранее, так что к тому времени, как нужно будет применять наш CSS, он уже будет скачан (ну или хотя бы начнет скачиваться). Ура!</p>\n<h3>Дальнейшее чтение</h3>\n<p><a href=\"http://calendar.perfplanet.com/2012/speed-up-your-site-using-prefetching/\">Speed Up Your Site Using Prefetching</a>.</p>\n<h2>CSS и быстродействие</h2>\n<p>Во множестве разных статей написано, что, если вы используете отдельные домены для ресурсов, то с них нужно загружать все статические ресурсы: CSS, JS, изображения и т.п.</p>\n<p>Одно из маленьких открытий, которое мы сделали в процессе работы, звучит так: <em>не раздавайте</em> CSS с поддомена.</p>\n<p>Помните, как мы обсуждали блокировку отрисовки загрузкой стилей. Браузер хочет получить ваш CSS как можно скорее, CSS находится на <em>критическом пути —</em> то есть на том необходимом пути, который браузер проходит от момента, когда пользователь затребовал страницу, и до того, когда он что-то увидел. В отличие от JS и изображений, CSS находится там из-за своего свойства блокировать отрисовку. В ваших интересах проходить критический путь настолько быстро, насколько это возможно — то есть <strong>без дополнительных DNS-запросов</strong>.</p>\n<p>Однажды мы разрабатывали сайт, рабочее окружение которого раздавало все ресурсы с одного хоста (например, <code>foo.com</code>), но когда дело дошло до того, чтобы сделать его более приближенным к реальному, мы начали раздавать ресурсы с <code>s1.foo.com</code> и <code>s2.foo.com</code>. Получилось, что все изображения, JS, CSS и шрифты были расположены на разных доменах, что приводило к нескольким DNS-запросам. Проблема здесь в том, что неоходимый для получения CSS-файла DNS-запрос, отправленный из холодного кэша, <em>сразу же</em> замедлял наш критический путь. Наши графики ужасно скакнули, показывая задержку, которой в теории не должно было случиться: все прогрессивные практики диктуют, что вы должны распределять большое количество ресурсов по поддоменам, не правда ли? CSS это <strong>не касается</strong>. Необходимый DNS-запрос занимал ощутимое время, на которое в итоге задерживалась отрисовка страницы.</p>\n<p>CSS — один из самых страшных врагов быстродействия, <a href=\"http://www.phpied.com/css-and-the-critical-path/\">подчеркивает Стоян Стефанов</a>, — именно из-за этой блокировки отрисовки. Также стоит отметить, что браузер скачает <em>все</em> CSS-файлы перед тем, как начнет рендерить страницу. Это значит, что браузер <em>в любом случае</em> запросит <code>print.css</code>, даже если страница всего лишь выводится на экран. Это значит, что все стили, которые используются только вместе с медиавыражениями, например, следующие стили, скачаются в любом случае, даже если они не нужны:</p>\n<pre><code>&#x3C;link rel=\"stylesheet\"\n      media=\"screen and (min-device-width: 800px)\"\n      href=\"desktop.css\">\n</code></pre>\n<p>Впрочем, <a href=\"http://twitter.com/andydavies\">Энди Дэвис</a> сообщил мне, что WebKit расставляет приоритеты в порядке загрузки CSS таким образом, что <em>сперва</em> загружается только тот CSS, который нужен для первоначального отображения страницы, а загрузка всех остальных стилей (например, <code>print.css</code>) как можно дольше откладывается. Отлично!</p>\n<p>Итак, то, что знаем про CSS, позволяет нам принять несколько решений и все они основаны на знании, что CSS блокирует отрисовку, запрашивается <em>весь сразу</em> и находится на вашем критическом пути:</p>\n<ul>\n<li><strong>Никогда не раздавайте CSS с отдельного домена,</strong> поскольку это приводит к задерживающим отрисовку DNS-запросам.</li>\n<li><strong>Вставляйте CSS в HTML-код как можно раньше,</strong> чтобы браузер мог скачать его и заняться другими вещами.</li>\n<li><strong>Собирайте CSS в один файл.</strong> Браузер все равно скачает весь CSS, поэтому гораздо лучше просто собрать все, что у вас есть, в один HTTP-запрос.</li>\n<li><strong>Сожмите его с помощью gzip и минифицируйте,</strong> чтобы браузеру пришлось загружать меньше.</li>\n<li><strong>Закэшируйте все, что можно,</strong> чтобы весь этот процесс происходил как можно реже.</li>\n</ul>\n<p>CSS находится на вашем критическом пути, так что вам нужно разобраться с ним быстро; он блокирует отрисовку, это означает, что пользователям загрузка страницы будет казаться медленной. <strong>Когда мы перенесли CSS на поддомен, наше быстродействие резко упало.</strong></p>\n<h3>Дальнейшее чтение</h3>\n<p><a href=\"http://www.phpied.com/css-and-the-critical-path/\">CSS And the Critical Path</a></p>\n<h2>Минификация и gzip</h2>\n<p>Есть две простые вещи, которые вы можете (и должны) сделать со своими текстовыми ресурсами: минификация, чтобы убрать комментарии и пробелы, и сжатие с помощью gzip, чтобы ещё сильнее уменьшить размер.</p>\n<p>Если выбирать из этого только что-то одно, то gzip эффективнее, чем минификация. Но если вы можете, делайте и то и другое.</p>\n<p><em>Обычно</em> для того, чтобы включить gzip, нужно чуть-чуть поиграть с <code>.htaccess</code>, но, как подсказывает мой добрый друг <a href=\"http://twitter.com/makeusabrew\">Ник Пэйн</a>, <code>.htaccess</code> — не самая лучшая вещь с точки зрения серверного быстродействия — <code>.htaccess</code> заново анализируется на <em>каждом</em> входящем запросе, поэтому при его использовании возникает достаточно большая нагрузка.</p>\n<p>Итак, <a href=\"http://httpd.apache.org/docs/2.2/howto/htaccess.html\">из документации Apache</a>:</p>\n<blockquote>\n<p>Вам стоит перестать использовать <code>.htaccess</code> полностью, если у вас есть доступ к конфигурационному файлу главного httpd-сервера. Использование <code>.htaccess</code> замедляет ваш Apache. Любую директиву, которую вы включаете в <code>.htaccess</code>, гораздо лучше поместить в блок <code>Directory</code>, поскольку эффект будет таким же, а быстродействие — лучше…</p>\n</blockquote>\n<p>Если же у вас есть только доступ к <code>.htaccess</code>, не волнуйтесь: эта нагрузка <em>обычно</em> настолько маленькая, что беспокоиться о нёй на стоит. Включить gzip с помощью <code>.htaccess</code> на самом деле очень просто. С минификацией сложнее, разве что у вас есть процесс сборки проекта, или если вы используете какой-то препроцессор или CodeKit, который компилирует исходники сразу в минифицированную версию.</p>\n<p>Кстати, главной причиной, по которой я переписал <a href=\"http://inuitcss.com/\">inuit.css</a> на Sass было (по крайней мере, сперва) то, что я мог легко скомпилировать минифицированную версию.</p>\n<p>Основной эффект минификации сводится к тому, что она убирает пробелы и комментарии — если вы комментируете свой код так же подробно, как я, то вы наверняка захотите минифицировать свои ресурсы.</p>\n<p>Gzip, как и любой другой алгоритм сжатия, берет любой <em>текстовый</em> исходник и сжимает его на основании повторяющихся строк. В целом, gzip сжимает код очень хорошо, потому что в любом коде, как правило, есть типовые строки, которые повторяются: например, <code>background-image</code> в CSS, <code>&#x3C;strong></code> в разметке и т.п.</p>\n<p>Gzip <em>действительно</em> очень сильно уменьшает размер ваших ресурсов, и вам определенно нужно включать его. Если вам нужен хороший пример <code>.htaccess</code>, посмотрите, как это сделано <a href=\"https://github.com/h5bp/html5-boilerplate/blob/dac15682b35ad69f519205e1b82694d0cab189ca/.htaccess#L153\">в HTML5 Boilerplate</a>.</p>\n<p>Сжатие вашего контента это <em>гигантская</em> экономия. На данный момент <code>inuit.css</code> весит 77 КБ. После минификации и gzip-сжатия он весит всего лишь <strong>5,52 КБ</strong>. Таким образом, эти два приема дают нам экономию в 93%. Ну а раз gzip хорошо работает на текстовых ресурсах, то вы можете сжимать с его помощью и SVG, и даже некоторые форматы шрифтов!</p>\n<h2>Оптимизация изображений</h2>\n<p>Я не могу сказать, что я какой-то запредельный специалист в науке оптимизации изображений — я просто прогоняю их через утилиту оптимизации, но разбираться собственно с изображениями и их постобработкой очень интересно.</p>\n<h3>Спрайты</h3>\n<p>Если вы хотите, чтобы ваш сайт обладал хорошим быстродействием, спрайты просто-напросто обязательны: вы загружаете одну большую картинку через один HTTP-запрос, а не несколько изображений за несколько запросов. Проблема состоит в том, что не все изображения можно объединить в спрайт: например, если у вас есть иконка, которая должна быть фоновым изображением на элементе переменной длины, то у вас не получится это сделать — это не работает для элементов, размеры которых не фиксированы. Вы можете оставить много свободного места вокруг картинки в своём спрайте, но <a href=\"http://blog.vlad1.com/2009/06/22/to-sprite-or-not-to-sprite/\">лишние пиксели в спрайтах сами по себе являются проблемой для быстродействия</a>.</p>\n<p>Чтобы справиться с изображениями, которые нельзя поместить в спрайты, нам понадобится «спрайтовый элемент». По сути, это просто пустой элемент, обычно <code>&#x3C;i></code>, единственная задача которого — оставаться пустым и содержать фоновое изображение. (Всё же элемент <code>&#x3C;i></code> имеет <a href=\"/articles/i-b-em-strong-elements/\">другое назначение</a> и здесь больше подойдёт <code>&#x3C;span></code> — <em>прим. редактора.)</em></p>\n<p>Я использовал такие элементы, когда разрабатывал <a href=\"http://www.skybet.com/\">Sky Bet</a>, они используются на YouTube и Facebook, а <a href=\"http://twitter.com/snookca\">Джонатан Снук</a> написал <a href=\"http://smacss.com/book/icon-module\">целый раздел о них на SMACSS</a>.</p>\n<p>Идея такая: если вы не можете использовать в элементе спрайт из-за того, что элемент тянется, то вы помещаете внутрь пустой элемент, чтобы иметь возможность поправить размеры. После этого сможете уже собрать спрайты в один файл, например:</p>\n<pre><code>&#x3C;li>\n    &#x3C;a href=\"/profile/\">\n        &#x3C;i class=\"icon icon--person\">&#x3C;/i> Profile\n    &#x3C;/a>\n&#x3C;/li>\n</code></pre>\n<p>Здесь мы не можем отправить в спрайты ни для <code>&#x3C;li></code>, ни для <code>&#x3C;a></code>, так что мы просто ставим пустой <code>&#x3C;i></code>, в котором и находится иконка. Именно это — одна из тех вещей, которые я больше всего люблю в теме быстродействия: вы используете разные умные приемы, чтобы увеличить скорость загрузки страницы, но при этом используете разметку, которая традиционно считается «плохой». Отлично же!</p>\n<h3>Дальнейшее чтение</h3>\n<p><a href=\"http://blog.vlad1.com/2009/06/22/to-sprite-or-not-to-sprite/\">To Sprite Or Not To Sprite</a>.</p>\n<h2>Изображения для ретины</h2>\n<p>Вам не нужно готовить для ретины <em>все</em> изображения. Картинка в два раза больше по ширине и высоте содержит <strong>в четыре раза</strong> больше пикселей, чем такая же картинка в стандартном разрешении. В четыре. Раза. Хоть это и не значит, что размер файла увеличится соответственно — все-таки у изображений свои методы сжатия — но памяти на это изображение требуется <em>в четыре раза больше</em>.</p>\n<p>Давайте мы на секунду остановимся и подумаем: изображения для ретины чаще всего (хоть и необязательно) нужны для того, чтобы отображение дизайна на телефонах было более четким. У телефонов гораздо меньше памяти, чем у других устройств. Таким образом, изображения для ретины занимают кучу памяти на устройствах, у которых, как известно, лишней памяти немного… Подумайте ещё раз, действительно ли вам нужны изображения для ретина, или вы можете пойти на разумный компромисс?</p>\n<p>Изображения для ретины прекрасны, когда вам нужна красивая четкая графика, но нет никакого смысла в четкой графике, если на то, чтобы загрузить ее, уходит пять секунд. В большинстве случаев скорость должна стоять выше эстетики.</p>\n<p>Вы можете побыть умным и отдавать всем устройствам изображения в 1,5 раза больше (чтобы на всех устройствах были достаточно хорошими), но, по-моему, лучше всего будет использовать изображения для ретины только тогда, когда это нужно.</p>\n<p>Если ваша статистика использования браузеров позволяет, вместо растровых изображений вы можете использовать SVG или шрифт с иконками. На CSS Wizardry я использую SVG и это даёт мне следующие преимущества:</p>\n<ul>\n<li>Независимость от разрешения</li>\n<li>Можно минифицировать</li>\n<li>Можно сжимать в gzip</li>\n</ul>\n<p>Мой коллега <a href=\"http://twitter.com/sdmix\">Мэтт Аллен</a> сделал шрифт с иконками, который можно использовать вместе со спрайтовым элементом, чтобы на странице были пригодные для ретина-дисплеев масштабируемые иконки.</p>\n<p>Ещё вы можеете попробовать сервисы вроде <a href=\"http://resrc.it/\">ReSRC.it</a>, чтобы загружать изображения в зависимости от устройства и дополнительных условий.</p>\n<h3>JPG с прогрессивной загрузкой</h3>\n<p>Ещё один интересный аспект быстродействия — это его <em>восприятие</em>: дело не только в том, что говорят цифры, но и в том, есть ли <em>ощущение,</em> что сайт быстрый.</p>\n<p>Вам наверняка знакома прерывистая загрузка больших JPG-изображений: 100 пикселей картинки загрузилось, пауза, ещё 50, пауза, потом ещё 200, потом — <strong>бах! —</strong> вся картинка загрузилась.</p>\n<p>Это работа <em>обычного</em> (baseline) JPG, и она действительно выглядит крайне прерывистой. Если вы переключаетесь на JPG с прогрессивной загрузкой, всё происходит намного веселее: сперва появляется вся картинка, но сильно размытая, затем изображение постепенно фокусируется. Звучит хуже, чем предыдущем варианте, но на самом деле <em>ощущается</em>, что загрузка идет быстрее: пользователь сразу что-то видит, а качество постепенно улучшается. Эти изображения, как правило, чуть тяжелее своих стандартных версий, но в целом будет казаться, что изображение загружается <em>намного</em> быстрее.</p>\n<p>Для того, чтобы создать JPG с прогрессивной загрузкой, нужно всего лишь включить соответствующий флажок в диалоге «Save for Web» в Photoshop — и дело сделано!</p>\n<h3>Дальнейшее чтение</h3>\n<p><a href=\"http://calendar.perfplanet.com/2012/progressive-jpegs-a-new-best-practice/\">Progressive JPEGs: a New Best Practice.</a></p>\n<h3>Не используйте изображения вообще</h3>\n<p>Лучше, чем спрайты, SVG и игнорирование ретины — полный отказ от изображений. Если вы можете сверстать дизайн картинкой со стопроцентной точностью, а повторить его чистым CSS с точностью 75% — лучше выберите CSS-решение (конечно, если для этого не потребуются лишние сто строчек кода!). Если у вас нет картинок — нет и HTTP-запросов, а также это упрощает поддержку сайта. Если вы можете не использовать изображения — не используйте.</p>\n<h2>Итоги</h2>\n<p>Итак, вот целая куча решений (а на самом деле всего ничего), что вы можете применить, чтобы заставить браузер загружать клиентский код быстрее. Понимая, как работают браузеры, мы можем построить свой код так, чтобы наш фронтенд работал <em>ещё</em> быстрее.</p>\n<p>Если у вас есть предложения, что можно было бы сюда добавить — или вы не согласны, или хотите поправить меня — пожалуйста, присоединяйтесь к обсуждению; весь этот мир быстродействия для меня относительно нов, поэтому я очень хочу продолжать учиться у других и узнавать что-то новое.</p>\n<p>Я очень надеюсь, что эта простыня хоть немного помогла вам, и, прочитав её, вы получили знания о вещах, о которых вы, возможно, никогда бы и не задумались. Ещё я надеюсь, что эта статья помогла вам хотя бы <em>вполовину</em> так заинтересоваться вопросами быстродействия, как ими заинтересовался я.</p>\n<p>Я особенно хотел бы поблагодарить <a href=\"http://twitter.com/makeusabrew\">Ника Пэйна</a> и <a href=\"http://twitter.com/andydavies\">Энди Дэвиса</a> за помощь в прояснении нескольких вещей, которые я описал в этой статье. Спасибо, парни!</p>\n<h2>Дальнейшее чтение</h2>\n<p>Если вам понравилась эта статья и вы хотите узнать ещё, я настоятельно рекомендую следующее:</p>\n<ul>\n<li>Книги Стива Саудерса: <a href=\"http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309\">High Performance Web Sites</a> и <a href=\"http://www.amazon.com/Even-Faster-Web-Sites-Performance/dp/0596522304\">Even Faster Web Sites</a>.</li>\n<li><a href=\"http://www.phpied.com/\">Сайт Стояна Стефанова</a>.</li>\n<li><a href=\"http://www.igvita.com/\">Сайт Ильи Григорика</a>.</li>\n<li><a href=\"http://twitter.com/andydavies\">Читать Энди Дэвиса</a>.</li>\n</ul>\n<p>Перевод оригинальной записи «<a href=\"http://csswizardry.com/2013/01/front-end-performance-for-web-designers-and-front-end-developers/\">Front-end performance for web designers and front-end developers</a>» Гарри Робертса (Harry Roberts), опубликованной на сайте <a href=\"http://csswizardry.com\">CSS Wizardry</a>. Переведено и опубликовано с разрешения автора.</p>\n<p>Перевод <a href=\"http://www.facebook.com/vlad.andersen\">Влада Андерсена</a>, редактура <a href=\"http://pepelsbey.net\">Вадима Макеева</a> и <a href=\"http://engel-t.moikrug.ru\">Ольги Алексашенко</a>.</p>","frontmatter":{"title":"Быстродействие фронтенда для дизайнеров и разработчиков","date":"15 апреля 2013"}}},"pageContext":{"slug":"/articles/front-end-performance/"}}