{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"0214cc22-ada8-5091-bf6a-e8c69fcd224d","excerpt":"Почему у нас нет селектора по родителю Джонатан Снук  20 сентября 2011 Относительно регулярно я вижу дискуссии о том, должен ли CSS включать…","html":"<h1>Почему у нас нет селектора по родителю</h1>\n<p><a href=\"http://snook.ca/\">Джонатан Снук</a> 20 сентября 2011</p>\n<p>Относительно регулярно я вижу дискуссии о том, должен ли CSS включать селектор по родителю и, пока я не выяснил, как работает движок браузера, сам строил предположения по этому поводу.</p>\n<p>Вкратце: <em>производительность</em>.</p>\n<h2>Как работает CSS</h2>\n<p>В связи с моей работой я делаю много тестов производительности. Для определения «узких мест» мы используем массу приложений. Например, Google Page Speed, который дает рекомендации по улучшению производительности JavaScript и рендеринга. Прежде чем я перейду к рассмотрению этих рекомендаций, нам нужно разобраться как браузеры работают с CSS</p>\n<h2>Стиль элемента применяется в момент его создания</h2>\n<p>Мы часто рассматриваем веб-страницы как полноценные документы, наполненные элементами и содержимым. Между тем, браузеры разработаны так, чтобы обрабатывать документ потоково. Они начинают получать документ с сервера и могут начать его отображать до момента полной загрузки. Каждый узел анализируется и отображается в окне по мере получения.</p>\n<p>Взгляните на этот документ:</p>\n<pre><code>&#x3C;body>\n    &#x3C;div id=\"content\">\n        &#x3C;div class=\"module intro\">\n            &#x3C;p>Lorem Ipsum&#x3C;/p>\n        &#x3C;/div>\n        &#x3C;div class=\"module\">\n            &#x3C;p>Lorem Ipsum&#x3C;/p>\n            &#x3C;p>Lorem Ipsum&#x3C;/p>\n            &#x3C;p>Lorem Ipsum &#x3C;span>Test&#x3C;/span>&#x3C;/p>\n        &#x3C;/div>\n    &#x3C;/div>\n&#x3C;/body>\n</code></pre>\n<p>Браузер начинает сначала и видит элемент <code>&#x3C;body></code>. В этот момент времени считается, что этот узел не имеет дочерних узлов. Ничего более не рассматривается. Браузер определяет соответствующий ему обобщенный набор стилей и применяет его к элементу. Какой шрифт, цвет, интерлиньяж? После того, как это все будет выяснено, элемент отображается на экране.</p>\n<p>Далее браузер видит элемент <code>&#x3C;div></code> со значением атрибута ID <code>content</code>. И снова в этот момент времени браузер считает его пустым. Он не рассматривает другие элементы. Как только браузер рассчитает стиль, элемент отображается на экране. Затем браузер определяет нужно ли перерисовать <code>&#x3C;body></code> — стал ли элемент шире или выше? Я подозреваю, что там есть масса других проверок, но изменение ширины и высоты — самый распространенный способ повлиять на отображение родительского узла.</p>\n<p>Процесс продолжается, пока браузер не достигнет корневого узла документа.</p>\n<p>Вот как выглядит визуализация процессов перерисовки в Firefox:</p>\n<iframe width=\"510\" height=\"382\" src=\"http://www.youtube.com/embed/ZTnIxIA5KGw\" frameborder=\"0\"></iframe>\n<h2>CSS селекторы анализируется справа налево</h2>\n<p>Чтобы определить, применяется ли CSS-правило к определенному элементу, браузер рассматривает селектор справа налево.</p>\n<p>Если у вас есть селектор <code>body div#content p { color: #003366; }</code>, то, когда каждый элемент появляется на странице, браузер проверяет, является ли он параграфом. Если да, он начинает подниматься вверх по DOM и ищет <code>&#x3C;div></code> со значением атрибута ID равным <code>content</code>. Если он его находит, то продолжает подниматься по DOM пока не найдет <code>&#x3C;body></code>.</p>\n<p>Таким образом, читая селектор справа налево, браузер значительно быстрее может определить применяется ли правило к элементу. Чтобы определить, какой из селекторов обладает большей производительностью, нужно выяснить, как много узлов придется рассмотреть, чтобы определить, можно ли применить правило к элементу.</p>\n<h2>Правила</h2>\n<p>Возвращаясь к Page Speed, давайте рассмотрим <a href=\"http://code.google.com/speed/page-speed/docs/rendering.html#UseEfficientCSSSelectors\">несколько его рекомендаций</a>:</p>\n<ul>\n<li>Избегайте селектора по потомку: <code>.content .sidebar</code>;</li>\n<li>Избегайте селектора по дочернему элементу: <code>.content > .sidebar</code> и селектора по следующему элементу: <code>.content + .sidebar</code>.</li>\n</ul>\n<p>Конечно, селекторы по ID — самые быстрые. Проверить применимость селектора <code>#content</code> к рассматриваемому элементу можно очень быстро. Есть у него этот ID или нет? Селекторы по классу практически такие же быстрые, так как нет никаких связанных элементов, которые надо проверять.</p>\n<p>Селекторы по потомкам, такие как <code>.content .sidebar</code> — более ресурсоемкие, так как, чтобы определить надо ли применять правило к <code>.sidebar</code>, браузер должен найти <code>.content</code>. Cелектор по дочернему элементу, например, <code>.content > .sidebar</code>, лучше селектора по потомку, так как браузер должен проверить только один элемент вместо множества.</p>\n<p>К сожалению, селекторы <code>+</code> и <code>></code> не поддерживаются IE6. Так что если его поддержка актуальна для вас, то про них придется забыть. Примечание переводчика.</p>\n<h2>Селектор по тегу и универсальный селектор</h2>\n<p>В рамках рекомендации избегать селекторов по потомку, дочернему или следующему элементам, рекомендуется избегать универсального селектора и селектора по тегу.</p>\n<p>Рассмотрим следующий пример:</p>\n<pre><code>#content * { color: #039; }\n</code></pre>\n<p>Так как в селекторе присутствует ID, то можно подумать, что этот селектор обрабатывается очень быстро. Проблема в том, что браузер обрабатывает селектор справа налево и сперва проверяется универсальный селектор. Для того чтобы браузер мог определить, должен ли цвет текста элемента быть тёмно-синим, надо проверить каждый предок элемента, пока не будет найден предок с атрибутом ID равным <code>content</code> или не будет достигнут корень документа.</p>\n<p>И это должно быть сделано для каждого элемента на странице.</p>\n<p>Теперь, когда мы понимаем, как элемент обрабатывается, как определяется применимость правил к элементу, давайте рассмотрим пример.</p>\n<h2>Почему IE долго не поддерживал <code>:last-child</code></h2>\n<p>Все жаловались: у всех браузеров, кроме IE, есть поддержка <code>:last-child</code> (она появилась только в IE9!) Некоторые могли подумать <q>насколько же сложнее сделать :last-child, если уже реализован :first-child?</q></p>\n<p>Давайте представим, что мы — браузер и мы парсим документ-пример, который я приводил ранее.</p>\n<pre><code>.module > p:first-child { color: red; } /* Первое правило */\n.module > p:last-child { color: blue; } /* Второе правило */\n</code></pre>\n<p>Когда мы рассматриваем внутренности первого <code>&#x3C;div></code>, мы видим, что там есть параграф. Браузер видит что-то вроде этого:</p>\n<pre><code>&#x3C;div class=\"module\">\n    &#x3C;p>Lorem Ipsum&#x3C;/p>\n</code></pre>\n<p>Нужно ли применить первое правило к параграфу? Да, это параграф; да, это первый дочерний узел; и, да, это непосредственный потомок элемента с классом <code>module</code>.</p>\n<p>Нужно ли применить к этому параграфу второе правило? На данный момент это последний элемент. Но мы могли ещё не загрузить все элементы и не можем быть уверены, что он останется последним.</p>\n<p>Вне зависимости от того, как решать эту дилемму, у нас возникает необходимость повторного анализа стилей двух узлов для каждого нового узла, который мы добавляем в DOM. Если я добавлю ещё один параграф следом за первым, мы должны так же повторно перерассчитать стили, которые применяются к предыдущему параграфу.</p>\n<h2>Как на самом деле это делает браузер?</h2>\n<p>Я не мог сказать с абсолютной уверенностью, как браузеры парсят <code>:last-child</code>, так что я создал несколько тестов:</p>\n<ul>\n<li><a href=\"http://testing.snook.ca/css-1.html\">Статическая HTML-страница</a>;</li>\n<li><a href=\"http://testing.snook.ca/css-1.php\">Рендеринг с паузами в одну секунду</a>.</li>\n</ul>\n<p>Первый пример весьма скучен. В любом браузере, включая IE9, всё отображается корректно. Внутри <code>&#x3C;div></code> первый элемент красный, а последний синий. Но посмотрите на второй пример, и вы увидите интересные отличия в поведении браузеров.</p>\n<p>Второй пример приостанавливается перед добавлением каждого параграфа в <code>&#x3C;div></code>.</p>\n<p>В Firefox первый параграф изначально отображается синим. Когда загружается второй параграф, первый становится красным и второй — синим. Когда загружается третий параграф, второй отображается цветом по умолчанию и третий отображается синим. Firefox рассматривает каждый элемент, который был загружен в качестве последнего элемента, пока не будет загружен ещё один.</p>\n<p>В Safari, Chrome и Opera мы увидим другой подход. Первый параграф красный. Второй отображается чёрным. Последний параграф отображается чёрным, пока браузер не получит закрывающий тег <code>&#x3C;/div></code>. В этот момент последний параграф становится синим. Эти браузеры не рассматривают элемент как последний, пока не будет закрыт родительский.</p>\n<p>В Internet Explorer 9 Beta я нашел интересный баг. В то время, как статическая страница отображается корректно, версия с паузами отрабатывает с любопытным побочным эффектом. Первый параграф синий, второй параграф синий и затем — третий. Когда закрывающий тег <code>&#x3C;/div></code> загружен, предпоследний параграф меняет цвет на чёрный. IE9 пытается обрабатывать селектор как Webkit и Opera, но… м-м… не выходит. Надо бы отправить багрепорт в Microsoft.</p>\n<h2>Почему у нас нет селектора по родителю?</h2>\n<p>Уже дано достаточно пояснений, чтобы можно было вернуться к оригинальному вопросу. Проблема не в том, что у нас не может быть селектора по родителю. Проблема в том, что мы столкнемся с проблемами быстродействия, когда дело дойдет до определения того, какие CSS-правила применимы к данному элементу. Если Google Page Speed не рекомендует использование универсальных селекторов, то можно гарантировать, что селектор по родителю будет первым в списке ресурсоемких селекторов, намного опережая все проблемы с производительностью, которые могут быть вызваны использованием универсального селектора.</p>\n<p>Давайте посмотрим почему. Первым делом давайте приведём пример синтаксиса для селектора по родителю.</p>\n<pre><code>div.module:has(span) { color: green; }\n</code></pre>\n<p>Проблема в том, что мы не можем определить применимость правила до тех пор, либо пока мы не найдем соответствия, либо пока все элементы, дочерние по отношению к родителю данного, не будут загружены. Ввиду этого мы должны оценивать правило и все остальные (в случае наличия специфических особенностей), применяющиеся к элементу, для каждого дочернего элемента, который мы загружаем.</p>\n<p>Посмотрите на часть нашего документа:</p>\n<pre><code>&#x3C;div class=\"module\">\n    &#x3C;p>Lorem Ipsum&#x3C;/p>\n    &#x3C;p>Lorem Ipsum&#x3C;/p>\n    &#x3C;p>Lorem Ipsum &#x3C;span>Test&#x3C;/span>&#x3C;/p>\n&#x3C;/div>\n</code></pre>\n<p>Исходя из того, что мы видим, <code>.module</code> будет отображён без использования правила, применяемого селектором по родителю. Когда будет загружен первый элемент <code>&#x3C;p></code>, нужно повторно оценить применимость селектора по родителю к <code>&#x3C;div></code>. Нужно сделать это снова для следующего параграфа. И снова, для следующего. Наконец, когда <code>&#x3C;span></code> загружен, селектор по родителю будет применен к родительскому <code>&#x3C;div></code>, и элемент нужно будет повторно перерисовать.</p>\n<p>И что теперь? Теперь, если изменится любое наследуемое CSS-свойство, каждый потомок должен будет повторно анализироваться и перерисовываться. Ох…</p>\n<h2>Почему проблему можно решить с помощью JavaScript?</h2>\n<p>Это только кажется, что JavaScript решает проблему. В общем случае JavaScript-заплатки (<em>заплатки — polyfills — части кода, обеспечивающие функциональность, которую должен обеспечивать браузер. Примечание переводчика</em>). Или регрессивное усовершенствование (или как там вы, молодежь, это сейчас называете) запускаются только один раз, после полной загрузки DOM.</p>\n<p>Для того чтобы действительно имитировать поведение CSS, любой скрипт, решающий эту проблему, должен запускаться после отображения каждого элемента на странице, чтобы определить, нужно ли применить нашу «заплатку». Помните CSS-expressions в Internet Explorer? Именно по этой причине они вызывали такие проблемы с производительностью.</p>\n<h2>Не невозможно</h2>\n<p>Появится ли когда-нибудь селектор по родителю? Возможно. То, что я опиcал, не невозможно. На самом деле — наоборот. Это значит только то, что нам придётся иметь дело с ухудшением производительности из-за использования этого селектора.</p>\n<p>Перевод оригинальной заметки «<a href=\"http://snook.ca/archives/html_and_css/css-parent-selectors/\">Why we don’t have a parent selector</a>» <a href=\"http://snook.ca/about/\">Джонатана Снука</a> (Jonathan Snook), опубликованной в блоге «<a href=\"http://snook.ca/\">Snook.ca</a>».</p>","frontmatter":{"title":"Почему у нас нет селектора по родителю","date":"20 сентября 2011"}}},"pageContext":{"slug":"/articles/parent-selector/"}}