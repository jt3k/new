{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"1215e458-da11-597a-b2e1-ed12edd4fa73","excerpt":"Svable — простая генерация SVG на сервере Илья Заяц  13 декабря 2013 Мы начинаем серию статей, в которых вы можете рассказать о своём…","html":"<h1>Svable — простая генерация SVG на сервере</h1>\n<p><a href=\"http://svable.com/\">Илья Заяц</a> 13 декабря 2013</p>\n<p><em>Мы начинаем серию статей, в которых вы можете рассказать о своём сервисе или разработке, которые могут быть полезны для фронтенд-разработчиков. Есть о чём рассказать? Пишите нам на <a href=\"mailto:wst@web-standards.ru\">wst@web-standards.ru</a>. Редакция.</em></p>\n<p>Рассказывать про актуальность векторной графики уже нет никакого смысла — количеством различных размеров, разрешений (а теперь еще и плотностей) экранов веб-разработчика не удивишь. А вот вопрос подготовки и создания изображений для всего этого разнообразия набирает актуальность с каждым днем. В этой статье я хочу рассказать не о том, как научить дизайнера использовать Illustrator, а о том, как облегчить жизнь разработчика при работе с SVG.</p>\n<p>В последнее время SVG начинают использовать не только в качестве замены растра для иконок и логотипов начинает, но и для создания сложной графики и динамических диаграмм. За это нужно сказать спасибо множеству отличных JavaScript-библиотек, которые позволяют реализовывать все фантазии дизайнеров быстро и легко: Raphaël, Snap.svg, SVG.js, а также тех, что визуализируют разнообразные данные в любом вообразимом виде: D3, Highcharts, GRaphaël.</p>\n<p>Но я говорил об облегчении жизни разработчиков: в чем она нелегка, если хороших инструментов так много? Проблемы начинаются, когда перед программистами ставится одна из следующих задач:</p>\n<ul>\n<li>отрисовать графики на сервере, чтобы вставить в email-рассылку;</li>\n<li>закэшировать результат, потому что каждая отрисовка очередного сложного изображения «подвешивает» браузер на слабой машине;</li>\n<li>дать пользователю возможность скачать файл в PNG или PDF.</li>\n</ul>\n<p>Очевидно, основное преимущество всех этих библиотек становится их самым большим минусом — они работают только в браузере.</p>\n<p>Решения этой проблемы уж больно прямолинейные — перетащить браузер на сервер. Тут и решения «headless», например, у <a href=\"http://www.highcharts.com/component/content/article/2-news/52-serverside-generated-charts\">highcharts</a> или <a href=\"http://mir.aculo.us/2013/04/30/embed-canvas-and-svg-charts-in-emails/\">freckle</a>, или попытки перенести <a href=\"https://github.com/dodo/node-raphael\">DOM в Node.js для Raphaël</a>.</p>\n<p>Это работает, но инфраструктура для столь небольших потребностей получается монструозной, сложной и часто медленной.</p>\n<p>Почему же тогда просто не использовать сторонние серверные библиотеки? Ни один программист в мире не захочет поддерживать две реализации одного и того же на двух разных языках. Это ведет к ошибкам, дополнительным сложностям и высокой итоговой стоимости поддержки и разработки новой функциональности.</p>\n<p>Мы все это понимаем, поэтому и создали <a href=\"http://svable.com\" title=\"Svable\">Svable</a>. Это сервис, который позволит вам перенести всю вашу существующую генерацию SVG из браузера на сервер или запускать один и тот же код как на клиенте, так и на сервере.</p>\n<p>Как это реализуется? Система состоит из двух частей: самой платформы и адаптеров. Платформа — это API, который принимает на вход специально сформированный JSON с высокоуровневыми командами, вроде: <code>rect</code>, <code>circle</code>, <code>getBBox</code> и т.д. В ответ вы получаете результирующий SVG, PDF или PNG. Мы конвертируем результат, если вам это нужно.</p>\n<p>Возьмем для примера <a href=\"http://codepen.io/anon/pen/jiHkq\">вот этот SVG</a>. Как видим, это круг с полупрозрачным <code>stroke</code> и белым квадратом, который рисуется ровно по центру этого круга. И все это на фоне белого прямоугольника с закругленными краями. Допустим, нам позарез нужно отрисовать подобное на сервере. Для этого потребуется сформировать POST-запрос на наш сервис со следующим JSON:</p>\n<pre><code>{\n    'paper': {\n    'attrs': [ { 'width': '640' }, { 'height': '480' }],\n    'access_key': 'my_key',\n    'format': 'svg',\n    'children': [\n        {\n        'type': 'rect',\n        'attrs': [\n            { 'x': '0' },\n            { 'y': '0' },\n            { 'width': '640' },\n            { 'height': '480' },\n            { 'rx': '10' },\n            { 'fill': '#fff' }\n        ]},\n        {\n        'type': 'circle',\n        'svable_id': 'main_circle',\n        'attrs': [\n            { 'cx': '320' },\n            { 'cy': '240' },\n            { 'r': '60' },\n            { 'fill': '#223fa3' },\n            { 'stroke': '#000000' },\n            { 'stroke-width': '80' },\n            { 'stroke-opacity': '0.5' }\n        ]},\n        {\n        'type': 'rect',\n        'attrs': [\n            { 'x': 'main_circle.cx - 10' },\n            { 'y': 'main_circle.cy - 10' },\n            { 'fill': '#fff' },\n            { 'width': '20' },\n            { 'height': '20' }\n        ]}\n    ]}\n}\n</code></pre>\n<p>Разберем его по частям: в корневом объекте <code>paper</code> вы описываете размеры вашего полотна, <code>viewBox</code>, а также указываете ваш персональный ключ доступа и растровый формат (по умолчанию в ответ вам придет SVG):</p>\n<pre><code>'paper': {\n    'attrs': [{ 'width': '640' }, { 'height': '480' }],\n    'access_key': 'my_key',\n    'format': 'svg',\n</code></pre>\n<p>В массиве <code>children</code> указываются все объекты, которые попадут на ваш холст. Первым из них идет фоновый прямоугольник. Тут все достаточно просто и почти один в один повторяет формат самого SVG-документа:</p>\n<pre><code>'type': 'rect',\n'attrs': [\n    { 'x': '0' },\n    { 'y': '0' },\n    { 'width': '640' },\n    { 'height': '480' },\n    { 'rx': '10' },\n    { 'fill': '#fff' }\n]\n</code></pre>\n<p>Далее опишем круг. Тут все тоже довольно банально, но есть одно отличие — атрибут <code>svable_id</code>, который позволит вам сослаться конкретно на этот объект в тот момент, когда вам понадобятся любые его параметры:</p>\n<pre><code>'type': 'circle',\n'svable_id': 'main_circle',\n'attrs': [\n    { 'cx': '320' },\n    { 'cy': '240' },\n    { 'r': '60' },\n    { 'fill': '#223fa3' },\n    { 'stroke': '#000000' },\n    { 'stroke-width': '80' },\n    { 'stroke-opacity': '0.5' }\n]\n</code></pre>\n<p>Затем опишем последний квадрат. Напомним, что он должен позиционироваться относительно центра круга. Тут вам и пригодится то, что вы указали в <code>svable_id</code>:</p>\n<pre><code>'type': 'rect',\n'attrs': [\n    { 'x': 'main_circle.cx - 10' },\n    { 'y': 'main_circle.cy - 10' },\n    { 'fill': '#fff' },\n    { 'width': '20' },\n    { 'height': '20' }\n]\n</code></pre>\n<p>Однако обычно никто не рисует SVG на сервере с нуля. Поэтому мы создали адаптеры под популярные JavaScript-библиотеки: уже готов Raphaël, завершаем работу над Snap.svg и D3.</p>\n<p>Адаптеры как раз занимаются тем, что преобразовывают код, написанный для браузерных библиотек в JSON, который понимает наша платформа. В итоге вы легко можете запускать свой код там, где вам сейчас это выгодно, лишь вызовите адаптер в нужный момент.</p>\n<p>Возьмем уже знакомый нам SVG и <a href=\"http://codepen.io/anon/pen/iJext\">отрисуем с помощью Raphaël</a>:</p>\n<pre><code>var paper = Raphael(0, 0, 640, 480);\n    paper\n        .rect(0, 0, 640, 480, 10)\n        .attr({\n            fill: '#fff',\n            stroke: 'none'\n});\nvar circle = paper\n    .circle(320, 240, 60)\n    .attr({\n        fill: '#223fa3',\n        stroke: '#000',\n        'stroke-width': 80,\n        'stroke-opacity': 0.5\n});\npaper\n    .rect(circle.attr('cx') - 10, circle.attr('cy') - 10, 20, 20)\n    .attr({\n        fill: '#fff',\n        stroke: 'none'\n});\n</code></pre>\n<p>А теперь перенесем его на сервер и <a href=\"http://codepen.io/anon/pen/woJgA\">отрисуем с помощью Node.js</a>:</p>\n<pre><code>var Svable = require('svable');\nvar paper = Svable(0, 0, 640, 480, 'raphael');\npaper\n    .rect(0, 0, 640, 480, 10)\n    .attr({\n    fill: '#fff',\n    stroke: 'none'\n});\nvar circle = paper\n    .circle(320, 240, 60)\n    .attr({\n        fill: '#223fa3',\n        stroke: '#000',\n        'stroke-width': 80,\n        'stroke-opacity': 0.5\n});\npaper\n    .rect(circle.attr('cx') - 10, circle.attr('cy') - 10, 20, 20)\n    .attr({\n        fill: '#fff',\n        stroke: 'none'\n});\nconsole.log(paper.burnSync());\n</code></pre>\n<p>Как видите, вся разница лишь в первоначальном вызове объекта и итоговом получении результата.</p>\n<p>В данном случае вызов <code>paper.burnSync()</code> синхронно вернет нам необходимый XML, с которым вы уже можете поступить как захотите. Любители асинхронности могут воспользоваться методом <code>burn</code> — он возвращает промис.</p>\n<p>Таким образом, вы получаете возможность вставить итоговый файл в почтовую рассылку, отдать пользователю на скачивание, сохранить на сервере, чтобы в следующий раз сэкономить как время пользователя, так и деньги на генерации, и все это без дублирования кода и страданий программистов.</p>\n<p>Мы сейчас находимся на финальной стадии разработки, и нам нужны первые клиенты со сложными задачами для пробных интеграций. Мы не только решим их проблемы, но и дадим выгодные условия на время бета-теста. Напишите нам, обсудим конкретно ваш случай: <a href=\"http://svable.com/\">svable.com</a>.</p>\n<p>Редактура <a href=\"http://pepelsbey.net/\">Вадима Макеева</a> и <a href=\"http://engel-t.moikrug.ru/\">Ольги Алексашенко</a>.</p>","frontmatter":{"title":"Svable — простая генерация SVG на сервере","date":"13 декабря 2013"}}},"pageContext":{"slug":"/articles/svable-server-svg/"}}