{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"d3555d52-a548-55cb-b0be-0bd922016e4e","excerpt":"CSS: новый вид JavaScript Перевод «CSS: A New Kind Of JavaScript» Хейдона Пикеринга. Те из вас, кто знаком с веб-платформой, наверняка…","html":"<h1>CSS: новый вид JavaScript</h1>\n<p>Перевод «CSS: A New Kind Of JavaScript» Хейдона Пикеринга.</p>\n<p>Те из вас, кто знаком с веб-платформой, наверняка наслышаны и о двух дополнительных технологиях: <strong>HTML</strong> для структуризации документов и <strong>JavaScript</strong> для интерактивности и стилизации.</p>\n<p>Сколько мы себя помним, стилизация документов (то есть, влияние на их внешний вид) всегда производилась с помощью JavaScript-свойства style, доступного на каждом поддерживаемом DOM-узле.</p>\n<pre><code>node.style.color = 'red';\n</code></pre>\n<p>До изобретения этого API для стилизации авторам HTML приходилось писать атрибуты style вручную прямо в DOM, что затрудняло процесс редактирования.</p>\n<p>Используя выборку узлов по селектору из JS, мы можем стилизовать несколько элементов одновременно. В примере ниже текст во всех p стилизован красным цветом.</p>\n<pre><code>const nodes = document.querySelectorAll('p');\nArray.prototype.forEach.call(nodes, node => {\n  node.style.color = 'red';\n});\n</code></pre>\n<p>Отличная возможность выборки по селектору — обращение к нескольким элементам, перечисленным в списке через запятую.</p>\n<pre><code>const nodes = document.querySelectorAll('p, li, dd');\n</code></pre>\n<p>Гораздо менее удобно применять несколько стилей к одному узлу. Такой подход быстро становится слишком многословным:</p>\n<pre><code>node.style.color = 'red';\nnode.style.backgroundColor = 'black';\nnode.style.padding = '1rem';\n// и т.д.\n</code></pre>\n<p>Единственная стандартная альтернатива — использовать свойство cssText:</p>\n<pre><code>node.style.cssText = 'color: red; background-color: black; padding: 1rem;';\n</code></pre>\n<p>Управлять несколькими стилями в одной строке проблематично. В будущем будет сложно обновлять, удалять или заменять отдельные стили.</p>\n<p>Для этого авторы придумали способы управления информацией о стилях с помощью объектов, часто при помощи прототипа интерфейса Element.</p>\n<pre><code>Element.prototype.styles = function(attrs) {\n  Object.keys(attrs).forEach(attr => {\n    this.style[attr] = attrs[attr];\n  });\n}\n</code></pre>\n<p>Теперь стили к узлу можно добавлять вот так:</p>\n<pre><code>node.styles({\n  'color': 'red',\n  'backgroundColor': 'black',\n  'padding': '1rem'\n});\n</code></pre>\n<p>Использование подобного подхода приобрело <em>довольно большую</em> популярность в приложениях и их жизненных циклах. Однако это привело к печально известной проблеме—непониманию, где всё это хранить и как явно отделить стили от интерактивной части, ещё одной области ответственности JavaScript.</p>\n<p>А есть и другая, более фундаментальная проблема: эти стили не реактивны. К примеру, у меня есть некоторые стили для неактивных кнопок:</p>\n<pre><code>const disableds = document.querySelectorAll('[disabled]');\n\nArray.prototype.forEach.call(disableds, disabled => {\n  disabled.styles({\n  'opacity': '0.5',\n  'cursor': 'not-allowed'\n});\n</code></pre>\n<p>Эти стили применяются только к неактивным кнопкам, которые уже есть в DOM. Любые кнопки, добавленные в DOM или, что более вероятно, любые кнопки, которые приобретут свойство или атрибут disabled, не получат автоматически подходящую стилизацию.</p>\n<pre><code>button.disabled = true;\nbutton.style // ничего нового\n</code></pre>\n<p>Можно, конечно, слушать изменение атрибутов и реагировать на него с помощью mutationObserver:</p>\n<pre><code>const button = document.querySelector('button');\n\nvar config = { attributes: true }\n\nvar callback = function(mutationsList) {\n  for(var mutation of mutationsList) {\n    if (mutation.type == 'attributes') {\n      if (button.disabled) { \n        button.styles({\n          'opacity': '0.5',\n          'cursor': 'not-allowed'\n        });\n      }\n    }\n  }\n}\n\nvar observer = new MutationObserver(callback);\n\nobserver.observe(button, config);\n</code></pre>\n<p>Думаю, что все согласятся, что это—<em>довольно много</em> кода, с учётом того, что он всего лишь заставляет один экземпляр элемента одного типа реагировать на изменение единственного атрибута. Также это меняет стилизацию только в одном направлении: нам бы пришлось обрабатывать отмену стилей при удалении свойства disabled. Это не так уж и просто, учитывая, что мы не знаем изначальных значений свойств opacity или cursor.</p>\n<p>Как бы я ни любил JavaScript, я не думаю, что он хорошо спроектирован для задач стилизации. В конце концов, это процедурный и событийный язык, тогда как стили — это то, что у вас либо есть, либо нет.</p>\n<p>Мы тратим слишком много времени впустую, когда пишем и поддерживаем стили с помощью JavaScript. Пришло время это менять. Поэтому я с большим удовольствием представляю вам новый стандарт, который называется CSS.</p>\n<h2>CSS</h2>\n<p>CSS — это декларативное подмножество JavaScript, оптимизированное для задач стилизации. CSS-файл имеет расширение .css и, что важно, парсится независимо от стандартных JS-файлов. С помощью CSS наконец-то стало возможно отделить стили от поведения. Вы можете брендировать своё приложение, не трогая бизнес-логику!</p>\n<h3>Синтаксический сахар</h3>\n<p>Первое, что вы заметите — это более чистый синтаксис, фанаты CoffeeScript оценят:</p>\n<pre><code>[disabled] {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n</code></pre>\n<p>Структура, похожая на объектную, сохраняется, но теперь вам не нужно явно вызывать querySelectorAll для перебора DOM-узлов. Вместо этого перебор происходит внутри, и это, конечно же, производительнее.</p>\n<p>Пример выше автоматически применяется ко всем DOM-узлам с атрибутом disabled. Более того, все <em>новые</em> кнопки с атрибутом disabled автоматически приобретут связанные стили. Реактивность из коробки!</p>\n<h3>Каскад</h3>\n<p>CSS расшифровывается как <strong>каскадные таблицы стилей</strong>. Каскадность здесь, пожалуй, самая лучшая особенность. Взгляните на следующий CSS:</p>\n<pre><code>button {\n  background-color: blue;\n  cursor: pointer;\n}\n\n[disabled] {\n  cursor: not-allowed;\n}\n</code></pre>\n<p>Стили для блока [disabled] идут после блока button в стилях. Любые стили, описанные в блоке [disabled] с такими же ключами (именами свойств), что и в предшествующем button, будут перезаписаны. Самое замечательное заключается в том, что добавление атрибута или свойства disabled кнопке обновит только соответствующие стили. В примере выше свойство cursor обновится, но background-color останется тем же. Своего рода система фильтрации.</p>\n<p>Ко всему прочему, если атрибут или свойство disabled удалено, стили по умолчанию будут автоматически возвращены — ведь узел теперь соответствует блоку button выше по каскаду. Не нужно «вспоминать», какие стили и при каких условиях были применены ранее.</p>\n<h3>Устойчивость</h3>\n<p>При стилизации с помощью JavaScript любое неизвестное свойство или синтаксическая ошибка остановят парсинг скрипта. Все последующие стили или поведение будут отброшены целиком и всё ваше приложение просто рухнет.</p>\n<p>CSS гораздо надёжнее. В большинстве случаев любое неизвестное свойство или синтаксическая ошибка приведут только к тому, что только декларация (пара свойство: значение) с ошибкой будет отброшена.</p>\n<p>Эта инновация учитывает, что разные браузеры поддерживают разные свойства стилизации, и что отдельные стили не критичны для всей задачи. Устойчивость CSS значит, что больше пользователей получат доступ к функционирующему интерфейсу.</p>\n<h2>Заключение</h2>\n<p>Явный признак того, что технология не подходит для определённых целей—если для обхода сложностей нам приходится сильно полагаться на трюки и лучшие практики. Другой признак — насколько много кода нам приходится писать, чтобы сделать простые вещи. Когда речь заходит про стилизацию, JavaScript — как раз та самая неподходящая технология.</p>\n<p>CSS решает проблемы JavaScript со стилизацией, причём элегантно. Вопрос в том, готовы ли вы принять изменения или вы завязли в неудачной методологии?</p>\n<p>Больше информации про CSS и советы для быстрого старта <a href=\"https://en.wikipedia.org/wiki/Campus_SuperStar\">вы найдете здесь</a>.</p>\n<p><em>Перевод <a href=\"https://medium.com/@pepelsbey\">Вадима Макеева</a>, редактура <a href=\"https://medium.com/@tachisis\">Ольги Алексашенко</a> и <a href=\"https://medium.com/@amel_true\">Андрея Мелихова</a>. Переведено с разрешения автора.</em></p>","frontmatter":{"title":"CSS: новый вид JavaScript","date":"TODO"}}},"pageContext":{"slug":"/articles/css-new-kind-of-javascript/"}}