{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"7d72eb3a-8aa7-5c96-9b9c-085c06fd7e2a","excerpt":"Нюансы CSS Лев Солнцев  21 апреля 2011 Многие используют CSS для оформления сайтов и веб-страниц, знают основные приёмы вёрстки, а если и…","html":"<h1>Нюансы CSS</h1>\n<p><a href=\"http://my.opera.com/GreLI/blog/\">Лев Солнцев</a> 21 апреля 2011</p>\n<p>Многие используют CSS для оформления сайтов и веб-страниц, знают основные приёмы вёрстки, а если и нет, то быстро найдут решение в интернете, или им подскажут в тематических сообществах. Тем не менее многие широко используемые решения не оптимальны, и если ознакомиться со спецификациями чуть глубже, можно написать лучший код.</p>\n<p>К примеру многие знают, что цвет в шестнадцатеричной нотации вида <code>#RRGGBB</code> можно писать сокращённо как <code>#RGB</code>, если каждый старший разряд совпадает с младшим, или что нуль можно писать без единиц измерения, таких как «px» или «em», так как нуль — в любой системе измерения нуль.</p>\n<h2>Что считает браузер</h2>\n<p>Также широко известно, что можно отцентрировать блок с шириной меньше родительского элемента при помощи <code>margin:0 auto</code>. Однако мало кто задумывается, что почти во всех случаях дело касается непозиционированных элементов, и в этом случае значение <code>margin-top:auto</code> или <code>margin-bottom:auto</code> устанавливается равным нулю, а значит данное правило можно сократить до простого <code>margin:auto</code>.</p>\n<p>Правила <code>margin-left:auto</code> и <code>margin-right:auto</code> при ширине блока меньше ширины контейнера равномерно распределяют оставшееся место. Так, задав только <code>margin-left:auto</code>, можно выровнять элемент по правому краю.</p>\n<p>В обычном потоке элементы идут сверху вниз, поэтому <code>margin-top:auto</code> устанавливается нулевым. Однако для абсолютно спозиционированных элементов действует то же распределение свободного места, и аналогичным образом можно сделать <a href=\"http://test.csswg.org/suites/css2.1/20110111/html4/absolute-non-replaced-height-003.htm\">центрирование по вертикали</a> при заданных высоте и <code>top</code> с <code>bottom</code> (не работает в IE7).</p>\n<h2>Сокращения и значения по умолчанию</h2>\n<p>Не менее широко распространено использование спрайтов, например: <code>background:url(icons.png) 0 0 no-repeat</code>. Однако, <code>background-position:0 0</code> является значением по умолчанию, поэтому <code>0 0</code> в таком случае можно опустить.</p>\n<p>Но если в <code>background-position</code> задана хоть одна координата: будь то <code>top</code>, <code>left</code> или <code>100%</code>, то вторая принимает значение 50%. Это может быть полезно для значков, выровненных посередине строки по вертикали — достаточно указать лишь положение слева или справа.</p>\n<p>Не все знают, что опущенные в сокращённой записи правила принимают своё значение по умолчанию. Поэтому уточняющие правила надо писать после или делать сильнее общей сокращённой надписи, как <code>background-position</code> уточняет положение каждого спрайта после <code>background</code> в предыдущем примере.</p>\n<p>При подобном написании:</p>\n<pre><code>h1 {\n    font: 2em/1 Arial,sans-serif;\n}\n</code></pre>\n<p>задаётся не только шрифт, его размер и интерлиньяж, но и сразу сбрасывается полужирное написание (<code>font-weight:normal</code>), а также другие свойства, такие как <code>font-style</code> (курсив) и <code>font-variant</code> (капитель). Некоторые авторы совершенно зря дописывают в <code>font</code> значение <code>normal</code>. Непонятно даже к какому правилу из перечисленных трёх оно могло бы относиться — порядок следования в сокращённых свойствах неважен, и неучитывание порядка могло приводить к ошибкам лишь в устаревших браузерах.</p>\n<p>Другими недопонятыми, но тоже полезными сокращёнными записями являются отдельные правила рамок <code>border-width</code>, <code>border-style</code> и <code>border-color</code>. Например, благодаря им можно задать верхнюю и нижнюю одинаковые рамки не дублированием кода в <code>border-top</code> и в <code>border-bottom</code>, а подобным образом:</p>\n<pre><code>border: solid gray;\nborder-width: 3px 0;\n</code></pre>\n<p>Кроме меньшего размера кода, такая запись полезна тем, что каждое значение написано только один раз, и поменять, скажем, <code>solid</code> на <code>double</code> не составляет труда.</p>\n<p>Более того, если будет использоваться <code>border-image</code>, то здесь явно задано, что размер боковых рамок нулевой. В противном случае <code>border-image</code> приводит к неявному появлению рамок, что может дать неожиданный эффект в углах.</p>\n<p>Есть возможность, что <code>border-radius</code> может быть включен в сокращённую запись <code>border</code> (предлагался вариант с косой чертой «/»), поэтому записывайте на всякий случай <code>border-radius</code> после <code>border</code>.</p>\n<h2>Переусложенение</h2>\n<p>Часто, чтобы избавиться от рамки на картинке внутри ссылки, пишут:</p>\n<pre><code>a img {\n    border: 0;\n}\n</code></pre>\n<p>Однако в таком случае бразуер будет на каждой картинке проверять, не находится ли она в ссылке. Если для простых страниц это кажется несущественным (вы и глазом моргнуть не успеете за те несколько миллисекунд, на которое задержится отображение страницы), то в какой-нибудь фотогалерее со сложной анимацией это может лишить вас нескольких кадров в секунду, прибавляя ощущения «тормознутости». Куда проще написать так:</p>\n<pre><code>img {\n    border: 0;\n}\n</code></pre>\n<p>Эффект будет тот же самый. Уточнение, что рамка появляется на ссылках <code>a</code> в данном случае совершенно излишне.</p>\n<p>Из тех же соображений производительности, как правило, незачем писать имя тэга вместе с классом и уж тем более с идентификатором, который сам по себе уникален. В данном правиле могут быть только два исключения: уточнение для конкретного тэга (возможно в этом случае у вас очень общий класс), и обход недостатка IE7, где эффекты при наведении <code>:hover</code> тормозят, если в селекторе не указан тэг (то есть надо писать <code>a.class:hover { color:#FC0; }</code>).</p>\n<h2>Наследование</h2>\n<p>Ещё одна недооценённая многими возможность CSS: наследование стилей. Например, может не устраивать, что по умолчанию содержимое ячеек таблиц центрируется по вертикали, при этом используются следующие правила:</p>\n<pre><code>th {\n    vertical-align: bottom;\n}\ntd {\n    vertical-align: top;\n}\n</code></pre>\n<p>Вроде бы всё здорово, но, сделав так, вы лишаетесь простого способа переопределить выравнивание для целого ряда:</p>\n<pre><code>tr.images {\n    vertical-align: middle;\n}\n</code></pre>\n<p>Этого можно избежать, воспользовавшись тем, что ячейки таблицы <code>th</code> и <code>td</code> наследуют правила от рядов <code>tr</code>, а те в свою очередь от блоков <code>thead</code>, <code>tfoot</code> и <code>tbody</code>.</p>\n<pre><code>thead {\n    vertical-align: bottom;\n}\ntbody,\ntfoot {\n    vertical-align: top;\n}\n</code></pre>\n<p>Стоит отметить, что все браузеры, кроме IE8, наследуют еще и значение <code>text-align</code> для <code>th</code>, а сам IE8 понимет ключевое слово <code>inherit</code>, что также позволяет наследовать значение <code>text-align</code>.</p>\n<h2>Заключение</h2>\n<p>Знание основ спецификаций, понимание механизмов работы браузеров и выполняемых действий позволяет оптимизировать написание кода, упростить его, сделать лаконичней, а также упростить дальшейшую разработку и поддержку.</p>","frontmatter":{"title":"Нюансы CSS","date":"21 апреля 2011"}}},"pageContext":{"slug":"/articles/css-nuances/"}}