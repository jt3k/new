{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"9a1ca9ce-a5be-5825-aa6c-8528ea7a24ff","excerpt":"Реализуем пуш-уведомления на фронтенде и бэкенде Перевод «Implementing push notifications on the front-end and back-end» Майкла Шарналя. В…","html":"<h1>Реализуем пуш-уведомления на фронтенде и бэкенде</h1>\n<p>Перевод «Implementing push notifications on the front-end and back-end» Майкла Шарналя.</p>\n<p>В предыдущей <a href=\"https://justmarkup.com/log/2017/02/introducing-iss-observer-com/\">статье</a> об <a href=\"https://iss-observer.com/\">*iss-observer.com</a>* я обещал рассказать о технической стороне реализации пуш-уведомлений. Изначально я планировал сконцентрироваться на проблемах, с которыми пришлось иметь дело в процессе работы над <a href=\"https://iss-observer.com/\">*iss-observer.com</a>*. Теперь я думаю, будет полезнее посвятить материал базовым вопросам, и уточнять детали, где это необходимо. Обращаю ваше внимание, что фронтенд частично опирается на <a href=\"https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/?hl=en\">этот урок</a>.</p>\n<p><em>Если вы хотите углубиться в исходный код, то смотрите в <a href=\"https://github.com/justmarkup/demos/tree/gh-pages/push-notifications\">GitHub-репозиторий</a> и на <a href=\"https://push-notifications-vwursywdxa.now.sh\">пример</a>, демонстрирующий его работу.</em></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*8KWLqCaGqDIe0KRNFOycsA.jpeg\"></p>\n<h2>Фронтенд</h2>\n<p>Начнем с клиентской части. Первое, что нужно сделать — убедиться, что браузер поддерживает пуш-уведомления. Если да, загружаем наш <em>JavaScript</em>.</p>\n<pre><code>if ('serviceWorker' in navigator &#x26;&#x26; 'PushManager' in window) {\n  var s = document.createElement('script');\n  s.src = '/script/push.js';\n  s.async = true;\n  document.head.appendChild(s);\n}\n</code></pre>\n<p>Прежде чем писать код, выполним ряд требований. Нам потребуются <em>Application Server Keys (VAPID Key)</em>. Получаем их <a href=\"https://web-push-codelab.appspot.com\">здесь</a>, либо с помощью библиотеки <em>web-push</em>. Кстати, она нам еще потребуется для бэкенд-части. Устанавливаем библиотеку: npm install -g web-push, генерируем ключи: web-push generate-vapid-keys. В независимости от способа в результате у вас должны быть <strong>закрытый ключ*</strong> (private key)* и <strong>открытый ключ*</strong> (public key)*. Сохраните их в надежном месте.</p>\n<p><em>До появления спецификации Application server key/VAPID первые браузеры (Chrome, Opera) реализовали функциональность пуш-уведомлений с помощью <a href=\"https://developers.google.com/cloud-messaging/\">Google Cloud Messaging</a>. Все современные браузеры, за исключением <a href=\"https://github.com/web-push-libs/web-push#browser-support\">Samsung Internet</a>, поддерживают VAPID. Поэтому в этой статье я не буду касаться GCM. Как добавить поддержку для Samsung Internet и старых версий Chrome и Opera — читайте <a href=\"https://web-push-book.gauntface.com/chapter-06/01-non-standards-browsers/\">здесь</a>.</em></p>\n<p>Посмотрим на <em>push.js</em>. Здесь мы регистрируем сервис-воркер и подписываемся на уведомления:</p>\n<pre><code>'use strict';\n\nconst appServerKey = 'BHLCrsFGJQIVgg-XNp8F59C8UFF49GAVxvYMvyCURim3nMYI5TMdsOcrh-yJM7KbtZ3psi5FhfvaJbU_11jwtPY';\n\nconst pushWrapper = document.querySelector('.push-wrapper');\nconst pushButton = document.querySelector('.push-button');\n\nlet hasSubscription = false;\nlet serviceWorkerRegistration = null;\nlet subscriptionData = false;\n\nfunction urlB64ToUint8Array(base64String) {\n  const padding = '='.repeat((4 - base64String.length % 4) % 4);\n  const base64 = (base64String + padding)\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i &#x3C; rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\nfunction updatePushButton() {\n  pushWrapper.classList.remove('hidden');\n  \n  if (hasSubscription) {\n    pushButton.textContent = `Disable Push Notifications`;\n  } else {\n    pushButton.textContent = `Enable Push Notifications`;\n  }\n}\n\nfunction subscribeUser() {\n  serviceWorkerRegistration.pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: urlB64ToUint8Array(appServerKey)\n  })\n  .then(function(subscription) {\n\n    fetch('/push/subscribe',{\n      method: 'POST',\n      headers: {\n          'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(subscription)\n    })\n    .then(function(response) {\n      return response;\n    })\n    .then(function(text) {\n      console.log('User is subscribed.');\n      hasSubscription = true;\n\n      updatePushButton();\n    })\n    .catch(function(error) {\n      hasSubscription = false;\n      console.error('error fetching subscribe', error);\n    });\n    \n  })\n  .catch(function(err) {\n    console.log('Failed to subscribe the user: ', err);\n  });\n}\n\nfunction unsubscribeUser() {\n  serviceWorkerRegistration.pushManager.getSubscription()\n  .then(function(subscription) {\n    if (subscription) {\n      subscriptionData = {\n        endpoint: subscription.endpoint\n      };\n      \n      fetch('/push/unsubscribe',{\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(subscriptionData)\n      })\n      .then(function(response) {\n        return response;\n      })\n      .then(function(text) {\n        hasSubscription = false;\n\n        updatePushButton();\n      })\n      .catch(function(error) {\n        hasSubscription = true;\n        console.error('error fetching subscribe', error);\n      });\n\n      hasSubscription = false;\n\n      updatePushButton();\n      return subscription.unsubscribe();\n    }\n  });\n}\n\nfunction initPush() {\n\n  pushButton.addEventListener('click', function() {\n    if (hasSubscription) {\n      unsubscribeUser();\n    } else {\n      subscribeUser();\n    }\n  });\n\n  // Set the initial subscription value\n  serviceWorkerRegistration.pushManager.getSubscription()\n  .then(function(subscription) {\n    hasSubscription = !(subscription === null);\n\n    updatePushButton();\n  });\n}\n\nnavigator.serviceWorker.register('sw.js')\n.then(function(sw) {\n  serviceWorkerRegistration = sw;\n  initPush();\n})\n.catch(function(error) {\n  console.error('Service Worker Error', error);\n});\n</code></pre>\n<p>В первую очередь создаем константу addServiceKey: ей присваиваем значение с открытым ключ <em>VAPID</em> (о нем мы говорили выше). Также создаем несколько элементов и переменных. Записываем функцию urlB64ToUint8Array(): она понадобится для конвертации ключа из <em>base64</em> в <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\">*Uint8Array</a>*.</p>\n<p>Затем декларируем функцию updatePushButton(). Мы будем вызывать её каждый раз при изменении статуса уведомлений, чтобы обновить отвечающие за него элементы интерфейса.</p>\n<p>Далее видим функцию регистрации подписки subscribeUser(). Как вы наверно заметили, в начале скрипта была объявлена переменная let serviceWorkerRegistration. Она содержит результат <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\">регистрации сервис-воркера</a>: посмотрите в конец файла, мы записываем его в переменную в момент регистрации.</p>\n<pre><code>serviceWorkerRegistration.pushManager.subscribe({\n  userVisibleOnly: true,\n  applicationServerKey: urlB64ToUint8Array(appServerKey)\n})\n</code></pre>\n<p>Метод subscribe() возвращает промис, а в качестве аргумента принимает объект с двумя свойствами:</p>\n<ul>\n<li>\n<p>userVisibilityOnly: булево значение. Параметр сообщает, что подписка будет использоваться только для сообщений, эффект которых виден для пользователя. Устанавливаем значение true.</p>\n</li>\n<li>\n<p>applicationServiceKey: номер открытого ключа, он используется сервером для отправки уведомлений. Так как ключ должен быть в формате <em>UInt8Attay</em>, используем уже знакомую нам функцию.</p>\n<p>.then(function(subscription) {\nfetch('/push/subscribe',{\nmethod: \"POST\",\nheaders: {\n'Content-Type': 'application/json'\n},\nbody: JSON.stringify(subscription)\n})</p>\n</li>\n</ul>\n<p>Теперь отправляем данные подписки на сервер. Смело используем <em>Fetch API</em>, так как все браузеры, которые поддерживают пуш-уведомления, поддерживают и <em>Fetch</em>. После получения ответа выводим результат — завершена ли подписка успешно.</p>\n<p>Этот этап прекрасно подходит для уточнения нужных параметров у пользователя. Например, на <a href=\"https://iss-observer.com\">*iss-observer.com</a>* он может выбрать время получения уведомлений (утро и/или вечер). Я также отправляю на сервер данные о стране, регионе и городе, по которому пользователь хочет получать уведомления; данные сохраняются и могут потребоваться при отправке уведомлений.</p>\n<p>После этого, создаем функцию отписки unsubscribeUser(). Используем метод getSubscription() объекта PushManager, с его помощью получаем детали подписки, которые отправляем на сервер (снова <em>Fetch API</em>). На этот раз, чтобы удалить её базы.</p>\n<p>Записываем функцию initPush(). В ней — событие для кнопки <em>pushButton,</em> которое вызывает функцию подписки или отписки в зависимости от текущего состояния. После, не забываем обновить это состояние. Использованный в примере код можно найти на <a href=\"https://github.com/justmarkup/demos/blob/gh-pages/push-notifications/public/script/push.js\">*GitHub</a>*.</p>\n<p>Последний шаг — регистрация сервис-воркера.</p>\n<h2>Сервис-воркер</h2>\n<p>В этой части мы разберем два необходимых для реализации пуш-уведомлений события: push и notificationonclick.</p>\n<pre><code>self.addEventListener('push', function(event) {\n  let notificationData = {};\n  \n  try {\n    notificationData = event.data.json();\n  } catch (e) {\n    notificationData = {\n      title: 'Default title',\n      body: 'Default message',\n      icon: '/default-icon.png'\n    };\n  }\n  \n  event.waitUntil(\n    self.registration.showNotification(notificationData.title, {\n      body: notificationData.body,\n      icon: notificationData.icon\n    })\n  );\n});\n</code></pre>\n<p>Начнем с push. Проверяем содержимое объекта notificationData (свойства title, body и icon), и, если не находим их, присваиваем дефолтные значения. После вызываем метод showNotification, он покажет уведомление пользователю.</p>\n<p><em>В дополнение к трём перечисленным свойствам могут использоваться и другие, например, badge, tag, vibrate. На момент написания этой статьи (февраль 2017) многие из них поддерживались только некоторыми браузерами. title, body и icon, доступных во всех браузерах, поэтому ограничимся ими.</em></p>\n<pre><code>self.addEventListener('notificationclick', function(event) {\n\n// close the notification\n  event.notification.close();\n\n// see if the current is open and if it is focus it\n  // otherwise open new tab\n  event.waitUntil(\n    self.clients.matchAll().then(function(clientList) {\n      \n      if (clientList.length > 0) {\n        return clientList[0].focus();\n      }\n      \n      return self.clients.openWindow('/');\n    })\n  );\n});\n</code></pre>\n<p>Событие notificationOnClick срабатывает в момент клика по уведомлению. Сначала закрываем уведомление. Затем проверяем, открыт ли наш сайт в текущей вкладке браузера, если нет, то открываем его с помощью openWindow().</p>\n<h2>Бэкенд</h2>\n<p>Переходим к серверной части, в которой мы используем <a href=\"https://github.com/web-push-libs/web-push\">*web-push library</a><em>. В нашем случае это реализация библиотеки для *Node.js</em>, но версии для <em>PHP</em>, <em>Java</em> и <em>C#</em> также доступны.</p>\n<p><em>Я предполагаю, что у вас есть базовые знания Node.js и опыт использования Express. В ином случае, я рекомендую вам ознакомиться с ними прежде чем продолжить.</em></p>\n<p>Итак, в первую очередь:</p>\n<ul>\n<li>\n<p>устанавливаем библиотеку командой npm install web-push --save,</p>\n</li>\n<li>\n<p>получаем доступ к ней с помощью require: const webPush = require('web-push');</p>\n<p>webPush.setVapidDetails(\n'<a href=\"mailto:hallo@justmarkup.com&#x27;\">hallo@justmarkup.com'</a>,\n'YOUR<em>PUBLIC</em>VAPID<em>KEY', // process.env.VAPID</em>PUBLIC<em>KEY,\n'YOUR</em>PRIVATE<em>VAPID</em>KEY', // process.env.VAPID<em>PRIVATE</em>KEY\n);</p>\n</li>\n</ul>\n<p>Теперь передаем данные <em>VAPID</em>. Помимо сгенерированной в начале пары ключей, нужно указать адрес электронной почты (с префиксом mailto:) либо <em>URL</em> сайта. Контактные данные могут потребоваться сервису для связи с вами. Обратите внимание на комментарии: я предпочел сохранить ключи в переменную окружения. Вы можете поступить так же или выбрать свой метод, но главное помните, **закрытый ключ **должен быть всегда защищен от обращений извне. Собственно поэтому он так и назван.</p>\n<p>Переходим к функции подписки:</p>\n<pre><code>app.post('/push/subscribe', function (req, res) {\n\nconst subscription = {\n    endpoint: req.body.endpoint,\n    keys: {\n      p256dh: req.body.keys.p256dh,\n      auth: req.body.keys.auth\n    }\n  };\n  \n  const payload = JSON.stringify({\n    title: 'Welcome',\n    body: 'Thank you for enabling push notifications',\n    icon: '/android-chrome-192x192.png'\n  });\n\nconst options = {\n    TTL: 3600 // 1sec * 60 * 60 = 1h\n  };\n\nwebPush.sendNotification(\n    subscription, \n    payload,\n    options\n    ).then(function() {\n      console.log('Send welcome push notification');\n      res.status(200).send('subscribe');\n      return;\n    }).catch(err => {\n      console.error('Unable to send welcome push notification', err );\n      res.status(500).send('subscription not possible');\n      return;\n  });\n\n})\n</code></pre>\n<p>В функции отправки подписки на сервер, получаем доступ к объекту subscription. В нем — значение endpoint и ключи доступа. Здесь я не буду останавливаться на вопросах работы с базой данных. Для примера укажу только, что для демо использована <a href=\"https://github.com/justmarkup/demos/blob/gh-pages/push-notifications/controllers/push.js#L19\">*Mongo DB</a>*.</p>\n<p><em>Прим. переводчика: endpoint — это уникальный URI, создаваемый для каждого пользователя индивидуально в соответствии <a href=\"https://random-push-service.com/some-kind-ofunique-id-1234/v2/\">с паттерном</a>: p256dh — открытый ключ, auth — закрытый ключ.</em></p>\n<p>Затем получаем наше первое уведомление — то, которое приветствует подписавшегося пользователя. Метод sendNotification() принимает три аргумента:</p>\n<ul>\n<li>\n<p>данные подписки, получаемые от браузера;</p>\n</li>\n<li>\n<p>информацию для пользователя (заголовок, сообщение, иконка — свойства title, body, icon соответственно);</p>\n</li>\n<li>\n<p>объект options, <a href=\"https://github.com/web-push-libs/web-push#sendnotificationpushsubscription-payload-options\">см. подробнее</a>.</p>\n</li>\n</ul>\n<p><em>TTL (Time To Live) — срок жизни уведомления —по умолчанию четыре недели. Это значит, что оно будет ожидать появления пользователя онлайн в течение этого срока. Например, если вы отправили уведомление пользователю в оффлайне, и он подключится к сети только через две недели, сообщение все равно будет доставлено. В моем случае разумно изменить TTL на более короткий срок.</em></p>\n<pre><code>app.post('/push/unsubscribe', function (req, res) {\n  // remove from database\n  Push.findOneAndRemove({endpoint: endpoint}, function (err,data) {\n    if (err) { \n      console.error('error with unsubscribe', error);\n      res.status(500).send('unsubscription not possible'); \n    }\n    console.log('unsubscribed');\n    res.status(200).send('unsubscribe');\n  });\n})\n</code></pre>\n<p>Если пользователь отменяет подписку, удаляем информацию о ней из базы.</p>\n<h2>Дополнительно</h2>\n<p>Вероятно, каждый из вас столкнется со своим случаем применения пуш-уведомлений, и просто скопировать код не получится. Однако я надеюсь, что этот урок поможет вам реализовать искомую функциональность как на стороне клиента, так и на стороне сервера.</p>\n<p><a href=\"https://push-notifications-vwursywdxa.now.sh\">Демо проекта</a>, исходный код опубликован на <a href=\"https://github.com/justmarkup/demos/tree/gh-pages/push-notifications\">GitHub</a>.</p>\n<p>Для более глубокого погружения в тему рекомендую бесплатную книгу <a href=\"https://web-push-book.gauntface.com\">Web Push Book</a> и примеры на <a href=\"https://serviceworke.rs/\">servicewore.rs</a>.</p>\n<p>Если вам есть что спросить, или есть что добавить, пишите в <a href=\"https://twitter.com/justmarkup\">Twitter</a> или по <a href=\"mailto:hallo@justmarkup.com\">электронной почте</a>.</p>\n<p><em>Перевод «<a href=\"https://justmarkup.com/log/2017/02/implementing-push-notifications/\">Implementing push notifications on the front-end and back-end</a>» Майкла Шарналя. Перевод <a href=\"https://medium.com/@vlad_poe\">Владислава Почепцова</a>, редактура <a href=\"https://medium.com/@pepelsbey\">Вадима Макеева</a>.</em></p>","frontmatter":{"title":"Реализуем пуш-уведомления на фронтенде и бэкенде","date":"TODO"}}},"pageContext":{"slug":"/articles/push-front-back/"}}