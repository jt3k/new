{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"40207e08-e97c-533d-b78b-4264373bdfbf","excerpt":"Роутинг, бандлинг и ленивая загрузка на Webpack Перевод «Multiple routes, bundling and lazy-loading» Серджио Гомеса. Обзор проблемы Мы с…","html":"<h1>Роутинг, бандлинг и ленивая загрузка на Webpack</h1>\n<p>Перевод «Multiple routes, bundling and lazy-loading» Серджио Гомеса.</p>\n<h2>Обзор проблемы</h2>\n<p>Мы с коллегами пишем клиентское приложение на нативном <em>JS</em>, которое разбивается на маршруты. Маршруты — это способ организации структуры сайта. Они как правило привязаны к отдельным <em>URL</em>. Таким образом, в интернет-магазине вы можете иметь различные маршруты, такие как главная, список категорий, страница продукта, и страница оформления заказа, каждый из которых может иметь свой собственный <em>JavaScript</em>. Например, для списка категорий может потребоваться код для обработки фильтрации, а для страницы оформления заказа может потребоваться иной код (для валидации формы).</p>\n<p>Однако мы не создаем полностью клиентское приложение. Пользователь может попасть на сайт через различные страницы, например, ввести <em>URL</em> в адресную строку и загрузить главную страницу, или найти интересный продукт в поисковике и перейти прямо на страницу описания этого продукта. Поэтому каждый из этих маршрутов должен иметь свою собственную структуру <em>URL</em>:</p>\n<pre><code>Home: /\nCategory listing: /category/42\nProduct page: /product/1234\nCheckout: /checkout\n</code></pre>\n<p>Кроме того, нам не нужно загружать весь <em>JavaScript</em> для всех маршрутов, когда сайт впервые открыт. В идеале, нам достаточно кода для того маршрута, который был открыт, а остальное можно подгружать, когда пользователь переходит на другие страницы сайта. Но если вы делаете единый бандл, то вы получите один массивный файл, который должен быть полностью загружен и проанализирован, прежде чем что-либо произойдет:</p>\n<pre><code>dist/\n  big-bundle.js\n</code></pre>\n<p>Это не лучшее решение, ведь подгружается много <em>JavaScript</em>, который не используется. При медленном подключении это может означать, что пользователю придется подождать довольно долгое время, прежде чем начать взаимодействовать со страницей. Вот почему большие бандлы являются антипаттерном.</p>\n<p>Вот где нам поможет концепция <strong>точки входа</strong>. Вместо того, чтобы иметь единый главный файл, мы решили иметь точку входа для каждого маршрута, при этом оставшиеся маршруты лениво загружаются по мере необходимости. В конечном итоге мы получим следующее:</p>\n<pre><code>dist/\n  bundle-home.js\n  bundle-category.js\n  bundle-product.js\n  bundle-checkout.js\n  home.js\n  category.js\n  product.js\n  checkout.js\n</code></pre>\n<p>В зависимости от маршрута, будет загружен только один из файлов пакета. Этот файл будет лениво загружать другие модули, по мере необходимости. И если пользователь открыл продукт, то загрузится только bundle-product.js, необходимый для текущей страницы , а затем лениво подгрузятся home.js, category.js и checkout.js , если это необходимо.</p>\n<p>Это решение позволяет загружать весь необходимый код для выполнения немедленного запроса пользователя и только при необходимости загружать остальной. И хотя это и включает в себя один и тот же код в нескольких файлах, фактически пользователь должен загружать только одну версию каждого модуля при навигации по сайту.</p>\n<h2>Webpack и модули</h2>\n<p>Существует миф, что <em>Webpack</em> трудно сконфигурировать, чтобы использовать его в большинстве ситуаций. Я использую <em>Webpack</em> недавно, и не могу судить насколько было правдиво это утверждение в прошлом, но оказывается, что сейчас <em>Webpack</em> довольно прост в использовании! Если вы знакомы с <em>ES</em>-модулями, статическим и динамическим импортом, вы в значительной степени готовы к созданию некоторых сложных приложений с хорошей практикой загрузки и без особых навыков конфигурирования.</p>\n<p><em>Webpack</em> понимает стандартизированный синтаксис <em>ES</em>-модулей, а также статическую и динамическую загрузку модулей. Он смотрит на ваш код и решает, как разделить его на пакеты в зависимости от того, какой тип импорта вы делаете. Таким образом, если вы загружаете модуль статически, он будет в бандле:</p>\n<pre><code>import Foo from './foo.js';\nFoo.doSomething();\n</code></pre>\n<p>Приведенные выше результаты соберутся в один файл bundle.js со всем кодом. Если вместо этого вы загружаете его динамически, то <em>Webpack</em> будет создавать отдельный бандл и получать дополнительный код по требованию:</p>\n<pre><code>import('./foo.js').then(module => {\n  module.doSomething();\n});\n</code></pre>\n<p>Приведенные выше результаты соберутся в bundle.js с некоторой магической ленивой загрузкой, и файл 0.js с кодом для foo. 0.js называется «чанком» в терминологии, предназначенной для ленивой загрузки другим кодом <em>Webpack</em>, и не обрабатывается непосредственно собственным кодом.</p>\n<h2>Множественные точки входа и роутинг</h2>\n<p>Хорошо, похоже, что все готово! Вы можете написать стандартизированный код модуля, который будет работать как изначально в браузере (если ваш браузер уже добавил поддержку), так и через некоторую магию в <em>Webpack</em>.</p>\n<p>Итак, давайте напишем код и посмотрим, как это на самом деле выглядит. Я вернусь к исходному примеру и использую маршруты для страниц категории, продукта, оформления заказа и главной, а также соответствующую точку входа для каждого из них.</p>\n<p>Модули довольно просты. Вы можете создать один метод с любым именем, так как содержание не имеет значения для примера:</p>\n<pre><code>export function printMessage() {\n  console.log('Hi! This is the Checkout module.');\n}\n</code></pre>\n<p>Каждый файл точки входа будет загружать соответствующий модуль статически, а остальные модули динамически. Чтобы избежать дублирования кода, вам нужно создать простой, последовательный интерфейс для определения всего остального. Вот пример, который я называю Router.</p>\n<p><strong>*Примечание:</strong> хоть этот пример и не будет делать какие-либо фактические маршрутизации, в традиционном смысле, он будет определять какой код будет загружаться по маршруту. Так что я все еще думаю, что это нормальное имя:)*</p>\n<pre><code>const _modules = {\n  Home: import('./home.js'),\n  Category: import('./category.js'),\n  Product: import('./product.js'),\n  Checkout: import('./checkout.js'),\n};\n\nexport default class Router {\n  static get modules() {\n    return _modules;\n  }\n}\n</code></pre>\n<p>Каждый модуль хранится как запись в объекте _modules, причем значение является промисом загрузки, возвращаемым import(). Обратите внимание, что это немедленно начнет загружать другие маршруты, которые вам, возможно, не понадобятся, но в этом случае вы всегда можете отложить загрузку явным вызовом, который вызовет фактический импорт. Например:</p>\n<pre><code>const _modules = {\n  Home: () => import('./home.js'),\n  Category: () => import('./category.js'),\n  Product: () => import('./product.js'),\n  Checkout: () => import('./checkout.js'),\n};\n\nexport default class Router {\n  static get modules() {\n    return _modules;\n  }\n}\n</code></pre>\n<p>Но если все четыре модуля загружаются лениво, как избежать дублирования кода в точке входа? Безусловно, один из них должен быть null?</p>\n<p>На самом деле в этом нет необходимости! Браузер (с поддержкой модулей) и <em>Webpack</em> делают дедупликацию, где они отслеживают, какие модули были загружены, чтобы они не загружались дважды. Таким образом, вам, как разработчику, не нужно беспокоиться о том, чтобы отслеживать что-либо из этого. Это делает точку входа действительно чистой и легкой для понимания:</p>\n<pre><code>import * as Home from './home.js';\nimport Router from './router.js';\n\nconsole.log('Hello from the Home entry point!');\n\nRouter.modules.Home().then(module => module.printMessage());\nRouter.modules.Category().then(module => module.printMessage());\nRouter.modules.Product().then(module => module.printMessage());\nRouter.modules.Checkout().then(module => module.printMessage());\n</code></pre>\n<p>Главная загружается статически, так что она сразу же доступна и не требует ожидания ленивой загрузки. Router также загружается статически. После того, как вы сделаете запрос к Router, он проверяет, был ли загружен этот модуль либо статически, либо динамически. Если он уже был загружен, промис немедленно разрешается. Если этого не произошло, он извлекает файл, загружает код и продолжает цепочку промисов после этого.</p>\n<p>Это означает, что все модули могут использоваться точно так же, входным модулем или, если это было реальное приложение с надлежащей маршрутизацией <em>URL</em>, самим Router.</p>\n<h2>Как мне заставить это работать в Webpack?</h2>\n<p>Как я упоминал ранее, все это должно работать в браузере без изменений, если ваш браузер поддерживает <em>ES-</em>модули и их загрузку. Вы не получите преимущества от сборки без некоторой дальнейшей работы, но код все еще функционален.</p>\n<p>Тем не менее, поскольку большинство из нас все еще собирают в бандл, нам нужно найти способ заставить это работать с <em>Webpack</em>. И оказывается все очень просто! Вот файл webpack.config.js:</p>\n<pre><code>const path = require('path');\nmodule.exports = {\n  entry: {\n    'bundle-home': './entry-home.js',\n    'bundle-category': './entry-category.js',\n    'bundle-product': './entry-product.js',\n    'bundle-checkout': './entry-checkout.js',\n  },\n  output: {\n    path: path.resolve('./dist'),\n    filename: '[name].js',\n  }\n}\n</code></pre>\n<p>Главное здесь — убедиться, что все точки входа являются частью одного формирования, чтобы создать только один набор динамически загружаемых блоков. Выходное имя файла основано на ключе для каждой точки входа, благодаря использованию [name], поэтому вывод выглядит следующим образом:</p>\n<pre><code>dist/\n  0.js\n  1.js\n  2.js\n  3.js\n  bundle-category.js\n  bundle-checkout.js\n  bundle-home.js\n  bundle-product.js\n</code></pre>\n<p>Числовые файлы включают в себя модуль, завернутый в <em>JSONP</em>. Собранные файлы имеют код для этой точки входа, связанный с кодом Router и некоторыми методами, обрабатывающими отложенную загрузку.</p>\n<p>Если вы загрузите файл bundle-checkout.js на тестовой странице и посмотрите на отладчик <em>Chrome</em>, вы можете убедится, что загружаются только три чанка, как и ожидалось. Вы также можете увидеть, что сообщение из модуля Checkout поступает из bundle-checkout.js, что означает, что модуль Checkout попал в этот файл.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2660/0*pnJPmIbgfe86W1QK.png\"></p>\n<h2>Выводы и предостережения</h2>\n<p>Обратите внимание, что этот пример довольно прост, и реальное приложение будет иметь дополнительные требования, такие как необходимость использовать <em>CommonsChunkPlugin</em> для более легкого разделения битов кода, или, возможно, некоторые потенциальные сложности, возникающих при использовании <em>npm</em>-модулей в качестве зависимостей. Это, вероятно, потребует дополнительной работы над конфигурацией <em>Webpack</em>.</p>\n<p>Тем не менее, я чувствовал, что это интересная проблема и достаточно достойное решение, чтобы поделиться, поэтому я надеюсь, что вы найдете его полезным! Особая благодарность Сурме и Сэму Даттону за помощь в поисках более чистого решения!</p>\n<p><em>Перевод <a href=\"https://medium.com/@nzvtrkk\">Артура Храброва</a>, редактура <a href=\"https://medium.com/@pepelsbey\">Вадима Макеева</a>.</em></p>","frontmatter":{"title":"Роутинг, бандлинг и ленивая загрузка на Webpack","date":"TODO"}}},"pageContext":{"slug":"/articles/multiple-routes-webpack/"}}