{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"8aac479f-be3c-5c10-8500-354095058eb7","excerpt":"Функции-декораторы, которые можно написать с нуля Перевод «Here are a few function decorators you can write from scratch» Кристи Сальсезку…","html":"<h1>Функции-декораторы, которые можно написать с нуля</h1>\n<p>Перевод «Here are a few function decorators you can write from scratch» Кристи Сальсезку.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/10392/1*Qw0e4LC2Fri7dFkBY0N1cA.jpeg\" alt=\"Фото [Calum Lewis](https://unsplash.com/photos/rkT_TG5NKF8).\"><em>Фото <a href=\"https://unsplash.com/photos/rkT_TG5NKF8\">Calum Lewis</a>.</em></p>\n<blockquote>\n<h1>Декораторы — это функции высшего порядка, которые принимают в качестве аргумента одну функцию и возвращают другую. Возвращаемая функция является преобразованным вариантом функции-аргумента <a href=\"https://leanpub.com/javascript-allonge/read#decorators\">*Javascript Allongé</a>*</h1>\n</blockquote>\n<p>Давайте самостоятельно напишем некоторые базовые дектораторы, представленные в таких библиотеках, как <a href=\"http://underscorejs.org/#functions\">*underscore.js</a><em>, [</em>lodash.js](<a href=\"https://lodash.com/docs/4.17.5\">https://lodash.com/docs/4.17.5</a>)<em>, [</em>ramda.js](<a href=\"http://ramdajs.com/docs/\">http://ramdajs.com/docs/</a>)*.</p>\n<h2>once()</h2>\n<ul>\n<li>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/zpLeLp0v/\">once(fn)</a> создает экземпляр функции, которая должна быть выполнена только один раз. Паттерн может быть использован, например, для инициализации, когда нужно быть уверенным в единичном запуске функциональности, даже если сама функция вызвана в нескольких местах.</p>\n<p>function once(fn){\nlet returnValue;\nlet canRun = true;\nreturn <strong>function runOnce(){\nif(canRun) {\nreturnValue = fn.apply(this, arguments);\ncanRun = false;\n}\nreturn returnValue;\n}</strong>\n}</p>\n<p>var processonce = once(process);\nprocessonce(); // process\nprocessonce(); //</p>\n</li>\n</ul>\n<p>Функция once() возвращает другую функцию — runOnce(), использующую <a href=\"https://medium.freecodecamp.org/why-you-should-give-the-closure-function-another-chance-31253e44cfa0\">замыкание</a>. Обратите также внимание, как осуществлен вызов оригинальной функции, а именно через передачу this и arguments в метод apply: fn.apply(this, arguments).</p>\n<p>Если хотите узнать замыкания глубже, обратите внимание на статью «<a href=\"https://medium.com/p/31253e44cfa0\">Why you should give the Closure function another chance</a>».</p>\n<h2>after()</h2>\n<ul>\n<li>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/4evuoxe6/\">after(count, fn)</a> создает вариант функции, которая будет выполнена только после определенного количества вызовов. Функция полезна, например, если должна быть выполнена *только *по завершению асинхронных операций.</p>\n<p>function after(count, fn) {\nlet runCount = 0;\nreturn function runAfter() {\nrunCount = runCount + 1;\nif (runCount >= count) {\nreturn fn.apply(this, arguments);<br>\n}\n}\n}</p>\n<p>function logResult() { console.log(\"calls have finished\"); }\n<strong>let logResultAfter2Calls = after(2, logResult);</strong></p>\n<p>setTimeout(function logFirstCall() {\nconsole.log(\"1st call has finished\");\n<strong>logResultAfter2Calls();</strong>\n}, 3000);</p>\n<p>setTimeout(function logSecondCall() {\nconsole.log(\"2nd call has finished\");\n**logResultAfter2Calls(); **\n}, 4000);</p>\n</li>\n</ul>\n<p>В примере выше при помощи after() я создаю функцию logResultAfter2Calls(). Она в свою очередь выполняет logResult() только после второго вызова.</p>\n<h2>throttle()</h2>\n<ul>\n<li>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/5tdv0eq6/\">throttle(fn, wait)</a> создает вариант функции, которая при повторяющихся вызовах выполняется через указанный временной интервал (аргумент wait). Декоратор эффективен для обработки быстро повторяющихся событий.</p>\n<p>function throttle(fn, interval) {\nlet lastTime;\nreturn function throttled() {\nlet timeSinceLastExecution = Date.now() - lastTime;\nif(!lastTime || (timeSinceLastExecution >= interval)) {\nfn.apply(this, arguments);\nlastTime = Date.now();\n}\n};\n}</p>\n<p>let throttledProcess = throttle(process, 1000);\n$(window).mousemove(throttledProcess);</p>\n</li>\n</ul>\n<p>Здесь движение мыши генерирует множество событий mousemove, тогда как оригинальная функция process() вызывается лишь раз в секунду.</p>\n<h2>debounce()</h2>\n<ul>\n<li>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/424unsa7/\">debounce(fn, wait)</a> создает вариант функции, которая выполняет <em>оригинальную *функцию спустя wait миллисекунд *после</em> предыдующего вызова *декорированной *функции. Паттерн также применяется в работе с повторяющимися событиями. Он полезен, если функциональность должна быть выполнена по завершению очереди событий.</p>\n<p>function debounce(fn, interval) {\nlet timer;\nreturn function debounced() {\nclearTimeout(timer);\nlet args = arguments;\nlet that = this;\ntimer = setTimeout(function callOriginalFn() {\nfn.apply(that, args);\n}, interval);\n};\n}</p>\n<p>let delayProcess = debounce(process, 400);\n$(window).resize(delayProcess);</p>\n</li>\n</ul>\n<p>Функция debounce() часто используется вместе с событиями scroll, resize, mousemove и keypress.</p>\n<h2>Частичное применение</h2>\n<p>Частичное применение преобразует функцию за счет изменения количества параметров. Это один из примеров движения от общего к частному.</p>\n<h2>partial()</h2>\n<p>На этот раз <a href=\"https://jsfiddle.net/cristi_salcescu/sbborekp/\">создадим метод partial()</a> и сделаем его доступным для всех функций. В данном примере я использую синтаксис <em>ECMAScript 6</em>, а именно оператор rest. С его помощью набор аргументов функции преобразуется в массив ...leftArguments. Это нужно для конкатенации массивов, тогда как специальный объект arguments массивом не является.</p>\n<pre><code>Function.prototype.partial = function(...leftArguments){\n    let fn = this;\n    return function partialFn(...rightArguments){\n       let args = leftArguments.concat(rightArguments);\n       return fn.apply(this, args);\n    }\n}\n\nfunction log(level, message){\n    console.log(level  + \" : \" + message);\n}\n\n**let logInfo = log.partial(\"Info\");\nlogInfo(\"here is a message\");**\n</code></pre>\n<p>Обратите внимание, созданная таким образом logInfo() использует лишь один аргумент message.</p>\n<h2>Заключение</h2>\n<p>Применение указанных функций помогает понять принципы работы декораторов и саму идею инкапсуляции логики внутри них.</p>\n<p>Декораторы — мощный инструмент расширения функциональности без изменения исходной функции. Это отличный путь переиспользовать код, и он соответствует функциональной парадигме программирования.</p>\n<h3><strong>Больше о ФП в JavaScript</strong></h3>\n<ul>\n<li>\n<p><a href=\"https://medium.com/p/33dcb910303a\">How point-free composition will make you a better functional programmer</a></p>\n</li>\n<li>\n<p><a href=\"https://medium.com/p/13ba11825319\">You will finally understand what Closure is</a></p>\n</li>\n<li>\n<p><a href=\"https://medium.com/p/73258b6a8d15\">Class vs Factory function: exploring the way forward</a> (см. <a href=\"https://medium.com/@kanby/%D0%BA%D0%BB%D0%B0%D1%81%D1%81-vs-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BF%D0%B5%D1%80%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-9b4c696823c8\">перевод</a>).</p>\n</li>\n<li>\n<p><a href=\"https://medium.com/p/94fb8cc69f9d\">Make your code easier to read with Functional Programming</a></p>\n</li>\n</ul>\n<p><em>Перевод <a href=\"https://medium.com/@vlad_poe\">Влада Почепцова</a>, редактура <a href=\"https://medium.com/@pepelsbey\">Вадима Макеева</a>.</em></p>","frontmatter":{"title":"Функции-декораторы, которые можно написать с нуля","date":"TODO"}}},"pageContext":{"slug":"/articles/function-decorators/"}}