{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"127467d5-bc79-521f-998b-4f061d6a7580","excerpt":"Обещание бургерной вечеринки Перевод статьи «The Promise of a Burger Party» Марико Косаки. Я написала этот пост как альтернативное введение…","html":"<h1>Обещание бургерной вечеринки</h1>\n<p>Перевод статьи «The Promise of a Burger Party» Марико Косаки.</p>\n<p><em>Я написала этот пост как альтернативное введение в JavaScript-промисы. Я набросала его в своем блокноте во время чтения многочисленных статей на эту тему. Если вам нужно более глубокое руководство, в конце статьи есть список для дальнейшего изучения.</em></p>\n<p>Пару недель назад я участвовала в обсуждении кое-какой функциональности на JavaScript. Она должна была работать асинхронно с использованием внешних данных. Я сказала: <em>«ладно, давайте используем fetch()… тогда в коде это… эм-м…» *И пока я молчала, пытаясь вспомнить *API Fetch</em>, мой собеседник сказал: «<em>он возвращает промис»</em>. Я впала в ступор и ответила: «<em>честно говоря, я не очень понимаю, что это значит…»</em></p>\n<p>Я множество раз писала код на основе промисов, но в этот раз части почему-то не сложились в единую картину. Я поняла, что в действительности так и не разобралась с ними.</p>\n<iframe src=\"https://medium.com/media/6843ee4f347528b7d397ac9dfab79a85\" frameborder=0></iframe>\n<p>Если вы читаете меня <a href=\"https://twitter.com/kosamari\">в Twitter</a>, то знаете, что я учусь на визуальных примерах: беру <a href=\"https://twitter.com/kosamari/status/807303762188574720\">объекты реального мира</a> как метафоры для сложных концепций в коде и изображаю их в виде <a href=\"https://twitter.com/kosamari/status/806941856777011200\">рисунков</a>. Это позволяет мне совладать с двойным уровнем абстракции: языком программирования и английского как неродного языка. В общем, мне пришлось рисовать и в этот раз.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*3U8UF-FdRnWK3RE44NGKyg.png\"></p>\n<p>А вот пример кода, с которым мы будем иметь дело в этой истории.</p>\n<pre><code>*// Асинхронная операция*\nfunction cookBurger (type) { ... }  \n\n*// Обычная операция*\nfunction makeMilkshake (type) { ... }\n\n*// Функция оформления заказа, возвращает промис\n*function order (type) {   \n   return new Promise(function(resolve, reject) {\n      var burger = cookBurger(type)\n      burger.ready = function (err, burger) {\n         if (err) {\n            return reject(Error('Error while cooking'))\n         }\n         return resolve(burger)\n      }\n   })\n}\n\norder('JakeBurger')\n   .then( burger => {\n      const milkshake = makeMilkshake('vanila')\n      return { burger: burger, shake: milkshake }\n   })\n   .then( foodItems => {\n      console.log('BURGER PARTY !', foodItems)\n   })\n   .catch( err => {\n     console.log(err)   \n   })\n</code></pre>\n<h3>Устроим бургерную вечеринку!</h3>\n<p>Добро пожаловать в парк Промис-Сквер, место встречи всех любителей бургеров — кафе «ДжейкШак». Бургеры ДжейкШака очень популярны в окру́ге, но в кафе мало кассовых аппаратов, и очередь из посетителей никогда не убывает. Несмотря на это, на кухне хватает рук, чтобы принимать множество заказов одновременно.</p>\n<p><em>Если вы не в курсе: <a href=\"http://www.foodsmackdown.com/2011/08/shake-shack-new-york-madison-square-park/\">кафе ShakeShak в парке Мэдисон-Сквер</a> — это место в Нью-Йорке. Кафе действительно отличное, но туда всегда длинная очередь .</em></p>\n<h2>Пообещать сделать</h2>\n<p>Чтобы принимать заказы максимально быстро, ДжейкШак использует систему сигнальных брелков. После оплаты заказа на кассе, сотрудник кафе выдает посетителю поднос и такой брелок.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*Gh5Pv0ujTuikxGZMeANfCg.png\"></p>\n<p>Поднос — это промис*, *обещание ДжейкШака преподнести вам вкуснейший бургер, как только тот будет готов, а брелок — индикатор состояния вашего заказа. Брелок молчит? — значит заказ <strong>в процессе</strong> и лучшие повара трудятся над вашим бургером. Брелок загорелся красным и гудит? — значит заказ <strong>приготовлен</strong>.</p>\n<p>Но есть небольшой нюанс: «приготовлен» — не значит «готов». Это значит, что работа поваров над заказом завершена, и они хотят, чтобы вы подошли и забрали его. Вы как клиент, вероятно, хотите просто получить свой бургер, но, в некоторых случаях, предпочтёте уйти. Дело ваше.</p>\n<p>Давайте посмотрим, как это работает в коде. Когда вы вызываете функцию order (делаете заказ), она возвращает promise (выдает поднос и брелок как обещание выполнить заказ). Возвращённое значение (бургер) должен появиться на подносе, когда будет исполнен промис (данное вам обещание) и сработал колбэк. Подробнее об этом в следующем разделе!</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*-h3389QFwG0TG01piaFQjg.png\"></p>\n<h2>Добавьте обработчики промисов</h2>\n<p>Ой, кажется брелок загудел. Пойдемте за стойку попросим заказ. На этом этапе возможны два сценария развития событий.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*EvC0N4I6l5WWH7CM9f0THg.png\"></p>\n<p><strong>1. Заказ исполнен</strong></p>\n<p>Ура-а! Ваш заказ готов, сотрудник кафе выносит свежий ароматный бургер. Обещание приготовить отличный бургер можно считать выполненным.</p>\n<p><strong>2. Заказ отклонен</strong></p>\n<p>Похоже, на кухне закончились котлеты. Обещание приготовить бургер выполнено не будет, оно отменяется. Не забудьте потребовать назад ваши деньги!</p>\n<p>Посмотрим, как мы можем подготовиться к этим двум ситуациям в нашем коде.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*XbbU9ZKSkEXPgkvFmULtIA.png\"></p>\n<p><em>Метод .then() принимает вторым аргументом функцию. Эта функция является обработчиком для reject. Но для простоты в своем примере я буду использовать для обработки ошибок только .catch(). Если вы хотите узнать подробнее о разнице, вам может пригодиться <a href=\"https://developers.google.com/web/fundamentals/getting-started/primers/promises#error_handling\">эта статья</a>.</em></p>\n<h2>Связываем промисы</h2>\n<p>Скажем, ваш заказ был успешно выполнен, но тут вы вспоминаете, что для фееричной бургерной вечеринки вам не хватает молочного коктейля… и вы идете в очередь «С» (специальная очередь за напитками, <a href=\"http://midtownlunch.com/2010/08/02/midtown-times-square-shake-shack-finally-add-a-c-line/\">существует в ShakeShack на самом деле</a>, чтобы справиться с наплывом посетителей). При заказе коктейля кассир вручает вам другой поднос и еще один брелок. Так как напитки готовятся быстро, кассир сам выдает заказ, и не нужно ждать, когда загудит брелок (он уже гудит!).</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*WgzhaiCXhXQjrL04woAaEg.png\"></p>\n<p>Посмотрим, как это работает в коде. Чтобы соединить промисы в цепочку, достаточно всего лишь добавить еще один then(), он всегда возвращает промис. Просто запомните: каждый .then() возвращает поднос и брелок, а текущее возвращаемое значение передается аргументом в коллбэк.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/5464/1*JogpJI8YjDS7kkhTGgdcaQ.png\"></p>\n<p>Теперь, когда у вас есть бургер и молочный коктейль, вы готовы к БУРГЕРНОЙ ВЕЧЕРИНКЕ 🎉!</p>\n<h2>Другие трюки для вечеринок!</h2>\n<p>У промисов есть и другие методы, которые позволяют делать классные трюки.</p>\n<p>Promise.all() создает промис, принимающий массив промисов (<em>items</em>). Он исполняется, когда исполнены все элементы массива, каждый из которых тоже промис. Представим это так: вы заказали для друзей пять бургеров, но не хотите все пять раз бегать к стойке. Достаточно сделать это один раз, когда все бургеры будут готовы. Promise.all() в этом случае — отличное решение.</p>\n<p>Promise.race() похож на Promise.all(), но исполнится или будет отклонен, как только будет исполнен или отклонен один из элементов массива промисов. Своего рода принцип «хватай и беги». Скажем, вы очень голодны и заказали бургер, чизбургер и хотдог одновременно, но заберёте только то, что быстрее приготовят. Обратите внимание, в этом случае, если на кухне закончились котлеты для бургеров, и отказ по бургеру вернется первым, то и все прочие заказы будут отменены.</p>\n<p>Помимо этого, в JavaScript-промисах есть много других вещей для изучения. Ниже ссылки на материалы, которые я для этого рекомендую:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/mattdesl/promise-cookbook/blob/master/README.md\">promise-cookbook</a> — на английском, также доступна версия на китайском;</p>\n</li>\n<li>\n<p><a href=\"https://developers.google.com/web/fundamentals/getting-started/primers/promises\">JavaScript Promises: an Introduction</a> — на английском;</p>\n</li>\n<li>\n<p><a href=\"http://azu.github.io/promises-book/\">JavaScript Promiseの本</a> — на японском, китайском и корейском языках.</p>\n</li>\n</ul>\n<p>Спасибо Джейку Арчибальду и Нолану Лоусону за вычитку статьи и ценные советы, а также Крису Уитли за найденную в коде ошибку.</p>\n<p><em>Перевод «<a href=\"http://kosamari.com/notes/the-promise-of-a-burger-party\">The Promise of a Burger Party</a>» Марико Косаки. Перевод <a href=\"https://medium.com/@vlad_poe\">Владислава Почепцова</a>, редактура <a href=\"https://medium.com/@pepelsbey\">Вадима Макеева</a>. Опубликовано под лицензией <a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\">CC BY-NC-SA 4.0</a>.</em></p>","frontmatter":{"title":"Обещание бургерной вечеринки","date":"TODO"}}},"pageContext":{"slug":"/articles/promise-burger-party/"}}