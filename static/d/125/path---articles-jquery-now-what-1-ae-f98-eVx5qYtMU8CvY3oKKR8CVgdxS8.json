{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"45ad5547-e498-5cd0-8148-1c3d2f35591d","excerpt":"Я знаю jQuery. И что? Реми Шарп  16 декабря 2013 На конференции jQuery UK 2013 я делал доклад под названием « Я знаю jQuery. И что…","html":"<h1>Я знаю jQuery. И что?</h1>\n<p><a href=\"http://remysharp.com\">Реми Шарп</a> 16 декабря 2013</p>\n<p>На конференции jQuery UK 2013 я делал доклад под названием «<a href=\"https://speakerdeck.com/rem/i-know-jquery-now-what\">Я знаю jQuery. И что?</a>». Обычно я готовлюсь, устраивая взрыв из стикеров на своём столе, но в этот раз я сперва написал пост, а потом уже сделал слайды. Итак, вот мой практически не отредактированный и немного путаный рассказ о том, как я работал с jQuery, и как я смотрю на использование встроенных браузерных технологий.</p>\n<h2>7 лет назад…</h2>\n<p>17 июня 2006 года я опубликовал мой самый первый настоящий <a href=\"http://web.archive.org/web/20061018170852/http://leftlogic.com/info/articles/auto-selecting_navigation\">пост в блоге</a>: я взял обычный JavaScript и упростил его с помощью jQuery. В итоге 14 строчек JavaScript превратились в три строчки на jQuery (версии pre-1.0).</p>\n<p>Самый важный эффект от jQuery был в том, что вместо муторной навигации по DOM вы писали простой CSS-селектор, после чего к нужному элементу добавлялся класс. К тому же, исходный JavaScript-код был довольно нестабильным, а разметка у вас получалась одна и та же в обоих случаях.</p>\n<p>Я показал jQuery команде разработчиков, с которыми я сотрудничал в середине 2000-х, и даже дизайнеры увидели все плюсы этого подхода, поскольку CSS-селекторы были им уже знакомы (именно так и возникла идея «jQuery для дизайнеров»).</p>\n<h3>Внезапно навигация по DOM стала простой</h3>\n<p>В те времена навигация по DOM была очень сложной. Можно было поспорить — если у вас получалось что-то сделать в Firefox 1.5, то в IE6 это не работало.</p>\n<p>Простота, с которой можно было изучить jQuery, стала для меня плюсом. Вся навигация по DOM делалась с помощью CSS-селекторов (реализовано это было какой-то безумной магией из «черного ящика», которую придумал Джон Резиг) — главное, что это экономило мои ограниченные мыслительные ресурсы, и, когда я получал нужные мне элементы DOM, я уже мог делать с ними все что угодно (показывать, скрывать, анимировать и т.п.)</p>\n<h3>Понимание Ajax</h3>\n<p>jQuery также поставила на доступный мне уровень абстракцию Ajax. Этот термин был придуман буквально только что, в 2005 году, и документации по технологии было мало, понять её было непросто (не забывайте про ограниченные вычислительные способности моего мозга).</p>\n<p>Итак, мне нужно было работать с объектом <code>XMLHttpRequest</code>. Когда я увидел его впервые, мне стоило усилий понять, как работает событие <code>onreadystatechange</code> и пара <code>this.status</code> и <code>this.readyState</code>. jQuery, как и ряд других библиотек, разобралась с тем ужасом, который представляли собой XHR-запросы в IE через ActiveX…</p>\n<pre><code>function getXmlHttpRequest() {\n    var xhr;\n        if (window.XMLHttpRequest) {\n            xhr = new XMLHttpRequest();\n    } else {\n            try {\n                xhr = new ActiveXObject(\"Msxml2.XMLHTTP\");\n        } catch (e) {\n            try {\n                xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        } catch (e) {\n                xhr = false;\n        }\n    }\n}\n    return xhr;\n}\n// Код, который Джон написал в jQuery,\n// куда более элегантен!\n</code></pre>\n<p>Когда я увидел, что в jQuery можно использовать функцию <code>ajax</code>, для того чтобы выцепить HTML по какому-то адресу (именно это мы обычно и хотели делать с помощью Ajax), вся технология внезапно стала для меня понятной.</p>\n<p>jQuery сразу и надолго стала моим обычным инструментом. Это был мой «швейцарский нож», если позаимствовать <a href=\"http://events.jquery.org/2013/uk/schedule.html#adam\">название доклада Адама</a>!</p>\n<h2>Назад в будущее: сегодня</h2>\n<p>Давайте промотаем ленту вперед и вернемся в сегодняшний день. Что случилось за эти годы?</p>\n<p>Для начала: моя позиция по умолчанию — это не «всегда подключай jQuery». Я лучше знаю JavaScript, и как в нём все работает. У меня появились собственные критерии, когда нужно подключать jQuery, а когда нет. Но если я не подключаю jQuery, что тогда?</p>\n<p>За эти семь лет произошло довольно многое. Вероятно, одним из самых важных шагов вперед стало появление в браузерах <code>querySelectorAll</code>.</p>\n<p>Возможность передать встроенной функции внутри браузера CSS-селектор, чтобы сам браузер работал над навигацией по DOM — это огромная (правда!) часть jQuery. Базовая поддержка была в Chrome с самого начала, в IE8 и Firefox 3.5 появилась в середине 2009 года.</p>\n<p>Эндрю Ланни (из PhoneGap и Adobe) написал невероятно простую функцию:</p>\n<pre><code>var $ = document.querySelectorAll.bind(document);\nElement.prototype.on = Element.prototype.addEventListener;\n\n$('#somelink')[0].on('touchstart', handleTouch);\n</code></pre>\n<p>Это просто и прекрасно.</p>\n<p>Я взял его идею, немного развил ее и использовал в ряде довольно специфических проектов, добавив поддержку для чейнинга, циклов и упростив синтаксис. В сжатом виде все занимает меньше 200 байт. Смысл этого в том, что сейчас у нас есть встроенная в браузеры поддержка для ряда функций, и я стараюсь принимать во внимание аудиторию своего проекта, перед тем как по умолчанию подключать jQuery.</p>\n<h2>В каких случаях я всегда использую jQuery</h2>\n<p>Прежде чем я расскажу о том, как я могу обходиться без jQuery, быть «нагим» — давайте я расскажу о случаях, когда я точно включаю jQuery в проект. Есть несколько довольно специфических причин, которые заставляют меня либо начинать прямо с jQuery, либо переключаться на нее с какого-то специально написанного решения.</p>\n<p>Перед этим я должен оговориться относительно случая, когда я абсолютно точно не использую jQuery: если я пытаюсь воспроизвести баг в браузере, я никогда не использую библиотеку. Если вы пытаетесь найти баг, чтобы можно было сообщить о проблеме, необходимо, чтобы в примере было как можно меньше кода (конечно, кроме тех случаев, когда вы отправляете сообщение об ошибке внутри jQuery!).</p>\n<h3>1. Когда проект должен работать в устаревших браузерах</h3>\n<p>BBC достаточно четко озвучили, <a href=\"http://responsivenews.co.uk/post/18948466399/cutting-the-mustard\">что именно они называют современным браузером</a>, и по некотором размышлении это и есть тот признак, по которому я решаю, включать jQuery по умолчанию или нет.</p>\n<p>Если я знаю, что я должен работать с несовременными браузерами, и они составляют часть ядра аудитории, то я начну с jQuery внутри своего кода.</p>\n<p>Что значит «современный»? По большому счету, ответ простой: поддерживает ли браузер <code>querySelectorAll</code>? BBC применяет следующий тест на соответствие требованию современности:</p>\n<pre><code>if (querySelector in document &#x26;&#x26;\n    localStorage in window &#x26;&#x26;\n    addEventListener in window) {\n    // Загружаем JavaScript-приложение\n}\n</code></pre>\n<p>Я знаю наизусть, что IE8 не поддерживает <code>addEventListener</code> (<a href=\"https://gist.github.com/eirikbacker/2864711\">хотя и существует полифил</a>), так что, если поддержка этого браузера важна для проекта, я понимаю, что не хочу начинать проект с хаков для IE8.</p>\n<p>Не то чтобы я хочу сказать, что те проекты, которые я начинаю без jQuery, не будут поддерживать IE8. Скорее — что нужно начинать с малого и делать разработку простой с самого начала. Если я начну проект с охапки хаков — проблем не оберёшься.</p>\n<p>И еще я считаю это тем случаем, «когда сложность перевешивает простоту».</p>\n<h3>2. Когда я делаю что-то дешево и сердито</h3>\n<p>Если я создаю какой-то концепт, тестирую идею или просто что-то набрасываю и отправляю в <a href=\"http://jsbin.com\">JS Bin</a>, обычно я просто добавляю jQuery по умолчанию. Так мне не приходится лишний раз думать.</p>\n<h2>Без jQuery!</h2>\n<p>Наверное, вы думаете: «Так, Реми использует jQuery, а если нет, то просто переписывает все фичи сам?»</p>\n<p>Я совершенно не хочу изобретать велосипед. Если я обнаруживаю, что, разрабатывая без jQuery, я в итоге сам переписываю с нуля ее функциональность, тогда, ясное дело, я просто трачу свое время впустую.</p>\n<p>Нет, всё не так. Просто есть довольно много сценариев, в которых я буду писать код своего приложения без библиотеки, опираясь на встроенные в браузер технологии. Если какая-то часть этих технологий не поддерживается в том или ином браузере, я могу прибегнуть к <a href=\"http://remysharp.com/2010/10/08/what-is-a-polyfill/\">полифилам</a> — но только после тщательного рассмотрения и понимания, что это имеет смысл.</p>\n<p>Итак, как я живу без jQuery, и насколько полной можно считать поддержку нужных технологий в браузерах?</p>\n<h2>document.ready</h2>\n<p>Даже когда я использую jQuery, если у меня (или моей компании) есть контроль над проектом, я очень редко использую <code>document.ready</code> (или его короткую версию: <code>$(function)</code>).</p>\n<p>Дело в том, что весь JavaScript я размещаю под всем DOM, перед тегом <code>&#x3C;/body></code>. Так я всегда уверен, что в этот момент весь DOM уже будет обработан браузером.</p>\n<p>Надеюсь, что вы это и так знаете, но JavaScript блокирует рендеринг страницы. Если вы разместите JavaScript над содержимым, и ваш сервер подвиснет — вы получите пустую страницу. Я много раз уже использовал этот пример, но повторюсь, что раньше (довольно давно) виджет Twitter просто вставлялся в HTML вашей страницы. Их сайт частенько падал, и мой блог (с этим виджетом) зависал на пустой странице — так что выглядело все так, будто упал мой сайт.</p>\n<h2>.attr('value') и .attr('href')</h2>\n<p>Мне всегда становится грустно, когда я вижу, как jQuery используется для того, чтобы получить значение элемента <code>&#x3C;input></code>:</p>\n<pre><code>$('input').on('change', function () {\n    var value = $(this).attr('value');\n    alert('The new value is' + value);\n});\n</code></pre>\n<p>Почему? Потому что всегда можно получить значение элемента с помощью <code>this.value</code>. Что важнее — нужно думать о том, как вы используете JavaScript-библиотеку. Не применяйте jQuery без необходимости.</p>\n<p>Дело здесь не в jQuery. Это просто нормальная практика. Нужно, чтобы в коде просто было написано:</p>\n<pre><code>$('input').on('change', function () {\n    alert('The new value is' + this.value);\n});\n</code></pre>\n<p>Еще люди довольно часто используют jQuery для того, чтобы получить <code>href</code> ссылки: <code>$(this).attr('href')</code>, но можно вполне легко получить путь и из DOM: <code>this.href</code>. Обратите, правда, внимание, что <code>this.href</code> несколько отличается: это абсолютный путь, поскольку мы здесь говорим про DOM API, а не сам элемент. Если вы хотите получить значение атрибута (как это работает в случае jQuery), вы можете использовать <code>this.getAttribute('href')</code>.</p>\n<p>Ещё есть сценарий, в котором вы устанавливаете класс для элемента, и здесь вам тоже не нужна jQuery, если вы просто добавите класс. Сколько раз я видел:</p>\n<pre><code>    &#x3C;script src=\"http://code.jquery.com/jquery.min.js\">&#x3C;/script>\n&#x3C;/head>\n&#x3C;body>\n    &#x3C;script>\n        $('body').addClass('hasJS');\n    &#x3C;/script>\n</code></pre>\n<p>Но зачем, когда можно так?</p>\n<pre><code>&#x3C;/head>\n&#x3C;body>\n    &#x3C;script>\n        document.body.className = 'hasJS';\n    &#x3C;/script>\n</code></pre>\n<p>Пожалуй, самое главное различие между этими двумя примерами состоит в том, что мы не подключаем jQuery только затем, чтобы установить класс для <code>&#x3C;body></code>, определяющий доступность JavaScript.</p>\n<p>Если у <code>&#x3C;body></code> уже может быть какой-нибудь класс, то просто припишите новый к строке (jQuery тоже нужно обращаться к свойству <code>className</code>): <code>document.body.className += ' hasJS'</code>.</p>\n<p>Здесь мы начинаем натыкаться на проблемы с именами классов и отслеживанием того, у каких элементов какой класс есть, а какого нет. Но в браузерах есть и такая функциональность.</p>\n<h2>classList — добавляем, удаляем, переключаем</h2>\n<p>Свойство <code>classList</code> из спецификации HTML5 поддерживается всеми последними версиями браузеров (кроме IE9 — но в этом случае я могу использовать полифил).</p>\n<p>Вместо:</p>\n<pre><code>$('body').addClass('hasJS');\n// или\ndocument.body.className += ' hasJS';\n</code></pre>\n<p>Можно написать:</p>\n<pre><code>document.body.classList.add('hasJS');\n</code></pre>\n<p>Красиво, не правда ли? А удалять?</p>\n<pre><code>$('body').removeClass('hasJS');\n// или какое-нибудь безумное регулярное выражение\n</code></pre>\n<p>Или можно сделать так:</p>\n<pre><code>document.body.classList.remove('hasJS');\n</code></pre>\n<p>Но больше впечатляет встроенная поддержка переключения классов:</p>\n<pre><code>document.body.classList.toggle('hasJS');\n// и\ndocument.body.classList.contains('hasJS');\n</code></pre>\n<p>Для добавления нескольких классов нужно добавить их как аргументы через запятую:</p>\n<pre><code>document.body.classList.add('hasJS', 'ready');\n</code></pre>\n<p>Есть, конечно, некоторые проблемы, вроде этой, с пустой строкой:</p>\n<pre><code>document.body.classList.contains('');\n// SyntaxError: DOM Exception 12\n</code></pre>\n<p>Ужасно! Но, с другой стороны, я знаю проблемные места и обхожу их стороной. В принципе, мы выросли, работая с браузерами именно по таким принципам.</p>\n<h2>Хранение данных</h2>\n<p>Хранение произвольных данных в элементах появилось в jQuery в версии 1.2.3, а хранение объектов — в 1.4, то есть уже довольно давно.</p>\n<p>В HTML5 есть встроенное хранение данных внутри элементов, но между jQuery и встроенной поддержкой есть фундаментальная разница: <code>dataset</code> в HTML5 не поддерживает хранение объектов.</p>\n<p>Но если вы храните строки или JSON, тогда встроенная поддержка работает идеально:</p>\n<pre><code>element.dataset.user = JSON.stringify(user);\nelement.dataset.score = score;\n</code></pre>\n<p>К сожалению, встроенной поддержки нет в IE10 (конечно, можно добавить полифил, и все прекрасно заработает — но это нужно принимать во внимание при использовании <code>dataset</code>).</p>\n<h2>Ajax</h2>\n<p>Как я уже говорил, jQuery помогла мне понять Ajax в полной мере. Сейчас Ajax — это довольно просто. Конечно, у меня нет всяких дополнительных опций, но, по большей части я просто выполняю XHR GET или POST-запросы с JSON.</p>\n<pre><code>function request(type, url, opts, callback) {\n    var xhr = new XMLHttpRequest(),\n        fd;\n\n    if (typeof opts === 'function') {\n        callback = opts;\n        opts = null;\n}\n\n    xhr.open(type, url);\n\n    if (type === 'POST' &#x26;&#x26; opts) {\n        fd = new FormData();\n\n        for (var key in opts) {\n            fd.append(key, JSON.stringify(opts[key]));\n    }\n}\n\n    xhr.onload = function () {\n        callback(JSON.parse(xhr.response));\n};\n\n    xhr.send(opts ? fd : null);\n}\n\nvar get = request.bind(this, 'GET');\nvar post = request.bind(this, 'POST');\n</code></pre>\n<p>Коротко и просто. XHR — это совсем не сложно, а сейчас есть и хорошая документация. Понимание того, как XHR на самом деле работает и что с его помощью можно сделать, дает нам больше возможностей.</p>\n<p>Как насчет событий прогресса? Событий, привязанных к прогрессу загрузки? Что насчёт отправки <code>ArrayBuffer</code>? А если нужно разбираться с <a href=\"http://ru.wikipedia.org/wiki/Cross-origin_resource_sharing\">CORS</a> и заголовком <code>xml-requested-with</code>?</p>\n<p>Для этого вам понадобится прямой доступ к объекту XHR (я знаю, что это можно получить и из jQuery), и вам нужно знать, как устроен XHR и что с ним можно делать, потому что такие вещи, как, например, загрузку файлов через перетаскивание сейчас безумно просто реализовать с помощью встроенной функциональности.</p>\n<h2>Наконец-то формы!</h2>\n<p>jQuery-плагин для валидации форм был стабильным плагином с первых дней jQuery, и честно сделал работу с формами намного проще.</p>\n<p>Но вне зависимости от валидации на стороне клиента все равно нужно проводить валидацию на стороне сервера — это необходимо в любом случае, какую бы валидацию вы ни делали.</p>\n<p>Но что, если можно было бы выбросить кучу строк JavaScript и плагинов и валидировать эл. адрес как-то так:</p>\n<pre><code>&#x3C;input type=\"email\">\n</code></pre>\n<p>Хотите сделать его обязательным полем?</p>\n<pre><code>&#x3C;input type=\"email\" required>\n</code></pre>\n<p>Хотите разрешать пользователю вводить только определенные символы?</p>\n<pre><code>&#x3C;input pattern=\"a-z0-9\">\n</code></pre>\n<p>Неплохо. Здесь даже есть поддержка вспомогательных технологий — например, клавиатура на мобильных устройствах адаптируется и будет выводить символы для эл. адреса.</p>\n<p>Так как все эти типы полей при отсутствиии в браузере поддержки просто становятся текстовыми полями, и раз уж вам все равно нужно делать валидацию на сервере, я бы на вашем месте выкинул всю JavaScript-валидацию и заменил ее на встроенную в браузеры валидацию HTML5-форм.</p>\n<h2>jQuery-анимации против CSS-анимаций и JavaScript-анимаций</h2>\n<p>На самом деле это никакое не соревнование. CSS выигрывает. Анимации, для которых используется CSS, вычисляются на видеокарте. В анимациях на JavaScript добавляется еще один уровень расчетов — просто потому, что там есть JavaScript.</p>\n<p>Даже в том случае, когда я пишу код сам, я выберу <code>requestAnimationFrame</code> вместо использования анимаций, основанных на <code>setInterval</code>.</p>\n<p>Джейк Арчибальд подготовил отличные слайды, которые показывают проблему — <code>setInterval</code> не сделает анимацию плавной, и достаточно скоро начнет пропускать кадры:</p>\n<figure>\n    \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; ; max-width: 510px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.09803921568627%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAXAQADAQAAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAHUkfK6Rhn/xAAaEAADAAMBAAAAAAAAAAAAAAAAAQIDERIT/9oACAEBAAEFAlE685HjkTR0Okf/xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8BrKz/xAAXEQADAQAAAAAAAAAAAAAAAAAAAREC/9oACAECAQE/AZkiP//EABgQAAIDAAAAAAAAAAAAAAAAAAAyASAx/9oACAEBAAY/AsFFin//xAAZEAADAAMAAAAAAAAAAAAAAAAAARExYcH/2gAIAQEAAT8hciTXKOBKmNR55P/aAAwDAQACAAMAAAAQWA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/EBP/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAlf//EABwQAAICAgMAAAAAAAAAAAAAAAABEVEhcTFBYf/aAAgBAQABPxBNl4Xg4BXSigwxzC6EVM40abpn/9k=&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\" alt=\"set timeout\" title=\"\" src=\"/static/set-timeout-339a76bf8fed5e9f1d0e4e1217f2340f-3ecdc.jpg\" srcset=\"/static/set-timeout-339a76bf8fed5e9f1d0e4e1217f2340f-5cba7.jpg 163w,\n/static/set-timeout-339a76bf8fed5e9f1d0e4e1217f2340f-cf009.jpg 325w,\n/static/set-timeout-339a76bf8fed5e9f1d0e4e1217f2340f-3ecdc.jpg 510w\" sizes=\"(max-width: 510px) 100vw, 510px\">\n    </span>\n  </span>\n  \n    \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; ; max-width: 510px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.09803921568627%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAdRofKqRhf/EABoQAAMAAwEAAAAAAAAAAAAAAAABAgMREhP/2gAIAQEAAQUCUTrzkeORNHQ6R//EABYRAAMAAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPwGsrP/EABcRAAMBAAAAAAAAAAAAAAAAAAABEQL/2gAIAQIBAT8BmSI//8QAGBAAAgMAAAAAAAAAAAAAAAAAADEBIDL/2gAIAQEABj8CRkUU/8QAGRABAQEAAwAAAAAAAAAAAAAAAQAxEWHB/9oACAEBAAE/IWY3WuR5SQZM52//2gAMAwEAAgADAAAAEJwP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAFh/9oACAEDAQE/EKdH/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERYfD/2gAIAQIBAT8QWoKD/8QAGhABAAIDAQAAAAAAAAAAAAAAAQARIVFxYf/aAAgBAQABPxAaKtHkYZxq0jAc0QJd45ON6Z//2Q==&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\" alt=\"request animation frame\" title=\"\" src=\"/static/request-animation-frame-baddf361410b4c8155d5b69297ad2890-3ecdc.jpg\" srcset=\"/static/request-animation-frame-baddf361410b4c8155d5b69297ad2890-5cba7.jpg 163w,\n/static/request-animation-frame-baddf361410b4c8155d5b69297ad2890-cf009.jpg 325w,\n/static/request-animation-frame-baddf361410b4c8155d5b69297ad2890-3ecdc.jpg 510w\" sizes=\"(max-width: 510px) 100vw, 510px\">\n    </span>\n  </span>\n  \n</figure>\n<p>Кроме того, CSS-анимации проходят через тот же таймер, что и <code>requestAnimationFrame</code> — его мы и хотим использовать.</p>\n<p>Так что, если ваш браузер это позволяет, используйте CSS-анимации. Конечно, это посложнее, чем <code>$foo.animate('slow', { x: '+=10px' })</code>, но зато анимация будет чище и плавнее. Стоит знать, что трогать DOM — дорогая операция. Если вы анимируете положение элемента по оси абсцисс, обновляя атрибут <code>el.style.left</code>, вы постоянно читаете и пишете в DOM.</p>\n<p>А вот если вы просто сделаете <code>foo.classList.add('animate')</code>, анимация CSS-класса выполнит плавный переход положения левой точки элемента. И если вы точно знаете, что это только значение слева, можно использовать аппаратное ускорение, выполнив <code>translateX</code> с <code>translateZ(0)</code>.</p>\n<p>Ну а как же, слышу я ваш крик, как же вызов функции после окончания анимации? Это тоже можно. Хотя синтаксис немножко противный:</p>\n<pre><code>el.addEventListener(\"webkitTransitionEnd\", transitionEnded);\nel.addEventListener(\"transitionend\", transitionEnded);\n</code></pre>\n<p>Обратите внимание, что <code>e</code> в <code>end</code> строчная…</p>\n<p>Пара милых людей в Твиттере показали мне <a href=\"https://github.com/benbarnett/jQuery-Animate-Enhanced\">своего рода полифил для jQuery</a>, который дополняет функцию <code>.animate</code> в том случае, если в браузере доступны CSS-анимации.</p>\n<p>Еще есть отдельный плагин <a href=\"http://ricostacruz.com/jquery.transit/\">Transit</a>, который дает вам возможность писать CSS-анимации на JavaScript. Приятный момент для меня — поддержка чейнинга. Но так он работает только с CSS-анимациями, для этого требуется IE10 или выше.</p>\n<p>Отсюда у меня возникает вопрос: почему этот плагин в обязательном порядке требует jQuery?</p>\n<h2>В сторону: jQuery-плагины — просто так</h2>\n<p>Я:</p>\n<blockquote>\n<p>Не знаю почему, но мне очень хочется больно ударить людей, которые пишут такие jQuery-плагины, для которых на самом деле jQuery совершенно не нужна. /требуется-контроль-эмоций</p>\n</blockquote>\n<p>Ответ:</p>\n<blockquote>\n<p>@rem У меня то же самое. Я думаю, где-то есть группа, в которой с этим помогают, — и, полагаю, довольно большая.</p>\n</blockquote>\n<p>Я недавно работал над проектом и узнал о <a href=\"http://fittextjs.com\">fitText.js</a>. Я решил включить его в свой код, но потом заметил, что для него <strong>требуется</strong> jQuery.</p>\n<p>Хм-м. Зачем?</p>\n<p>Этот проект использует следующие методы jQuery:</p>\n<ol>\n<li><code>.extend</code></li>\n<li><code>.each</code></li>\n<li><code>.width</code></li>\n<li><code>.css</code></li>\n<li><code>.on</code> (над производительностью никто особенно не задумывался)</li>\n</ol>\n<p>Собственно, вот код проекта:</p>\n<pre><code>$.fn.fitText = function( kompressor, options ) {\n\n    // Настраиваем\n    var compressor = kompressor || 1,\n        settings = $.extend({\n            'minFontSize' : Number.NEGATIVE_INFINITY,\n            'maxFontSize' : Number.POSITIVE_INFINITY\n    }, options);\n\n    return this.each(function(){\n\n        // Сохраняем объект\n        var $this = $(this);\n\n        // Функция Resizer() изменяет размеры объекта\n        // на основе его ширины, поделённой на compressor * 10\n        var resizer = function () {\n            $this.css('font-size', Math.max(\n                Math.min($this.width() / (compressor*10),\n                parseFloat(settings.maxFontSize)\n            ),\n            parseFloat(settings.minFontSize)));\n    };\n\n        // Вызываем для установки\n        resizer();\n\n        // Вызываем при ресайзе. Opera кеширует вызовы по умолчанию\n        $(window).on('resize orientationchange', resizer);\n});\n};\n</code></pre>\n<p><code>.extend</code> используется на объекте, в котором всего две опции, так что я бы переписал его так:</p>\n<pre><code>if (options === undefined) options = {};\nif (options.minFontSize === undefined) options.minFontSize = Number.NEGATIVE_INFINITY;\nif (options.maxFontSize === undefined) options.maxFontSize = Number.POSITIVE_INFINITY;\n</code></pre>\n<p><code>return this.each</code> используется для того, чтобы итерироваться по элементам. Предположим, что мы хотим, чтобы этот код работал без jQuery: тогда наша функция <code>fitText</code> получит список элементов (так как чейнинга мы делать не будем):</p>\n<pre><code>var length = nodes.length,\n    i = 0;\n\n// Хотелось бы использовать [].forEach.call, но нет поддержки в IE8\nfor (; i &#x3C; length; i++) {\n    (function (node) {\n        // там, где использовался `this`, теперь `node`\n        // …\n    })(nodes[i]);\n}\n</code></pre>\n<p><code>$this.width()</code> получает ширину контейнера, чтобы изменять размер текста. Для этого нам нужно получить рассчитанные стили и взять из них значение ширины:</p>\n<pre><code>// Функция Resizer() изменяет размеры объекта\n// на основе его ширины, поделённой на compressor * 10\nvar resizer = function () {\n    var width = node.clientWidth;\n    // …\n};\n</code></pre>\n<p><code>$this.css</code> используется для установки значений, так что тут всего лишь нужно задать стили:</p>\n<pre><code>node.style.fontSize = Math.max(…);\n</code></pre>\n<p><code>$(window).on('resize', resizer)</code> прикрепляет обработчик события (если вы хотите поддержку в IE8, то нужно еще включить <code>addEvent</code>):</p>\n<pre><code>window.addEventListener('resize', resizer, false);\n</code></pre>\n<p>На самом деле, я бы пошел еще дальше и хранил бы функции ресайза в массиве, и во время операции изменения размера проходил бы по массиву, исполняя все эти функции.</p>\n<p>Конечно, тут нужно немножко больше работы, но при этом такие изменения довольно легко провести так, чтобы работа в качестве jQuery-плагина была бы для этого проекта дополнительной функциональностью, а не требованием.</p>\n<p>Моя тирада скоро закончится: еще меня убивает, когда я вижу полифил, которому требуется jQuery — но я признаю и контраргумент: чрезвычайная распространенность jQuery, наверное, может оправдать то, что столько проектов пишется с зависимостью от нее.</p>\n<h2>Заключение</h2>\n<p>Моей целью было показать вам, что, хотя jQuery безумно помогала мне все эти годы (особенно годы плохой совместимости между браузерами), и со встроенной функциональностью браузеров можно уйти довольно далеко в плане обычных сценариев, — когда я пишу JavaScript для того, чтобы «сделать что-нибудь» в DOM.</p>\n<p>Перестаньте думать в парадигме «функция X не работает в браузере Y». Подходите с другой точки зрения. Какую задачу я решаю? Какой инструмент лучше всего подойдет? Для кого это делается? Я по-прежнему верю в методологию прогрессивного улучшения, но я не понимаю удовольствия лезть из кожи вон ради того, чтобы поддерживать воображаемую аудиторию пользователей (по той причине, что у нас нет данных, какие браузеры у наших пользователей).</p>\n<p>Google (по моим последним данным) поддерживает последние и предпоследние версии браузеров. Я тоже стараюсь начинать с поддержки этих версий.</p>\n<p>Я буду продолжать использовать jQuery так, как мне удобно, и я продолжу убеждать своих читателей и слушателей, что фронтенд-разработчики должны знать, что могут браузеры, с которыми они работают.</p>\n<p>Итак, на этом я заканчиваю и надеюсь, что этот текст был вам полезен.</p>\n<p>Возможно, некоторые из вас уже знали всё это (правда, в таком случае у меня возникает вопрос, зачем вы это читаете), однако я надеюсь, что хоть кому-то я показал, что за пределами jQuery есть еще целый мир, и вы можете начать осваивать его прямо сейчас в одном из своих проектов.</p>\n<p>Может быть, некоторые из вас только знакомятся с jQuery — я надеюсь, что вы станете разбираться и дальше в том, на что способны JavaScript и DOM.</p>\n<p>Однако большинству из вас я принёс снег зимой. Вы уже согласны со мной. Вы уже верите в стандарты, делаете все правильно, учитесь и образовываетесь. Но вы должны помочь людям, которые не получают этой информации.</p>\n<p>Вам нужно делиться своими ощущениям с другими людьми. Теперь вы — эксперты, и вы должны помочь окружающим достигнуть вашего уровня и превзойти его.</p>\n<p>На конференциях будут нужны новые докладчики и новые эксперты: это вы.</p>\n<h2>Материалы к статье</h2>\n<ul>\n<li><a href=\"https://speakerdeck.com/rem/i-know-jquery-now-what\">Слайды презентации</a></li>\n<li><a href=\"http://vimeo.com/68009123\">Видео доклада</a></li>\n<li><a href=\"http://vimeo.com/68910118#t=2380\">Секция вопросов и ответов с конференции Mobilism</a></li>\n<li><a href=\"https://github.com/remy/min.js\">Библиотека min.js</a></li>\n</ul>\n<p>Перевод оригинальной записи «<a href=\"http://remysharp.com/2013/04/19/i-know-jquery-now-what/\">I know jQuery. Now what?</a>» Реми Шарпа (Remy Sharp), опубликованной на сайте <a href=\"http://remysharp.com\">remy sharp’s b:log</a>. Переведено и опубликовано с разрешения автора.</p>\n<p>Перевод <a href=\"http://www.facebook.com/vlad.andersen\">Влада Андерсена</a>, редактура <a href=\"http://pepelsbey.net\">Вадима Макеева</a> и <a href=\"http://engel-t.moikrug.ru\">Ольги Алексашенко</a>.</p>","frontmatter":{"title":"Я знаю jQuery. И что?","date":"16 декабря 2013"}}},"pageContext":{"slug":"/articles/jquery-now-what/"}}