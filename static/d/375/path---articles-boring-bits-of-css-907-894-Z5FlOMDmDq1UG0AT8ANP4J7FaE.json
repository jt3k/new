{"data":{"site":{"siteMetadata":{"title":"Веб-стандарты"}},"markdownRemark":{"id":"8c48da8a-58c5-52fa-ba7c-297a22317022","excerpt":"Как я научился любить скучные мелочи CSS Питер Гастон  21 августа 2012 В будущем CSS есть много того, чего нам стоит ожидать с нетерпением…","html":"<h1>Как я научился любить скучные мелочи CSS</h1>\n<p><a href=\"http://www.broken-links.com\">Питер Гастон</a> 21 августа 2012</p>\n<p>В будущем CSS есть много того, чего нам стоит ожидать с нетерпением: с одной стороны, там будет целый спектр новых методов, которые произведут революцию в вёрстке; с другой стороны — новый набор графических эффектов, которые позволят создавать на лету фильтры и шейдеры. Людям всё это страшно нравится, в журналах и блогах пишется огромное количество статей об этих нововведениях.</p>\n<p>Но если эти инструменты можно назвать выставочными лошадками CSS, тогда, думается мне, стоит обратить немного внимания и на рабочих лошадей: на те компоненты языка, которые являются его составными частями: селекторы, единицы измерения, функции. Я частенько называю их «скучными мелочами» — хотя на самом деле я это говорю с большой теплотой, и вам стоит, мне кажется, разделить моё доброе к ним отношение.</p>\n<p>Почему? Давайте пробежимся по парочке лучших нововведений в CSS из разряда скучных мелочей — тех мелочей, над которыми работали в плохо освещенных лабораториях, вдали от блеска новых глянцевых штучек на витринах. Некоторые из этих мелочей уже какое-то время с нами, но заслуживают того, чтобы больше людей о них знали; другие, напротив, только начинают появляться в браузерах. Но тем не менее они произведут революцию в том, как мы работаем — причем тихо, скромно и без претензий.</p>\n<h2>Относительные единицы измерения</h2>\n<p>Скорее всего, вы, умный и предусмотрительный веб-разработчик, работаете с относительными единицами измерения — то есть с <code>em</code> или процентами — так что эта проблема вам должна быть знакома: вам наверняка приходится сидеть за калькулятором, чтобы вычислить размеры — из-за наследования. Например, сейчас вполне обычный прием — установить базовый размер шрифта для документа, а потом использовать относительные единицы, чтобы установить размер шрифта для всех остальных элементов на странице. В CSS это выглядит примерно так:</p>\n<pre><code>html { font-size: 10px; }\np { font-size: 1.4em; }\n</code></pre>\n<p>Здесь всё отлично, и никакой проблемы нет, пока у вас не появляется дочерний элемент, которому вы хотите установить какой-нибудь другой размер шрифта. Например, в такой разметке:</p>\n<pre><code>А и Б сидели на &#x3C;span>трубе&#x3C;/span>.\n</code></pre>\n<p>Если вы хотите, чтобы этот <code>&#x3C;span></code> было меньшего размера шрифта, например, <code>1.2em</code>, то что вам делать? Берите калькулятор и считайте, сколько будет 1,2 поделить на 1,4, и в итоге у вас получится:</p>\n<pre><code>p span { font-size: 0.85714em; }\n</code></pre>\n<p>И проблема не ограничивается использованием <code>em</code>. Если вы разрабатываете тянущийся сайт с использованием ширин в процентах, то знаете, что эти проценты соотносятся с размерами контейнера элемента, так что если у вас есть элемент, которому вы хотите поставить ширину в 40% от его родительского элемента, ширина которого — 75%, тогда придется устанавливать ширину этого элемента в 53,33333%.</p>\n<p>Мягко говоря, не идеально.</p>\n<h2>Размеры относительно корневого элемента</h2>\n<p>Чтобы побороть эту проблему с размерами шрифтов, теперь нам доступна новая единица измерения — <code>rem</code> (корневой <code>em</code>). Это всё ещё относительная единица измерения, но она всегда соотносится с фиксированным базовым значением, а именно — с размером шрифта корневого элемента документа (в случае HTML это всегда элемент <code>&#x3C;html></code>). Если предположить, что мы используем тот же самый размер шрифта для корневого элемента, что и в прошлый раз (<code>10px</code>), то нам потребуются для этого случая следующие CSS-правила:</p>\n<pre><code>p { font-size: 1.4rem; }\np span { font-size: 1.2rem; }\n</code></pre>\n<p>Теперь оба правила соотносятся с размером шрифта корневого элемента — это куда более элегантно, да и работать с этим удобнее, особенно если у вас простое базовое значение, например, <code>10px</code> или <code>12px</code>. Это как если вернуться назад и использовать значения в пикселях, только с возможностью их масштабировать.</p>\n<p>Это одна из функций, перечисленных в этой статье, которая поддерживается браузерами очень хорошо: все современные браузеры, включая IE9, поддерживают эту единицу, <a href=\"http://caniuse.com/#feat=rem\">нет её пока только в Opera Mobile</a>.</p>\n<h2>Размеры относительно вьюпорта</h2>\n<p>Если вам кажется, что единица <code>rem</code> — крутая (а я так думаю!), то вы будете в восторге от того, что узнаете, что существует ещё и новый набор единиц измерения, который поможет победить проблему с процентами. Эти единицы работают примерно так же, как <code>rem</code>, за исключением того, что они соотносятся не с установленным пользователем значением на корневом элементе документа, а с самим вьюпортом, или областью просмотра устройства.</p>\n<p>Две базовых единицы здесь — <code>vh</code> и <code>vw</code>; они соотносятся (соответственно) с высотой и шириной вьюпорта. Каждая единица является числом, и это число равняется соответствующему проценту от указанного измерения (ширины или высоты). Пока я ещё помню уроки в школе сценаристов, давайте я лучше не буду объяснять, а покажу:</p>\n<pre><code>div { height: 50vh; }\n</code></pre>\n<p>В этом примере высота блока будет равна точно половине высоты вьюпорта; <code>1vh</code> — это 1% от высоты вьюпорта, так что равенство <code>50vh</code> = 50% от этой высоты выглядит вполне логичным.</p>\n<p>Если размер окна просмотра изменяется, то изменяется и значение соответствующих единиц, и при этом вам не нужно беспокоиться о вложенных элементах: элемент с шириной <code>10vw</code> всегда будет этой ширины, вне зависимости от ширины его родительского элемента.</p>\n<p>Также есть единица <code>vmin</code>, которая соответствует меньшему значению — <code>vh</code> или <code>vw</code>; кроме того, недавно стало известно, что в спецификацию добавится и соответствующая единица <code>vmax</code> (хотя на момент написания статьи этого пока не случилось).</p>\n<p>Сейчас эти единицы поддерживаются в IE9+, Chrome и Safari 6.</p>\n<h2>Рассчитываемые значения</h2>\n<p>Если вы будете работать с тянущимся или адаптивным дизайном, вы, без сомнения, столкнетесь с проблемой смешивания единиц измерения — когда вы хотите, чтобы у вас на странице была сетка, ширина у которой задается в процентах, но при этом с фиксированными полями. Например:</p>\n<pre><code>div {\n    margin: 0 20px;\n    width: 33%; \n}\n</code></pre>\n<p>Если в вашей верстке указаны только <code>padding</code> и <code>border</code>, тогда, в приницпе, можно решить проблему с помощью <code>box-sizing</code>, но с <code>margin</code> это не поможет. Есть лучший и более гибкий подход — использовать для значения функцию <code>calc()</code>, которая позволяет вам производить математические действия с разными единицами, скажем:</p>\n<pre><code>div {\n    margin: 0 20px;\n    width: calc(33% - 40px);\n}\n</code></pre>\n<p>Вы можете применяться её где угодно, не только для ширин, но и везде, где вам нужны единицы изменения. А если вы хотите зайти совсем далеко, то вы тоже можете даже использовать <code>calc()</code> внутри <code>calc()</code>.</p>\n<p>В IE9+ эта функция поддерживается без префикса(!), в Firefox — с префиксом <code>-moz-</code> (в релизе 16 или 17 он должен быть отброшен), а в Chrome и Safari — с префиксом <code>-webkit-</code>. <a href=\"http://caniuse.com/#feat=calc\">В мобильный Webkit он, увы, пока не включен.</a></p>\n<h2>Загрузка подмножества символов</h2>\n<p>Быстрая загрузка веб-страниц всегда была важна — но сейчас, с появлением на рынке широкого спектра мобильных устройств (с каждым из которых понятие «скорость соединения» становится всё более изменчивым и неопределенным) это, пожалуй, особенно важно. Один из способов ускорить загрузку страницы — сократить размер внешних подгружаемых файлов, и поэтому новое свойство внутри <code>@font-face</code>, которое позволяет делать именно это, — весьма полезное добавление.</p>\n<p>Свойство, о котором идет речь — <code>unicode-range</code>, и в качестве значения оно принимает набор ссылок на юникод-символы. При загрузке внешних ресурсов из файла шрифта будут загружаться только эти символы, а не все символы, присутствующие в шрифте. Приведенный код показывает, как загрузить только три символа из файла foo.ttf:</p>\n<pre><code>@font-face {\n    font-family: foo;\n    src: url('foo.ttf');\n    unicode-range: U+31-33;\n}\n</code></pre>\n<p>Особенно это полезно в том случае, если вы используете <a href=\"http://net.tutsplus.com/tutorials/html-css-techniques/quick-tip-ever-thought-about-using-font-face-for-icons/\">иконки внутри шрифта</a> и хотите показывать на конкретной странице не все из них, а только конкретные. В одном тесте, который я провел, использование <code>unicode-range</code> сократило общее время загрузки файла шрифта в среднем на 0,85 секунды — а это вполне существенно. Конечно, у вас могут получиться и другие цифры.</p>\n<p>Это свойство на данный момент поддерживается в IE9+ и браузерах на движке Webkit: Chrome и Safari.</p>\n<h2>Новые псевдоклассы</h2>\n<p>Единицы измерения и значения — это всё прекрасно, но особенно меня радуют селекторы и псевдоклассы. Когда у меня получается выдумать замысловатый селектор, даже если он в итоге будет запрятан там, где только немногие избранные смогут его найти, я всегда чувствовую себя мастером своего дела. <a href=\"http://hbr.org/2012/04/the-real-leadership-lessons-of-steve-jobs/\">Перифразируя отца Стива Джобса</a>: ты должен сделать так, чтобы забор со стороны твоего дома выглядел так же хорошо, как со стороны улицы, даже если больше никто не будет знать, что это так — ведь ты будешь.</p>\n<p>Для меня стало откровением, когда я впервые использовал <code>:nth-of-type()</code>, это было словно я вышиб ногой двери восприятия... Окей, я чуть-чуть преувеличиваю. Но есть несколько новых CSS-псевдоклассов, относительно которых действительно стоит испытывать энтузиазм.</p>\n<h2>Псевдокласс отрицания</h2>\n<p>Вы наверняка не поймете, насколько в действительности полезен новый (относительно) псевдокласс отрицания <code>:not()</code>, пока сами его не попробуете. В качестве аргумента <code>:not()</code> передается простой, а не составной селектор. Когда список элементов создается селектором, включающим <code>:not()</code>, все элементы, которые соответствуют аргументу, исключаются из этого списка. Знаю, звучит сложно, мне тоже так кажется. Но на самом деле всё довольно просто.</p>\n<p>Представьте себе: у вас есть список, и вы хотите применить правило ко всем нечётным элементам в списке, но не к последнему. Вам придётся написать что-то вроде такого:</p>\n<pre><code>li { color: #00F; }\nli:nth-child(odd) { color: #F00; }\nli:last-child { color: #00F; }\n</code></pre>\n<p>С псевдоклассом отрицания вы можете исключить последний элемент из списка, используя в качестве аргумента <code>:last-child</code>. Таким образом количество правил уменьшится, и с кодом станет легче работать:</p>\n<pre><code>li { color: #00F; }\nli:nth-child(odd):not(:last-child) { color: #F00; }\n</code></pre>\n<p>Ничего принципиально нового здесь нет, и, как я показал, вполне можно работать и без него, но — это довольно-таки полезно. У меня была возможность применить этот псевдокласс в проекте, где использовался встроенный Webkit, и я раз за разом убеждался в его пользе. Честно, это один из моих любимых псевдоклассов.</p>\n<p>Всё верно, у меня есть любимые псевдоклассы.</p>\n<p>Из всех функций, рассмотренных в этой статье, это самая широко поддерживамая; её поддерживают IE9+ и все современные браузеры — без префикса. Если вы работаете с jQuery, вполне возможно, что вы уже привыкли использовать этот синтаксис — в jQuery он есть начиная с версии 1.0, как и метод <code>not()</code>, который делает то же самое.</p>\n<h2>Псевдокласс соответствия</h2>\n<p>Псевдокласс соответствия <code>:matches()</code> принимает в качестве аргумента простой селектор, составной селектор, список, разделенный запятой, или любую комбинацию этих пунктов. Отлично! Но что же он делает?</p>\n<p>Лучше всего он подходит для того, чтобы срезать лишнее с повторяющихся селекторов. В качестве сценария использования представьте себе, что у вас есть несколько элементов <code>&#x3C;p></code> в разных контейнерах, но вы хотите выбрать только некоторые из них; тогда правило в стилях будет выглядеть примерно так:</p>\n<pre><code>.home header p,\n.home footer p,\n.home aside p {\n    color: #F00;\n}\n</code></pre>\n<p>С селектором <code>:matches()</code> вы можете значительно сократить его, найдя сходство в селекторах; в нашем примере у нас везде в начале стоит <code>.home</code>, а конце — <code>p</code>, так что мы можем использовать <code>:matches()</code> для того чтобы собрать все элементы между ними. Непонятно? Это выглядит вот так:</p>\n<pre><code>.home :matches(header,footer,aside) p { color: #F00; }\n</code></pre>\n<p>В действительности это уже часть CSS4 (если быть совсем точными, спецификации CSS-селекторов уровня 4), и ещё в этой спецификации сказано, что вы сможете использовать такой же синтаксис — составные селекторы, разделенные запятой — в будущих версиях <code>:not()</code>. Здорово-то как!</p>\n<p>На сегодняшний день <code>:matches()</code> есть в Chrome и Safari с префиксом <code>-webkit-</code>, а в Firefox он проходит под своим старым названием, <code>:any()</code>, с префиксом <code>-moz-</code>.</p>\n<h2>Ну как, уже полюбили рабочих лошадок?</h2>\n<p>Самое лучшее во всех этих новых возможностях — они решают совершенно реальные проблемы, от маленького, но раздражающего повторения селекторов до новых и появляющихся в настоящее время сложных задач, связанных с разработкой высокопроизводительных адаптивных сайтов. На самом деле, я могу легко представить, что регулярно использую каждое из этих нововведений.</p>\n<p>Может быть, про новые возможности вроде фильтров больше пишут, но вы с гораздо большей вероятностью обнаружите, что именно те мелочи, которые представлены в этой статье, будут вам полезны в разработке.</p>\n<p>Каждая из них сделает вашу профессиональную жизнь немножко проще, и в то же время расширит пространство ваших возможностей — а в этом ничего скучного, поверьте, нет.</p>\n<p>Перевод оригинальной записи «<a href=\"http://www.alistapart.com/articles/love-the-boring-bits-of-css/\">Learning to Love the Boring Bits of CSS</a>» Питера Гастона (Peter Gasston), опубликованной на сайте <a href=\"http://www.alistapart.com\">A List Apart</a>. Переведено и опубликовано с разрешения автора.</p>\n<p>Перевод выполнил <a href=\"http://www.facebook.com/vlad.andersen\">Влад Андерсен</a>.</p>","frontmatter":{"title":"Как я научился любить скучные мелочи CSS","date":"21 августа 2012"}}},"pageContext":{"slug":"/articles/boring-bits-of-css/"}}