<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/869/path---articles-css-nuances-83-a-d42-kRm65xO6yCVagHmRBPsh9FMkNM.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Нюансы CSS</h1><div class="article__date">21 апреля 2011</div><div class="article__content"><h1>Нюансы CSS</h1>
<p><a href="http://my.opera.com/GreLI/blog/">Лев Солнцев</a> 21 апреля 2011</p>
<p>Многие используют CSS для оформления сайтов и веб-страниц, знают основные приёмы вёрстки, а если и нет, то быстро найдут решение в интернете, или им подскажут в тематических сообществах. Тем не менее многие широко используемые решения не оптимальны, и если ознакомиться со спецификациями чуть глубже, можно написать лучший код.</p>
<p>К примеру многие знают, что цвет в шестнадцатеричной нотации вида <code>#RRGGBB</code> можно писать сокращённо как <code>#RGB</code>, если каждый старший разряд совпадает с младшим, или что нуль можно писать без единиц измерения, таких как «px» или «em», так как нуль — в любой системе измерения нуль.</p>
<h2>Что считает браузер</h2>
<p>Также широко известно, что можно отцентрировать блок с шириной меньше родительского элемента при помощи <code>margin:0 auto</code>. Однако мало кто задумывается, что почти во всех случаях дело касается непозиционированных элементов, и в этом случае значение <code>margin-top:auto</code> или <code>margin-bottom:auto</code> устанавливается равным нулю, а значит данное правило можно сократить до простого <code>margin:auto</code>.</p>
<p>Правила <code>margin-left:auto</code> и <code>margin-right:auto</code> при ширине блока меньше ширины контейнера равномерно распределяют оставшееся место. Так, задав только <code>margin-left:auto</code>, можно выровнять элемент по правому краю.</p>
<p>В обычном потоке элементы идут сверху вниз, поэтому <code>margin-top:auto</code> устанавливается нулевым. Однако для абсолютно спозиционированных элементов действует то же распределение свободного места, и аналогичным образом можно сделать <a href="http://test.csswg.org/suites/css2.1/20110111/html4/absolute-non-replaced-height-003.htm">центрирование по вертикали</a> при заданных высоте и <code>top</code> с <code>bottom</code> (не работает в IE7).</p>
<h2>Сокращения и значения по умолчанию</h2>
<p>Не менее широко распространено использование спрайтов, например: <code>background:url(icons.png) 0 0 no-repeat</code>. Однако, <code>background-position:0 0</code> является значением по умолчанию, поэтому <code>0 0</code> в таком случае можно опустить.</p>
<p>Но если в <code>background-position</code> задана хоть одна координата: будь то <code>top</code>, <code>left</code> или <code>100%</code>, то вторая принимает значение 50%. Это может быть полезно для значков, выровненных посередине строки по вертикали — достаточно указать лишь положение слева или справа.</p>
<p>Не все знают, что опущенные в сокращённой записи правила принимают своё значение по умолчанию. Поэтому уточняющие правила надо писать после или делать сильнее общей сокращённой надписи, как <code>background-position</code> уточняет положение каждого спрайта после <code>background</code> в предыдущем примере.</p>
<p>При подобном написании:</p>
<pre><code>h1 {
    font: 2em/1 Arial,sans-serif;
}
</code></pre>
<p>задаётся не только шрифт, его размер и интерлиньяж, но и сразу сбрасывается полужирное написание (<code>font-weight:normal</code>), а также другие свойства, такие как <code>font-style</code> (курсив) и <code>font-variant</code> (капитель). Некоторые авторы совершенно зря дописывают в <code>font</code> значение <code>normal</code>. Непонятно даже к какому правилу из перечисленных трёх оно могло бы относиться — порядок следования в сокращённых свойствах неважен, и неучитывание порядка могло приводить к ошибкам лишь в устаревших браузерах.</p>
<p>Другими недопонятыми, но тоже полезными сокращёнными записями являются отдельные правила рамок <code>border-width</code>, <code>border-style</code> и <code>border-color</code>. Например, благодаря им можно задать верхнюю и нижнюю одинаковые рамки не дублированием кода в <code>border-top</code> и в <code>border-bottom</code>, а подобным образом:</p>
<pre><code>border: solid gray;
border-width: 3px 0;
</code></pre>
<p>Кроме меньшего размера кода, такая запись полезна тем, что каждое значение написано только один раз, и поменять, скажем, <code>solid</code> на <code>double</code> не составляет труда.</p>
<p>Более того, если будет использоваться <code>border-image</code>, то здесь явно задано, что размер боковых рамок нулевой. В противном случае <code>border-image</code> приводит к неявному появлению рамок, что может дать неожиданный эффект в углах.</p>
<p>Есть возможность, что <code>border-radius</code> может быть включен в сокращённую запись <code>border</code> (предлагался вариант с косой чертой «/»), поэтому записывайте на всякий случай <code>border-radius</code> после <code>border</code>.</p>
<h2>Переусложенение</h2>
<p>Часто, чтобы избавиться от рамки на картинке внутри ссылки, пишут:</p>
<pre><code>a img {
    border: 0;
}
</code></pre>
<p>Однако в таком случае бразуер будет на каждой картинке проверять, не находится ли она в ссылке. Если для простых страниц это кажется несущественным (вы и глазом моргнуть не успеете за те несколько миллисекунд, на которое задержится отображение страницы), то в какой-нибудь фотогалерее со сложной анимацией это может лишить вас нескольких кадров в секунду, прибавляя ощущения «тормознутости». Куда проще написать так:</p>
<pre><code>img {
    border: 0;
}
</code></pre>
<p>Эффект будет тот же самый. Уточнение, что рамка появляется на ссылках <code>a</code> в данном случае совершенно излишне.</p>
<p>Из тех же соображений производительности, как правило, незачем писать имя тэга вместе с классом и уж тем более с идентификатором, который сам по себе уникален. В данном правиле могут быть только два исключения: уточнение для конкретного тэга (возможно в этом случае у вас очень общий класс), и обход недостатка IE7, где эффекты при наведении <code>:hover</code> тормозят, если в селекторе не указан тэг (то есть надо писать <code>a.class:hover { color:#FC0; }</code>).</p>
<h2>Наследование</h2>
<p>Ещё одна недооценённая многими возможность CSS: наследование стилей. Например, может не устраивать, что по умолчанию содержимое ячеек таблиц центрируется по вертикали, при этом используются следующие правила:</p>
<pre><code>th {
    vertical-align: bottom;
}
td {
    vertical-align: top;
}
</code></pre>
<p>Вроде бы всё здорово, но, сделав так, вы лишаетесь простого способа переопределить выравнивание для целого ряда:</p>
<pre><code>tr.images {
    vertical-align: middle;
}
</code></pre>
<p>Этого можно избежать, воспользовавшись тем, что ячейки таблицы <code>th</code> и <code>td</code> наследуют правила от рядов <code>tr</code>, а те в свою очередь от блоков <code>thead</code>, <code>tfoot</code> и <code>tbody</code>.</p>
<pre><code>thead {
    vertical-align: bottom;
}
tbody,
tfoot {
    vertical-align: top;
}
</code></pre>
<p>Стоит отметить, что все браузеры, кроме IE8, наследуют еще и значение <code>text-align</code> для <code>th</code>, а сам IE8 понимет ключевое слово <code>inherit</code>, что также позволяет наследовать значение <code>text-align</code>.</p>
<h2>Заключение</h2>
<p>Знание основ спецификаций, понимание механизмов работы браузеров и выполняемых действий позволяет оптимизировать написание кода, упростить его, сделать лаконичней, а также упростить дальшейшую разработку и поддержку.</p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-css-nuances-83a","path":"/articles/css-nuances/"};window.dataPath="869/path---articles-css-nuances-83-a-d42-kRm65xO6yCVagHmRBPsh9FMkNM";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>