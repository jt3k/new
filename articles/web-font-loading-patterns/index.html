<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/517/path---articles-web-font-loading-patterns-986-137-avzAl0iCaFNz9QVODPxhAoKgjA.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Паттерны загрузки веб-шрифтов</h1><div class="article__date">14 июня 2016</div><div class="article__content"><h1>Паттерны загрузки веб-шрифтов</h1>
<p><a href="https://www.bramstein.com/">Брэм Штайн</a> 14 июня 2016</p>
<p><em>Загрузка веб-шрифтов может показаться сложной задачей. Однако, на самом деле, она довольно проста, если вы будете использовать описанные ниже паттерны. Комбинируя их, вы сможете управлять загрузкой веб-шрифтов во всех браузерах.</em></p>
<p>В этих паттернах используется <a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a>, простая и небольшая библиотека загрузки веб-шрифтов. Font Face Observer выбирает наиболее эффективный способ загрузки шрифта, основываясь на его браузерной поддержке, так что мы можем загружать шрифты, не беспокоясь о кроссбраузерности.</p>
<ol>
<li><a href="#part-1">Обычная загрузка шрифтов</a></li>
<li><a href="#part-2">Загрузка группы шрифтов</a></li>
<li><a href="#part-3">Загрузка шрифтов с таймером</a></li>
<li><a href="#part-4">Приоритетная загрузка</a></li>
<li><a href="#part-5">Особое отображение шрифтов</a></li>
<li><a href="#part-6">Оптимизация для кэширования</a></li>
</ol>
<p>Невозможно посоветовать единый паттерн, который идеально подходил бы каждому. Внимательно изучите свой сайт, его аудиторию, и на основании этого выберите тот способ загрузки или их комбинацию, которые подойдут лучше всего.</p>
<h2>Обычная загрузка шрифтов</h2>
<p>Font Face Observer даёт вам возможность контролировать загрузку веб-шрифтов через простой интерфейс, основанный на промисах. Не имеет значения, откуда будут загружаться шрифты: вы можете размещать их как у себя, так и подключать через сервисы — <a href="https://www.google.com/fonts">Google Fonts</a>, <a href="https://typekit.com/">Typekit</a>, <a href="https://fonts.com/">Fonts.com</a>, и <a href="http://www.webtype.com/">Webtype</a>.</p>
<p>Чтобы не перегружать паттерны лишним кодом, будем считать, что вы размещаете веб-шрифты у себя. Это означает, что в ваших CSS-файлах будет одно или несколько объявлений <code>@font-face</code>, в которых указано, какие шрифты нужно загрузить через Font Face Observer. Для краткости мы не будем объявлять каждое из подобных правил в коде, но будем считать, что они есть.</p>
<pre><code>@font-face {
    font-family: Output Sans;
    src: url(output-sans.woff2) format('woff2'),
         url(output-sans.woff) format('woff');
}
</code></pre>
<p>Рассмотрим самую обычную задачу: вам надо загрузить один или несколько разных шрифтов. Создайте несколько экземпляров <code>FontFaceObserver</code>, по одному на каждый шрифт, и вызовите их метод <code>load</code>.</p>
<pre><code>var output = new FontFaceObserver('Output Sans');
var input = new FontFaceObserver('Input Mono');

output.load().then(function () {
    console.log('Загружен Output Sans');
});

input.load().then(function () {
    console.log('Загружен Input Mono');
});
</code></pre>
<p>Этот способ загрузит каждый шрифт независимо от остальных. Это полезно, когда шрифты не связаны друг с другом, и мы ожидаем, что они отрисуются постепенно (т.е. как только загрузятся, так и отрисуются). В отличие от стандартного <a href="https://www.w3.org/TR/css-font-loading/">API загрузки шрифтов</a> вы не передаёте URL шрифтов в Font Face Observer. Для загрузки шрифтов он использует объявления <code>@font-face</code>, уже доступные в CSS. Это позволяет загружать веб-шрифты вручную через JavaScript, предусмотрев постепенную деградацию к обычному CSS.</p>
<h2>Загрузка групп шрифтов</h2>
<p>Вы можете загружать несколько шрифтов одновременно, группируя их: вся группа либо загрузится полностью, либо выдаст ошибку. Это полезно использовать, когда загружаемые шрифты принадлежат к одному семейству, и вы не хотите, чтобы группа отрисовывалась, пока не загрузятся все шрифты из неё. Тем самым, браузер не будет отображать стили, пока шрифты представлены не полностью.</p>
<pre><code>var normal = new FontFaceObserver('Output Sans');
var italic = new FontFaceObserver('Output Sans', {
    style: 'italic'
});

Promise.all([
    normal.load(),
    italic.load()
]).then(function () {
    console.log('Загружено семейство Output Sans');
});
</code></pre>
<p>Вы можете сгруппировать шрифты через <code>Promise.all</code>. Когда промис будет выполнен, мы будем знать, что все шрифты загружены. Если промис отклонён — как минимум один из шрифтов не смог загрузиться.</p>
<p>Ещё один пример применения группировки шрифтов — уменьшение количества перекомпоновок страницы. Если вы загружаете и отрисовываете веб-шрифты постепенно, браузер будет выполнять перекомпоновку страницы множество раз, так как характеристики начертаний запасного и веб-шрифта различны. Группировка позволит сократить количество перекомпоновок до одной.</p>
<h2>Загрузка шрифтов с таймером</h2>
<p>Иногда шрифты загружаются очень долго. Это может стать проблемой, поскольку веб-шрифты отвечают за текст — главную часть контента вашей страницы. Невозможно ждать загрузки шрифтов бесконечно. Мы можем исправить это, добавив таймер к загрузке.</p>
<p>Следующая вспомогательная функция создаёт таймеры, возвращающие промис, отклоняющийся по срабатыванию таймера.</p>
<pre><code>function timer(time) {
    return new Promise(function (resolve, reject) {
        setTimeout(reject, time);
    });
}
</code></pre>
<p>С помощью <code>Promise.race</code> мы можем заставить таймер и загрузку шрифта «соревноваться» друг с другом. Например, если загрузка завершилась до того, как сработал таймер, то шрифт победил, промис выполнен. А если раньше сработал таймер, промис отклонён.</p>
<pre><code>var font = new FontFaceObserver('Output Sans');

Promise.race([
    timer(1000),
    font.load()
]).then(function () {
    console.log('Загружен Output Sans');
}).catch(function () {
    console.log('Время на загрузку Output Sans истекло');
});
</code></pre>
<p>В этом примере время загрузки шрифта ограничено одной секундой. Вместо того, чтобы работать с одним шрифтом, мы также можем назначить таймер целой группе шрифтов. Это позволит просто и эффективно ограничить время их загрузки.</p>
<h2>Приоритетная загрузка</h2>
<p>Обычно, для того, чтобы отрисовать первую половину экрана (<em>above the fold</em> — верхняя половина первого экрана сайта, которую надо отобразить максимально быстро, <em>прим. переводчика</em>), нужно лишь несколько шрифтов. Если загружать эти шрифты раньше других, менее важных, мы получим выигрыш в производительности сайта. Это называется приоритетной загрузкой.</p>
<pre><code>var primary = new FontFaceObserver('Primary');
var secondary = new FontFaceObserver('Secondary');

primary.load().then(function () {
    console.log('Загружен основной шрифт')

    secondary.load().then(function () {
        console.log('Загружен второстепенный шрифт')
    });
});
</code></pre>
<p>При использовании приоритетной загрузки второстепенный шрифт зависит от основного: если не загрузится основной шрифт, то не загрузится и второстепенный. Это может оказаться полезным.</p>
<p>Например, можно применить приоритетную загрузку так: сначала загрузить небольшой основной шрифт, содержащий ограниченное число символов, а затем полный шрифт с большим количеством символов или стилей. Так как основной шрифт мал, он намного быстрее загрузится и отрисуется. А если основной шрифт не смог загрузиться, то, вполне возможно, не следует запрашивать и второстепенный — скорее всего, он тоже не загрузится.</p>
<p>Такое использование приоритетной загрузки более подробно описано в статьях Зака Лезермана: <a href="https://www.zachleat.com/web/foft/">Flash of Faux Text</a> и <a href="https://www.zachleat.com/web/web-font-data-uris/">Web Font Anti-Patterns: Data URIs</a>.</p>
<h2>Особое отображение шрифтов</h2>
<p>Перед тем как браузер сможет показать веб-шрифт, он должен скачать его по сети. Обычно это занимает какое-то время, и каждый браузер по-разному ведёт себя во время скачивания веб-шрифтов: некоторые из них скрывают текст, а другие сразу же показывают его с помощью запасного шрифта. Обычно это называют <em>мельканием невидимого текста</em> (Flash Of Invisible Text, <em>FOIT</em>) и <em>мельканием текста без стилей</em> (Flash Of Unstyled Text, <em>FOUT</em>).</p>
<figure>
    
  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 52.9054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABN0lEQVQoz4WS226DQAxE9/8/DJAqnrlEEFogXArhmlAghZ6slaptHjoPq8Ue2+NZ1KfG7QHu+773ff+uURTF5XLZtk1oXG4/oOI4TtO0aZrz+Qwbal3XrxpSX5blOI4Q3jSIwGw0lOM4QRAcDgfP8+AxlihBPn3fd133dDoxc5qm4/EIkzOKIoLLsijDMGzbtiyLEwbFeZ6bpsnniwYrEEQRjZgRhiEt0Luuq5I2vcam0bYt7ZMkGYYBwexGcJ7nruuu16sYJBao/Tfg0RIJlFHAXSxcNZD68QBZBQlJswY5ukKqqirLMnEbAvWkGEtT4QhNQWLJVgOrYGAmQcxDJ8qJEyQlTwCZFN3vbv+RLY+5P4GZ8iIA5zDlLltM+reY4RQzudBA3f0neZ48PSBWfbso/sm2cn4BDRVu24VPQgIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;">
      <img class="gatsby-resp-image-image" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;" alt="FOUT &#x438; FOIT." title="" src="/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-ce0d4.png" srcset="/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-a6060.png 163w,
/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-1a895.png 325w,
/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-ce0d4.png 650w,
/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-63d2a.png 975w,
/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-87302.png 1300w,
/static/fout-foit-8e129340dcccbb5f76321ea0d40564ea-6c20f.png 1480w" sizes="(max-width: 650px) 100vw, 650px">
    </span>
  </span>
  
    <figcaption>FOUT &#x438;&#xA0;FOIT.</figcaption>
</figure>
<p>Internet Explorer и Edge используют FOUT и отображают запасные шрифты, пока веб-шрифт не закончит свою загрузку. Все остальные браузеры используют FOIT и прячут текст во время загрузки веб-шрифтов.</p>
<p>Для управления этим поведением ввели новое CSS-свойство, называемое <code>font-display</code> (<a href="https://tabatkins.github.io/specs/css-font-display/">CSS Font Rendering Controls</a>). К сожалению, оно до сих пор находится в разработке и ещё не поддерживается ни одним браузером (на данный момент оно спрятано за флагом в Chrome и Opera). Однако мы можем реализовать аналогичное поведение во всех браузерах с помощью Font Face Observer.</p>
<p>Вы можете обмануть браузеры, использующие FOIT, заставив их сразу же отрисовывать текст запасными шрифтами, используя только полностью загруженные шрифты из вашей цепочки. Если шрифт ещё не в цепочке (поскольку он загружается), браузеры не будут пытаться скрыть текст.</p>
<p>Простейший способ сделать это — устанавливать на элемент <code>&#x3C;html></code> по классу на каждое из трёх состояний загрузки веб-шрифта: сам процесс загрузки, его завершение и ошибку. Класс <code>fonts-loading</code> устанавливается сразу, как начинается загрузка, <code>fonts-loaded</code> — когда шрифт загружен, и <code>fonts-failed</code> — если загрузка не удалась.</p>
<pre><code>var font = new FontFaceObserver('Output Sans');
var html = document.documentElement;

html.classList.add('fonts-loading');

font.load().then(function () {
    html.classList.remove('fonts-loading');
    html.classList.add('fonts-loaded');
}).catch(function () {
    html.classList.remove('fonts-loading');
    html.classList.add('fonts-failed');
});
</code></pre>
<p>При помощи этих классов и простого CSS вы можете кроссбраузерно использовать FOUT. Начнём с объявления запасных шрифтов для всех элементов, которым понадобятся веб-шрифты. Когда в <code>&#x3C;html></code> появляется класс <code>fonts-loaded</code>, мы применяем веб-шрифт, изменяя цепочку шрифтов для всех соответствующих элементов. Изменение правила в CSS заставит браузер загрузить веб-шрифт, однако, поскольку к этому моменту он уже будет загружен, перерисовка начнется практически мгновенно.</p>
<pre><code>body {
    font-family: Verdana, sans-serif;
}

.fonts-loaded body {
    font-family: Output Sans, Verdana, sans-serif;
}
</code></pre>
<p>Такой способ загрузки шрифтов может показаться вам похожим на технику прогрессивного улучшения. Так оно и есть: <em>мелькание текста без стилей</em> (FOUT) соответствует прогрессивному улучшению. Базовый вид в первую очередь отрисовывается запасными шрифтами, а затем улучшается веб-шрифтами.</p>
<p>Реализация FOIT такая же простая. Когда веб-шрифты начинают загрузку, вы скрываете контент, использующий шрифты, а когда они загружены, вы показываете его снова. Не забывайте и об ошибке загрузки — контент должен быть доступен, даже если шрифты не смогли загрузиться.</p>
<pre><code>.fonts-loading body {
    visibility: hidden;
}

.fonts-loaded body,
.fonts-failed body {
    visibility: visible;
}
</code></pre>
<p>Такой способ сокрытия контента кажется вам странным? Хорошо, если так. Этот паттерн следует применять только в очень специфичных случаях. Например, если у вас нет подходящего запасного шрифта, или вы точно знаете, что шрифт был закэширован ранее.</p>
<h2>Оптимизация для кэширования</h2>
<p>Все предыдущие паттерны позволяли вам регулировать когда и как загружаются шрифты. Однако, часто мы хотим, чтобы в зависимости от наличия или отсутствия шрифта в кэше сайт вёл себя по-разному. Например, если шрифт закэширован, нет необходимости отрисовывать текст сначала запасным шрифтом. Такого эффекта можно добиться сохранением в Session Storage статуса о том, был ли шрифт закэширован или нет.</p>
<p>Когда шрифт загружен, мы устанавливаем флаг в Session Storage. Флаг сохраняется на протяжении всей сессии, и с его помощью мы можем определить, находится файл в браузерном кэше или нет.</p>
<pre><code>var font = new FontFaceObserver('Output Sans');

font.load().then(function () {
    sessionStorage.fontsLoaded = true;
}).catch(function () {
    sessionStorage.fontsLoaded = false;
});
</code></pre>
<p>Теперь вы можете использовать эту информацию, чтобы изменить стратегию загрузки закэшированных шрифтов. Например, можно включить такой фрагмент JavaScript в элемент <code>&#x3C;head></code> вашей страницы, чтобы сразу же отрисовывать веб-шрифты.</p>
<pre><code>if (sessionStorage.fontsLoaded) {
    var html = document.documentElement;
    html.classList.add('fonts-loaded');
}
</code></pre>
<p>Если вы будете загружать шрифты этим способом, ваши посетители увидят FOUT только при первом посещении сайта, а при всех дальнейших переходах шрифт будет отрисовываться мгновенно. А значит, с одной стороны, вы сохраните выгоды, которые даёт прогрессивное улучшение, а с другой — сделаете сайт удобным, поскольку загрузка страниц будет меньше раздражать при повторных посещениях.</p>
<p>Перевод оригинальной статьи «<a href="https://www.bramstein.com/writing/web-font-loading-patterns.html">Web Font Loading Patterns</a>» Брэма Штайна. Перевод <a href="https://github.com/aalexeev239">Андрея Алексеева</a>, редактура <a href="http://pepelsbey.net">Вадима Макеева</a>.</p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-web-font-loading-patterns-986","path":"/articles/web-font-loading-patterns/"};window.dataPath="517/path---articles-web-font-loading-patterns-986-137-avzAl0iCaFNz9QVODPxhAoKgjA";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>