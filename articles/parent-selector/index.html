<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/345/path---articles-parent-selector-4-f-5-1f1-sNpFRg8D1xxHNvIIrhCNk0aF8VY.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Почему у нас нет селектора по родителю</h1><div class="article__date">20 сентября 2011</div><div class="article__content"><h1>Почему у нас нет селектора по родителю</h1>
<p><a href="http://snook.ca/">Джонатан Снук</a> 20 сентября 2011</p>
<p>Относительно регулярно я вижу дискуссии о том, должен ли CSS включать селектор по родителю и, пока я не выяснил, как работает движок браузера, сам строил предположения по этому поводу.</p>
<p>Вкратце: <em>производительность</em>.</p>
<h2>Как работает CSS</h2>
<p>В связи с моей работой я делаю много тестов производительности. Для определения «узких мест» мы используем массу приложений. Например, Google Page Speed, который дает рекомендации по улучшению производительности JavaScript и рендеринга. Прежде чем я перейду к рассмотрению этих рекомендаций, нам нужно разобраться как браузеры работают с CSS</p>
<h2>Стиль элемента применяется в момент его создания</h2>
<p>Мы часто рассматриваем веб-страницы как полноценные документы, наполненные элементами и содержимым. Между тем, браузеры разработаны так, чтобы обрабатывать документ потоково. Они начинают получать документ с сервера и могут начать его отображать до момента полной загрузки. Каждый узел анализируется и отображается в окне по мере получения.</p>
<p>Взгляните на этот документ:</p>
<pre><code>&#x3C;body>
    &#x3C;div id="content">
        &#x3C;div class="module intro">
            &#x3C;p>Lorem Ipsum&#x3C;/p>
        &#x3C;/div>
        &#x3C;div class="module">
            &#x3C;p>Lorem Ipsum&#x3C;/p>
            &#x3C;p>Lorem Ipsum&#x3C;/p>
            &#x3C;p>Lorem Ipsum &#x3C;span>Test&#x3C;/span>&#x3C;/p>
        &#x3C;/div>
    &#x3C;/div>
&#x3C;/body>
</code></pre>
<p>Браузер начинает сначала и видит элемент <code>&#x3C;body></code>. В этот момент времени считается, что этот узел не имеет дочерних узлов. Ничего более не рассматривается. Браузер определяет соответствующий ему обобщенный набор стилей и применяет его к элементу. Какой шрифт, цвет, интерлиньяж? После того, как это все будет выяснено, элемент отображается на экране.</p>
<p>Далее браузер видит элемент <code>&#x3C;div></code> со значением атрибута ID <code>content</code>. И снова в этот момент времени браузер считает его пустым. Он не рассматривает другие элементы. Как только браузер рассчитает стиль, элемент отображается на экране. Затем браузер определяет нужно ли перерисовать <code>&#x3C;body></code> — стал ли элемент шире или выше? Я подозреваю, что там есть масса других проверок, но изменение ширины и высоты — самый распространенный способ повлиять на отображение родительского узла.</p>
<p>Процесс продолжается, пока браузер не достигнет корневого узла документа.</p>
<p>Вот как выглядит визуализация процессов перерисовки в Firefox:</p>
<iframe width="510" height="382" src="http://www.youtube.com/embed/ZTnIxIA5KGw" frameborder="0"></iframe>
<h2>CSS селекторы анализируется справа налево</h2>
<p>Чтобы определить, применяется ли CSS-правило к определенному элементу, браузер рассматривает селектор справа налево.</p>
<p>Если у вас есть селектор <code>body div#content p { color: #003366; }</code>, то, когда каждый элемент появляется на странице, браузер проверяет, является ли он параграфом. Если да, он начинает подниматься вверх по DOM и ищет <code>&#x3C;div></code> со значением атрибута ID равным <code>content</code>. Если он его находит, то продолжает подниматься по DOM пока не найдет <code>&#x3C;body></code>.</p>
<p>Таким образом, читая селектор справа налево, браузер значительно быстрее может определить применяется ли правило к элементу. Чтобы определить, какой из селекторов обладает большей производительностью, нужно выяснить, как много узлов придется рассмотреть, чтобы определить, можно ли применить правило к элементу.</p>
<h2>Правила</h2>
<p>Возвращаясь к Page Speed, давайте рассмотрим <a href="http://code.google.com/speed/page-speed/docs/rendering.html#UseEfficientCSSSelectors">несколько его рекомендаций</a>:</p>
<ul>
<li>Избегайте селектора по потомку: <code>.content .sidebar</code>;</li>
<li>Избегайте селектора по дочернему элементу: <code>.content > .sidebar</code> и селектора по следующему элементу: <code>.content + .sidebar</code>.</li>
</ul>
<p>Конечно, селекторы по ID — самые быстрые. Проверить применимость селектора <code>#content</code> к рассматриваемому элементу можно очень быстро. Есть у него этот ID или нет? Селекторы по классу практически такие же быстрые, так как нет никаких связанных элементов, которые надо проверять.</p>
<p>Селекторы по потомкам, такие как <code>.content .sidebar</code> — более ресурсоемкие, так как, чтобы определить надо ли применять правило к <code>.sidebar</code>, браузер должен найти <code>.content</code>. Cелектор по дочернему элементу, например, <code>.content > .sidebar</code>, лучше селектора по потомку, так как браузер должен проверить только один элемент вместо множества.</p>
<p>К сожалению, селекторы <code>+</code> и <code>></code> не поддерживаются IE6. Так что если его поддержка актуальна для вас, то про них придется забыть. Примечание переводчика.</p>
<h2>Селектор по тегу и универсальный селектор</h2>
<p>В рамках рекомендации избегать селекторов по потомку, дочернему или следующему элементам, рекомендуется избегать универсального селектора и селектора по тегу.</p>
<p>Рассмотрим следующий пример:</p>
<pre><code>#content * { color: #039; }
</code></pre>
<p>Так как в селекторе присутствует ID, то можно подумать, что этот селектор обрабатывается очень быстро. Проблема в том, что браузер обрабатывает селектор справа налево и сперва проверяется универсальный селектор. Для того чтобы браузер мог определить, должен ли цвет текста элемента быть тёмно-синим, надо проверить каждый предок элемента, пока не будет найден предок с атрибутом ID равным <code>content</code> или не будет достигнут корень документа.</p>
<p>И это должно быть сделано для каждого элемента на странице.</p>
<p>Теперь, когда мы понимаем, как элемент обрабатывается, как определяется применимость правил к элементу, давайте рассмотрим пример.</p>
<h2>Почему IE долго не поддерживал <code>:last-child</code></h2>
<p>Все жаловались: у всех браузеров, кроме IE, есть поддержка <code>:last-child</code> (она появилась только в IE9!) Некоторые могли подумать <q>насколько же сложнее сделать :last-child, если уже реализован :first-child?</q></p>
<p>Давайте представим, что мы — браузер и мы парсим документ-пример, который я приводил ранее.</p>
<pre><code>.module > p:first-child { color: red; } /* Первое правило */
.module > p:last-child { color: blue; } /* Второе правило */
</code></pre>
<p>Когда мы рассматриваем внутренности первого <code>&#x3C;div></code>, мы видим, что там есть параграф. Браузер видит что-то вроде этого:</p>
<pre><code>&#x3C;div class="module">
    &#x3C;p>Lorem Ipsum&#x3C;/p>
</code></pre>
<p>Нужно ли применить первое правило к параграфу? Да, это параграф; да, это первый дочерний узел; и, да, это непосредственный потомок элемента с классом <code>module</code>.</p>
<p>Нужно ли применить к этому параграфу второе правило? На данный момент это последний элемент. Но мы могли ещё не загрузить все элементы и не можем быть уверены, что он останется последним.</p>
<p>Вне зависимости от того, как решать эту дилемму, у нас возникает необходимость повторного анализа стилей двух узлов для каждого нового узла, который мы добавляем в DOM. Если я добавлю ещё один параграф следом за первым, мы должны так же повторно перерассчитать стили, которые применяются к предыдущему параграфу.</p>
<h2>Как на самом деле это делает браузер?</h2>
<p>Я не мог сказать с абсолютной уверенностью, как браузеры парсят <code>:last-child</code>, так что я создал несколько тестов:</p>
<ul>
<li><a href="http://testing.snook.ca/css-1.html">Статическая HTML-страница</a>;</li>
<li><a href="http://testing.snook.ca/css-1.php">Рендеринг с паузами в одну секунду</a>.</li>
</ul>
<p>Первый пример весьма скучен. В любом браузере, включая IE9, всё отображается корректно. Внутри <code>&#x3C;div></code> первый элемент красный, а последний синий. Но посмотрите на второй пример, и вы увидите интересные отличия в поведении браузеров.</p>
<p>Второй пример приостанавливается перед добавлением каждого параграфа в <code>&#x3C;div></code>.</p>
<p>В Firefox первый параграф изначально отображается синим. Когда загружается второй параграф, первый становится красным и второй — синим. Когда загружается третий параграф, второй отображается цветом по умолчанию и третий отображается синим. Firefox рассматривает каждый элемент, который был загружен в качестве последнего элемента, пока не будет загружен ещё один.</p>
<p>В Safari, Chrome и Opera мы увидим другой подход. Первый параграф красный. Второй отображается чёрным. Последний параграф отображается чёрным, пока браузер не получит закрывающий тег <code>&#x3C;/div></code>. В этот момент последний параграф становится синим. Эти браузеры не рассматривают элемент как последний, пока не будет закрыт родительский.</p>
<p>В Internet Explorer 9 Beta я нашел интересный баг. В то время, как статическая страница отображается корректно, версия с паузами отрабатывает с любопытным побочным эффектом. Первый параграф синий, второй параграф синий и затем — третий. Когда закрывающий тег <code>&#x3C;/div></code> загружен, предпоследний параграф меняет цвет на чёрный. IE9 пытается обрабатывать селектор как Webkit и Opera, но… м-м… не выходит. Надо бы отправить багрепорт в Microsoft.</p>
<h2>Почему у нас нет селектора по родителю?</h2>
<p>Уже дано достаточно пояснений, чтобы можно было вернуться к оригинальному вопросу. Проблема не в том, что у нас не может быть селектора по родителю. Проблема в том, что мы столкнемся с проблемами быстродействия, когда дело дойдет до определения того, какие CSS-правила применимы к данному элементу. Если Google Page Speed не рекомендует использование универсальных селекторов, то можно гарантировать, что селектор по родителю будет первым в списке ресурсоемких селекторов, намного опережая все проблемы с производительностью, которые могут быть вызваны использованием универсального селектора.</p>
<p>Давайте посмотрим почему. Первым делом давайте приведём пример синтаксиса для селектора по родителю.</p>
<pre><code>div.module:has(span) { color: green; }
</code></pre>
<p>Проблема в том, что мы не можем определить применимость правила до тех пор, либо пока мы не найдем соответствия, либо пока все элементы, дочерние по отношению к родителю данного, не будут загружены. Ввиду этого мы должны оценивать правило и все остальные (в случае наличия специфических особенностей), применяющиеся к элементу, для каждого дочернего элемента, который мы загружаем.</p>
<p>Посмотрите на часть нашего документа:</p>
<pre><code>&#x3C;div class="module">
    &#x3C;p>Lorem Ipsum&#x3C;/p>
    &#x3C;p>Lorem Ipsum&#x3C;/p>
    &#x3C;p>Lorem Ipsum &#x3C;span>Test&#x3C;/span>&#x3C;/p>
&#x3C;/div>
</code></pre>
<p>Исходя из того, что мы видим, <code>.module</code> будет отображён без использования правила, применяемого селектором по родителю. Когда будет загружен первый элемент <code>&#x3C;p></code>, нужно повторно оценить применимость селектора по родителю к <code>&#x3C;div></code>. Нужно сделать это снова для следующего параграфа. И снова, для следующего. Наконец, когда <code>&#x3C;span></code> загружен, селектор по родителю будет применен к родительскому <code>&#x3C;div></code>, и элемент нужно будет повторно перерисовать.</p>
<p>И что теперь? Теперь, если изменится любое наследуемое CSS-свойство, каждый потомок должен будет повторно анализироваться и перерисовываться. Ох…</p>
<h2>Почему проблему можно решить с помощью JavaScript?</h2>
<p>Это только кажется, что JavaScript решает проблему. В общем случае JavaScript-заплатки (<em>заплатки — polyfills — части кода, обеспечивающие функциональность, которую должен обеспечивать браузер. Примечание переводчика</em>). Или регрессивное усовершенствование (или как там вы, молодежь, это сейчас называете) запускаются только один раз, после полной загрузки DOM.</p>
<p>Для того чтобы действительно имитировать поведение CSS, любой скрипт, решающий эту проблему, должен запускаться после отображения каждого элемента на странице, чтобы определить, нужно ли применить нашу «заплатку». Помните CSS-expressions в Internet Explorer? Именно по этой причине они вызывали такие проблемы с производительностью.</p>
<h2>Не невозможно</h2>
<p>Появится ли когда-нибудь селектор по родителю? Возможно. То, что я опиcал, не невозможно. На самом деле — наоборот. Это значит только то, что нам придётся иметь дело с ухудшением производительности из-за использования этого селектора.</p>
<p>Перевод оригинальной заметки «<a href="http://snook.ca/archives/html_and_css/css-parent-selectors/">Why we don’t have a parent selector</a>» <a href="http://snook.ca/about/">Джонатана Снука</a> (Jonathan Snook), опубликованной в блоге «<a href="http://snook.ca/">Snook.ca</a>».</p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-parent-selector-4f5","path":"/articles/parent-selector/"};window.dataPath="345/path---articles-parent-selector-4-f-5-1f1-sNpFRg8D1xxHNvIIrhCNk0aF8VY";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>