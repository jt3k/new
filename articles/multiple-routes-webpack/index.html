<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/836/path---articles-multiple-routes-webpack-5-ae-d30-G7DUvxCZyNsqcLWsp1HaVTo4dj0.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Роутинг, бандлинг и ленивая загрузка на Webpack</h1><div class="article__date">TODO</div><div class="article__content"><h1>Роутинг, бандлинг и ленивая загрузка на Webpack</h1>
<p>Перевод «Multiple routes, bundling and lazy-loading» Серджио Гомеса.</p>
<h2>Обзор проблемы</h2>
<p>Мы с коллегами пишем клиентское приложение на нативном <em>JS</em>, которое разбивается на маршруты. Маршруты — это способ организации структуры сайта. Они как правило привязаны к отдельным <em>URL</em>. Таким образом, в интернет-магазине вы можете иметь различные маршруты, такие как главная, список категорий, страница продукта, и страница оформления заказа, каждый из которых может иметь свой собственный <em>JavaScript</em>. Например, для списка категорий может потребоваться код для обработки фильтрации, а для страницы оформления заказа может потребоваться иной код (для валидации формы).</p>
<p>Однако мы не создаем полностью клиентское приложение. Пользователь может попасть на сайт через различные страницы, например, ввести <em>URL</em> в адресную строку и загрузить главную страницу, или найти интересный продукт в поисковике и перейти прямо на страницу описания этого продукта. Поэтому каждый из этих маршрутов должен иметь свою собственную структуру <em>URL</em>:</p>
<pre><code>Home: /
Category listing: /category/42
Product page: /product/1234
Checkout: /checkout
</code></pre>
<p>Кроме того, нам не нужно загружать весь <em>JavaScript</em> для всех маршрутов, когда сайт впервые открыт. В идеале, нам достаточно кода для того маршрута, который был открыт, а остальное можно подгружать, когда пользователь переходит на другие страницы сайта. Но если вы делаете единый бандл, то вы получите один массивный файл, который должен быть полностью загружен и проанализирован, прежде чем что-либо произойдет:</p>
<pre><code>dist/
  big-bundle.js
</code></pre>
<p>Это не лучшее решение, ведь подгружается много <em>JavaScript</em>, который не используется. При медленном подключении это может означать, что пользователю придется подождать довольно долгое время, прежде чем начать взаимодействовать со страницей. Вот почему большие бандлы являются антипаттерном.</p>
<p>Вот где нам поможет концепция <strong>точки входа</strong>. Вместо того, чтобы иметь единый главный файл, мы решили иметь точку входа для каждого маршрута, при этом оставшиеся маршруты лениво загружаются по мере необходимости. В конечном итоге мы получим следующее:</p>
<pre><code>dist/
  bundle-home.js
  bundle-category.js
  bundle-product.js
  bundle-checkout.js
  home.js
  category.js
  product.js
  checkout.js
</code></pre>
<p>В зависимости от маршрута, будет загружен только один из файлов пакета. Этот файл будет лениво загружать другие модули, по мере необходимости. И если пользователь открыл продукт, то загрузится только bundle-product.js, необходимый для текущей страницы , а затем лениво подгрузятся home.js, category.js и checkout.js , если это необходимо.</p>
<p>Это решение позволяет загружать весь необходимый код для выполнения немедленного запроса пользователя и только при необходимости загружать остальной. И хотя это и включает в себя один и тот же код в нескольких файлах, фактически пользователь должен загружать только одну версию каждого модуля при навигации по сайту.</p>
<h2>Webpack и модули</h2>
<p>Существует миф, что <em>Webpack</em> трудно сконфигурировать, чтобы использовать его в большинстве ситуаций. Я использую <em>Webpack</em> недавно, и не могу судить насколько было правдиво это утверждение в прошлом, но оказывается, что сейчас <em>Webpack</em> довольно прост в использовании! Если вы знакомы с <em>ES</em>-модулями, статическим и динамическим импортом, вы в значительной степени готовы к созданию некоторых сложных приложений с хорошей практикой загрузки и без особых навыков конфигурирования.</p>
<p><em>Webpack</em> понимает стандартизированный синтаксис <em>ES</em>-модулей, а также статическую и динамическую загрузку модулей. Он смотрит на ваш код и решает, как разделить его на пакеты в зависимости от того, какой тип импорта вы делаете. Таким образом, если вы загружаете модуль статически, он будет в бандле:</p>
<pre><code>import Foo from './foo.js';
Foo.doSomething();
</code></pre>
<p>Приведенные выше результаты соберутся в один файл bundle.js со всем кодом. Если вместо этого вы загружаете его динамически, то <em>Webpack</em> будет создавать отдельный бандл и получать дополнительный код по требованию:</p>
<pre><code>import('./foo.js').then(module => {
  module.doSomething();
});
</code></pre>
<p>Приведенные выше результаты соберутся в bundle.js с некоторой магической ленивой загрузкой, и файл 0.js с кодом для foo. 0.js называется «чанком» в терминологии, предназначенной для ленивой загрузки другим кодом <em>Webpack</em>, и не обрабатывается непосредственно собственным кодом.</p>
<h2>Множественные точки входа и роутинг</h2>
<p>Хорошо, похоже, что все готово! Вы можете написать стандартизированный код модуля, который будет работать как изначально в браузере (если ваш браузер уже добавил поддержку), так и через некоторую магию в <em>Webpack</em>.</p>
<p>Итак, давайте напишем код и посмотрим, как это на самом деле выглядит. Я вернусь к исходному примеру и использую маршруты для страниц категории, продукта, оформления заказа и главной, а также соответствующую точку входа для каждого из них.</p>
<p>Модули довольно просты. Вы можете создать один метод с любым именем, так как содержание не имеет значения для примера:</p>
<pre><code>export function printMessage() {
  console.log('Hi! This is the Checkout module.');
}
</code></pre>
<p>Каждый файл точки входа будет загружать соответствующий модуль статически, а остальные модули динамически. Чтобы избежать дублирования кода, вам нужно создать простой, последовательный интерфейс для определения всего остального. Вот пример, который я называю Router.</p>
<p><strong>*Примечание:</strong> хоть этот пример и не будет делать какие-либо фактические маршрутизации, в традиционном смысле, он будет определять какой код будет загружаться по маршруту. Так что я все еще думаю, что это нормальное имя:)*</p>
<pre><code>const _modules = {
  Home: import('./home.js'),
  Category: import('./category.js'),
  Product: import('./product.js'),
  Checkout: import('./checkout.js'),
};

export default class Router {
  static get modules() {
    return _modules;
  }
}
</code></pre>
<p>Каждый модуль хранится как запись в объекте _modules, причем значение является промисом загрузки, возвращаемым import(). Обратите внимание, что это немедленно начнет загружать другие маршруты, которые вам, возможно, не понадобятся, но в этом случае вы всегда можете отложить загрузку явным вызовом, который вызовет фактический импорт. Например:</p>
<pre><code>const _modules = {
  Home: () => import('./home.js'),
  Category: () => import('./category.js'),
  Product: () => import('./product.js'),
  Checkout: () => import('./checkout.js'),
};

export default class Router {
  static get modules() {
    return _modules;
  }
}
</code></pre>
<p>Но если все четыре модуля загружаются лениво, как избежать дублирования кода в точке входа? Безусловно, один из них должен быть null?</p>
<p>На самом деле в этом нет необходимости! Браузер (с поддержкой модулей) и <em>Webpack</em> делают дедупликацию, где они отслеживают, какие модули были загружены, чтобы они не загружались дважды. Таким образом, вам, как разработчику, не нужно беспокоиться о том, чтобы отслеживать что-либо из этого. Это делает точку входа действительно чистой и легкой для понимания:</p>
<pre><code>import * as Home from './home.js';
import Router from './router.js';

console.log('Hello from the Home entry point!');

Router.modules.Home().then(module => module.printMessage());
Router.modules.Category().then(module => module.printMessage());
Router.modules.Product().then(module => module.printMessage());
Router.modules.Checkout().then(module => module.printMessage());
</code></pre>
<p>Главная загружается статически, так что она сразу же доступна и не требует ожидания ленивой загрузки. Router также загружается статически. После того, как вы сделаете запрос к Router, он проверяет, был ли загружен этот модуль либо статически, либо динамически. Если он уже был загружен, промис немедленно разрешается. Если этого не произошло, он извлекает файл, загружает код и продолжает цепочку промисов после этого.</p>
<p>Это означает, что все модули могут использоваться точно так же, входным модулем или, если это было реальное приложение с надлежащей маршрутизацией <em>URL</em>, самим Router.</p>
<h2>Как мне заставить это работать в Webpack?</h2>
<p>Как я упоминал ранее, все это должно работать в браузере без изменений, если ваш браузер поддерживает <em>ES-</em>модули и их загрузку. Вы не получите преимущества от сборки без некоторой дальнейшей работы, но код все еще функционален.</p>
<p>Тем не менее, поскольку большинство из нас все еще собирают в бандл, нам нужно найти способ заставить это работать с <em>Webpack</em>. И оказывается все очень просто! Вот файл webpack.config.js:</p>
<pre><code>const path = require('path');
module.exports = {
  entry: {
    'bundle-home': './entry-home.js',
    'bundle-category': './entry-category.js',
    'bundle-product': './entry-product.js',
    'bundle-checkout': './entry-checkout.js',
  },
  output: {
    path: path.resolve('./dist'),
    filename: '[name].js',
  }
}
</code></pre>
<p>Главное здесь — убедиться, что все точки входа являются частью одного формирования, чтобы создать только один набор динамически загружаемых блоков. Выходное имя файла основано на ключе для каждой точки входа, благодаря использованию [name], поэтому вывод выглядит следующим образом:</p>
<pre><code>dist/
  0.js
  1.js
  2.js
  3.js
  bundle-category.js
  bundle-checkout.js
  bundle-home.js
  bundle-product.js
</code></pre>
<p>Числовые файлы включают в себя модуль, завернутый в <em>JSONP</em>. Собранные файлы имеют код для этой точки входа, связанный с кодом Router и некоторыми методами, обрабатывающими отложенную загрузку.</p>
<p>Если вы загрузите файл bundle-checkout.js на тестовой странице и посмотрите на отладчик <em>Chrome</em>, вы можете убедится, что загружаются только три чанка, как и ожидалось. Вы также можете увидеть, что сообщение из модуля Checkout поступает из bundle-checkout.js, что означает, что модуль Checkout попал в этот файл.</p>
<p><img src="https://cdn-images-1.medium.com/max/2660/0*pnJPmIbgfe86W1QK.png"></p>
<h2>Выводы и предостережения</h2>
<p>Обратите внимание, что этот пример довольно прост, и реальное приложение будет иметь дополнительные требования, такие как необходимость использовать <em>CommonsChunkPlugin</em> для более легкого разделения битов кода, или, возможно, некоторые потенциальные сложности, возникающих при использовании <em>npm</em>-модулей в качестве зависимостей. Это, вероятно, потребует дополнительной работы над конфигурацией <em>Webpack</em>.</p>
<p>Тем не менее, я чувствовал, что это интересная проблема и достаточно достойное решение, чтобы поделиться, поэтому я надеюсь, что вы найдете его полезным! Особая благодарность Сурме и Сэму Даттону за помощь в поисках более чистого решения!</p>
<p><em>Перевод <a href="https://medium.com/@nzvtrkk">Артура Храброва</a>, редактура <a href="https://medium.com/@pepelsbey">Вадима Макеева</a>.</em></p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-multiple-routes-webpack-5ae","path":"/articles/multiple-routes-webpack/"};window.dataPath="836/path---articles-multiple-routes-webpack-5-ae-d30-G7DUvxCZyNsqcLWsp1HaVTo4dj0";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>