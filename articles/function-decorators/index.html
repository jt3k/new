<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/232/path---articles-function-decorators-a-52-9b0-IUfP8y9vcIi9qeFIAX5ZEFN8k.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Функции-декораторы, которые можно написать с нуля</h1><div class="article__date">TODO</div><div class="article__content"><h1>Функции-декораторы, которые можно написать с нуля</h1>
<p>Перевод «Here are a few function decorators you can write from scratch» Кристи Сальсезку.</p>
<p><img src="https://cdn-images-1.medium.com/max/10392/1*Qw0e4LC2Fri7dFkBY0N1cA.jpeg" alt="Фото [Calum Lewis](https://unsplash.com/photos/rkT_TG5NKF8)."><em>Фото <a href="https://unsplash.com/photos/rkT_TG5NKF8">Calum Lewis</a>.</em></p>
<blockquote>
<h1>Декораторы — это функции высшего порядка, которые принимают в качестве аргумента одну функцию и возвращают другую. Возвращаемая функция является преобразованным вариантом функции-аргумента <a href="https://leanpub.com/javascript-allonge/read#decorators">*Javascript Allongé</a>*</h1>
</blockquote>
<p>Давайте самостоятельно напишем некоторые базовые дектораторы, представленные в таких библиотеках, как <a href="http://underscorejs.org/#functions">*underscore.js</a><em>, [</em>lodash.js](<a href="https://lodash.com/docs/4.17.5">https://lodash.com/docs/4.17.5</a>)<em>, [</em>ramda.js](<a href="http://ramdajs.com/docs/">http://ramdajs.com/docs/</a>)*.</p>
<h2>once()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/zpLeLp0v/">once(fn)</a> создает экземпляр функции, которая должна быть выполнена только один раз. Паттерн может быть использован, например, для инициализации, когда нужно быть уверенным в единичном запуске функциональности, даже если сама функция вызвана в нескольких местах.</p>
<p>function once(fn){
let returnValue;
let canRun = true;
return <strong>function runOnce(){
if(canRun) {
returnValue = fn.apply(this, arguments);
canRun = false;
}
return returnValue;
}</strong>
}</p>
<p>var processonce = once(process);
processonce(); // process
processonce(); //</p>
</li>
</ul>
<p>Функция once() возвращает другую функцию — runOnce(), использующую <a href="https://medium.freecodecamp.org/why-you-should-give-the-closure-function-another-chance-31253e44cfa0">замыкание</a>. Обратите также внимание, как осуществлен вызов оригинальной функции, а именно через передачу this и arguments в метод apply: fn.apply(this, arguments).</p>
<p>Если хотите узнать замыкания глубже, обратите внимание на статью «<a href="https://medium.com/p/31253e44cfa0">Why you should give the Closure function another chance</a>».</p>
<h2>after()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/4evuoxe6/">after(count, fn)</a> создает вариант функции, которая будет выполнена только после определенного количества вызовов. Функция полезна, например, если должна быть выполнена *только *по завершению асинхронных операций.</p>
<p>function after(count, fn) {
let runCount = 0;
return function runAfter() {
runCount = runCount + 1;
if (runCount >= count) {
return fn.apply(this, arguments);<br>
}
}
}</p>
<p>function logResult() { console.log("calls have finished"); }
<strong>let logResultAfter2Calls = after(2, logResult);</strong></p>
<p>setTimeout(function logFirstCall() {
console.log("1st call has finished");
<strong>logResultAfter2Calls();</strong>
}, 3000);</p>
<p>setTimeout(function logSecondCall() {
console.log("2nd call has finished");
**logResultAfter2Calls(); **
}, 4000);</p>
</li>
</ul>
<p>В примере выше при помощи after() я создаю функцию logResultAfter2Calls(). Она в свою очередь выполняет logResult() только после второго вызова.</p>
<h2>throttle()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/5tdv0eq6/">throttle(fn, wait)</a> создает вариант функции, которая при повторяющихся вызовах выполняется через указанный временной интервал (аргумент wait). Декоратор эффективен для обработки быстро повторяющихся событий.</p>
<p>function throttle(fn, interval) {
let lastTime;
return function throttled() {
let timeSinceLastExecution = Date.now() - lastTime;
if(!lastTime || (timeSinceLastExecution >= interval)) {
fn.apply(this, arguments);
lastTime = Date.now();
}
};
}</p>
<p>let throttledProcess = throttle(process, 1000);
$(window).mousemove(throttledProcess);</p>
</li>
</ul>
<p>Здесь движение мыши генерирует множество событий mousemove, тогда как оригинальная функция process() вызывается лишь раз в секунду.</p>
<h2>debounce()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/424unsa7/">debounce(fn, wait)</a> создает вариант функции, которая выполняет <em>оригинальную *функцию спустя wait миллисекунд *после</em> предыдующего вызова *декорированной *функции. Паттерн также применяется в работе с повторяющимися событиями. Он полезен, если функциональность должна быть выполнена по завершению очереди событий.</p>
<p>function debounce(fn, interval) {
let timer;
return function debounced() {
clearTimeout(timer);
let args = arguments;
let that = this;
timer = setTimeout(function callOriginalFn() {
fn.apply(that, args);
}, interval);
};
}</p>
<p>let delayProcess = debounce(process, 400);
$(window).resize(delayProcess);</p>
</li>
</ul>
<p>Функция debounce() часто используется вместе с событиями scroll, resize, mousemove и keypress.</p>
<h2>Частичное применение</h2>
<p>Частичное применение преобразует функцию за счет изменения количества параметров. Это один из примеров движения от общего к частному.</p>
<h2>partial()</h2>
<p>На этот раз <a href="https://jsfiddle.net/cristi_salcescu/sbborekp/">создадим метод partial()</a> и сделаем его доступным для всех функций. В данном примере я использую синтаксис <em>ECMAScript 6</em>, а именно оператор rest. С его помощью набор аргументов функции преобразуется в массив ...leftArguments. Это нужно для конкатенации массивов, тогда как специальный объект arguments массивом не является.</p>
<pre><code>Function.prototype.partial = function(...leftArguments){
    let fn = this;
    return function partialFn(...rightArguments){
       let args = leftArguments.concat(rightArguments);
       return fn.apply(this, args);
    }
}

function log(level, message){
    console.log(level  + " : " + message);
}

**let logInfo = log.partial("Info");
logInfo("here is a message");**
</code></pre>
<p>Обратите внимание, созданная таким образом logInfo() использует лишь один аргумент message.</p>
<h2>Заключение</h2>
<p>Применение указанных функций помогает понять принципы работы декораторов и саму идею инкапсуляции логики внутри них.</p>
<p>Декораторы — мощный инструмент расширения функциональности без изменения исходной функции. Это отличный путь переиспользовать код, и он соответствует функциональной парадигме программирования.</p>
<h3><strong>Больше о ФП в JavaScript</strong></h3>
<ul>
<li>
<p><a href="https://medium.com/p/33dcb910303a">How point-free composition will make you a better functional programmer</a></p>
</li>
<li>
<p><a href="https://medium.com/p/13ba11825319">You will finally understand what Closure is</a></p>
</li>
<li>
<p><a href="https://medium.com/p/73258b6a8d15">Class vs Factory function: exploring the way forward</a> (см. <a href="https://medium.com/@kanby/%D0%BA%D0%BB%D0%B0%D1%81%D1%81-vs-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BF%D0%B5%D1%80%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-9b4c696823c8">перевод</a>).</p>
</li>
<li>
<p><a href="https://medium.com/p/94fb8cc69f9d">Make your code easier to read with Functional Programming</a></p>
</li>
</ul>
<p><em>Перевод <a href="https://medium.com/@vlad_poe">Влада Почепцова</a>, редактура <a href="https://medium.com/@pepelsbey">Вадима Макеева</a>.</em></p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-function-decorators-a52","path":"/articles/function-decorators/"};window.dataPath="232/path---articles-function-decorators-a-52-9b0-IUfP8y9vcIi9qeFIAX5ZEFN8k";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>