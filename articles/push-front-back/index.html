<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/389/path---articles-push-front-back-6-f-2-d94-zVkPh9KQBzr91aFGqL1AIlEbH94.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Реализуем пуш-уведомления на фронтенде и бэкенде</h1><div class="article__date">TODO</div><div class="article__content"><h1>Реализуем пуш-уведомления на фронтенде и бэкенде</h1>
<p>Перевод «Implementing push notifications on the front-end and back-end» Майкла Шарналя.</p>
<p>В предыдущей <a href="https://justmarkup.com/log/2017/02/introducing-iss-observer-com/">статье</a> об <a href="https://iss-observer.com/">*iss-observer.com</a>* я обещал рассказать о технической стороне реализации пуш-уведомлений. Изначально я планировал сконцентрироваться на проблемах, с которыми пришлось иметь дело в процессе работы над <a href="https://iss-observer.com/">*iss-observer.com</a>*. Теперь я думаю, будет полезнее посвятить материал базовым вопросам, и уточнять детали, где это необходимо. Обращаю ваше внимание, что фронтенд частично опирается на <a href="https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/?hl=en">этот урок</a>.</p>
<p><em>Если вы хотите углубиться в исходный код, то смотрите в <a href="https://github.com/justmarkup/demos/tree/gh-pages/push-notifications">GitHub-репозиторий</a> и на <a href="https://push-notifications-vwursywdxa.now.sh">пример</a>, демонстрирующий его работу.</em></p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*8KWLqCaGqDIe0KRNFOycsA.jpeg"></p>
<h2>Фронтенд</h2>
<p>Начнем с клиентской части. Первое, что нужно сделать — убедиться, что браузер поддерживает пуш-уведомления. Если да, загружаем наш <em>JavaScript</em>.</p>
<pre><code>if ('serviceWorker' in navigator &#x26;&#x26; 'PushManager' in window) {
  var s = document.createElement('script');
  s.src = '/script/push.js';
  s.async = true;
  document.head.appendChild(s);
}
</code></pre>
<p>Прежде чем писать код, выполним ряд требований. Нам потребуются <em>Application Server Keys (VAPID Key)</em>. Получаем их <a href="https://web-push-codelab.appspot.com">здесь</a>, либо с помощью библиотеки <em>web-push</em>. Кстати, она нам еще потребуется для бэкенд-части. Устанавливаем библиотеку: npm install -g web-push, генерируем ключи: web-push generate-vapid-keys. В независимости от способа в результате у вас должны быть <strong>закрытый ключ*</strong> (private key)* и <strong>открытый ключ*</strong> (public key)*. Сохраните их в надежном месте.</p>
<p><em>До появления спецификации Application server key/VAPID первые браузеры (Chrome, Opera) реализовали функциональность пуш-уведомлений с помощью <a href="https://developers.google.com/cloud-messaging/">Google Cloud Messaging</a>. Все современные браузеры, за исключением <a href="https://github.com/web-push-libs/web-push#browser-support">Samsung Internet</a>, поддерживают VAPID. Поэтому в этой статье я не буду касаться GCM. Как добавить поддержку для Samsung Internet и старых версий Chrome и Opera — читайте <a href="https://web-push-book.gauntface.com/chapter-06/01-non-standards-browsers/">здесь</a>.</em></p>
<p>Посмотрим на <em>push.js</em>. Здесь мы регистрируем сервис-воркер и подписываемся на уведомления:</p>
<pre><code>'use strict';

const appServerKey = 'BHLCrsFGJQIVgg-XNp8F59C8UFF49GAVxvYMvyCURim3nMYI5TMdsOcrh-yJM7KbtZ3psi5FhfvaJbU_11jwtPY';

const pushWrapper = document.querySelector('.push-wrapper');
const pushButton = document.querySelector('.push-button');

let hasSubscription = false;
let serviceWorkerRegistration = null;
let subscriptionData = false;

function urlB64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/\-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i &#x3C; rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

function updatePushButton() {
  pushWrapper.classList.remove('hidden');
  
  if (hasSubscription) {
    pushButton.textContent = `Disable Push Notifications`;
  } else {
    pushButton.textContent = `Enable Push Notifications`;
  }
}

function subscribeUser() {
  serviceWorkerRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlB64ToUint8Array(appServerKey)
  })
  .then(function(subscription) {

    fetch('/push/subscribe',{
      method: 'POST',
      headers: {
          'Content-Type': 'application/json'
      },
      body: JSON.stringify(subscription)
    })
    .then(function(response) {
      return response;
    })
    .then(function(text) {
      console.log('User is subscribed.');
      hasSubscription = true;

      updatePushButton();
    })
    .catch(function(error) {
      hasSubscription = false;
      console.error('error fetching subscribe', error);
    });
    
  })
  .catch(function(err) {
    console.log('Failed to subscribe the user: ', err);
  });
}

function unsubscribeUser() {
  serviceWorkerRegistration.pushManager.getSubscription()
  .then(function(subscription) {
    if (subscription) {
      subscriptionData = {
        endpoint: subscription.endpoint
      };
      
      fetch('/push/unsubscribe',{
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(subscriptionData)
      })
      .then(function(response) {
        return response;
      })
      .then(function(text) {
        hasSubscription = false;

        updatePushButton();
      })
      .catch(function(error) {
        hasSubscription = true;
        console.error('error fetching subscribe', error);
      });

      hasSubscription = false;

      updatePushButton();
      return subscription.unsubscribe();
    }
  });
}

function initPush() {

  pushButton.addEventListener('click', function() {
    if (hasSubscription) {
      unsubscribeUser();
    } else {
      subscribeUser();
    }
  });

  // Set the initial subscription value
  serviceWorkerRegistration.pushManager.getSubscription()
  .then(function(subscription) {
    hasSubscription = !(subscription === null);

    updatePushButton();
  });
}

navigator.serviceWorker.register('sw.js')
.then(function(sw) {
  serviceWorkerRegistration = sw;
  initPush();
})
.catch(function(error) {
  console.error('Service Worker Error', error);
});
</code></pre>
<p>В первую очередь создаем константу addServiceKey: ей присваиваем значение с открытым ключ <em>VAPID</em> (о нем мы говорили выше). Также создаем несколько элементов и переменных. Записываем функцию urlB64ToUint8Array(): она понадобится для конвертации ключа из <em>base64</em> в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array">*Uint8Array</a>*.</p>
<p>Затем декларируем функцию updatePushButton(). Мы будем вызывать её каждый раз при изменении статуса уведомлений, чтобы обновить отвечающие за него элементы интерфейса.</p>
<p>Далее видим функцию регистрации подписки subscribeUser(). Как вы наверно заметили, в начале скрипта была объявлена переменная let serviceWorkerRegistration. Она содержит результат <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration">регистрации сервис-воркера</a>: посмотрите в конец файла, мы записываем его в переменную в момент регистрации.</p>
<pre><code>serviceWorkerRegistration.pushManager.subscribe({
  userVisibleOnly: true,
  applicationServerKey: urlB64ToUint8Array(appServerKey)
})
</code></pre>
<p>Метод subscribe() возвращает промис, а в качестве аргумента принимает объект с двумя свойствами:</p>
<ul>
<li>
<p>userVisibilityOnly: булево значение. Параметр сообщает, что подписка будет использоваться только для сообщений, эффект которых виден для пользователя. Устанавливаем значение true.</p>
</li>
<li>
<p>applicationServiceKey: номер открытого ключа, он используется сервером для отправки уведомлений. Так как ключ должен быть в формате <em>UInt8Attay</em>, используем уже знакомую нам функцию.</p>
<p>.then(function(subscription) {
fetch('/push/subscribe',{
method: "POST",
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify(subscription)
})</p>
</li>
</ul>
<p>Теперь отправляем данные подписки на сервер. Смело используем <em>Fetch API</em>, так как все браузеры, которые поддерживают пуш-уведомления, поддерживают и <em>Fetch</em>. После получения ответа выводим результат — завершена ли подписка успешно.</p>
<p>Этот этап прекрасно подходит для уточнения нужных параметров у пользователя. Например, на <a href="https://iss-observer.com">*iss-observer.com</a>* он может выбрать время получения уведомлений (утро и/или вечер). Я также отправляю на сервер данные о стране, регионе и городе, по которому пользователь хочет получать уведомления; данные сохраняются и могут потребоваться при отправке уведомлений.</p>
<p>После этого, создаем функцию отписки unsubscribeUser(). Используем метод getSubscription() объекта PushManager, с его помощью получаем детали подписки, которые отправляем на сервер (снова <em>Fetch API</em>). На этот раз, чтобы удалить её базы.</p>
<p>Записываем функцию initPush(). В ней — событие для кнопки <em>pushButton,</em> которое вызывает функцию подписки или отписки в зависимости от текущего состояния. После, не забываем обновить это состояние. Использованный в примере код можно найти на <a href="https://github.com/justmarkup/demos/blob/gh-pages/push-notifications/public/script/push.js">*GitHub</a>*.</p>
<p>Последний шаг — регистрация сервис-воркера.</p>
<h2>Сервис-воркер</h2>
<p>В этой части мы разберем два необходимых для реализации пуш-уведомлений события: push и notificationonclick.</p>
<pre><code>self.addEventListener('push', function(event) {
  let notificationData = {};
  
  try {
    notificationData = event.data.json();
  } catch (e) {
    notificationData = {
      title: 'Default title',
      body: 'Default message',
      icon: '/default-icon.png'
    };
  }
  
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon
    })
  );
});
</code></pre>
<p>Начнем с push. Проверяем содержимое объекта notificationData (свойства title, body и icon), и, если не находим их, присваиваем дефолтные значения. После вызываем метод showNotification, он покажет уведомление пользователю.</p>
<p><em>В дополнение к трём перечисленным свойствам могут использоваться и другие, например, badge, tag, vibrate. На момент написания этой статьи (февраль 2017) многие из них поддерживались только некоторыми браузерами. title, body и icon, доступных во всех браузерах, поэтому ограничимся ими.</em></p>
<pre><code>self.addEventListener('notificationclick', function(event) {

// close the notification
  event.notification.close();

// see if the current is open and if it is focus it
  // otherwise open new tab
  event.waitUntil(
    self.clients.matchAll().then(function(clientList) {
      
      if (clientList.length > 0) {
        return clientList[0].focus();
      }
      
      return self.clients.openWindow('/');
    })
  );
});
</code></pre>
<p>Событие notificationOnClick срабатывает в момент клика по уведомлению. Сначала закрываем уведомление. Затем проверяем, открыт ли наш сайт в текущей вкладке браузера, если нет, то открываем его с помощью openWindow().</p>
<h2>Бэкенд</h2>
<p>Переходим к серверной части, в которой мы используем <a href="https://github.com/web-push-libs/web-push">*web-push library</a><em>. В нашем случае это реализация библиотеки для *Node.js</em>, но версии для <em>PHP</em>, <em>Java</em> и <em>C#</em> также доступны.</p>
<p><em>Я предполагаю, что у вас есть базовые знания Node.js и опыт использования Express. В ином случае, я рекомендую вам ознакомиться с ними прежде чем продолжить.</em></p>
<p>Итак, в первую очередь:</p>
<ul>
<li>
<p>устанавливаем библиотеку командой npm install web-push --save,</p>
</li>
<li>
<p>получаем доступ к ней с помощью require: const webPush = require('web-push');</p>
<p>webPush.setVapidDetails(
'<a href="mailto:hallo@justmarkup.com&#x27;">hallo@justmarkup.com'</a>,
'YOUR<em>PUBLIC</em>VAPID<em>KEY', // process.env.VAPID</em>PUBLIC<em>KEY,
'YOUR</em>PRIVATE<em>VAPID</em>KEY', // process.env.VAPID<em>PRIVATE</em>KEY
);</p>
</li>
</ul>
<p>Теперь передаем данные <em>VAPID</em>. Помимо сгенерированной в начале пары ключей, нужно указать адрес электронной почты (с префиксом mailto:) либо <em>URL</em> сайта. Контактные данные могут потребоваться сервису для связи с вами. Обратите внимание на комментарии: я предпочел сохранить ключи в переменную окружения. Вы можете поступить так же или выбрать свой метод, но главное помните, **закрытый ключ **должен быть всегда защищен от обращений извне. Собственно поэтому он так и назван.</p>
<p>Переходим к функции подписки:</p>
<pre><code>app.post('/push/subscribe', function (req, res) {

const subscription = {
    endpoint: req.body.endpoint,
    keys: {
      p256dh: req.body.keys.p256dh,
      auth: req.body.keys.auth
    }
  };
  
  const payload = JSON.stringify({
    title: 'Welcome',
    body: 'Thank you for enabling push notifications',
    icon: '/android-chrome-192x192.png'
  });

const options = {
    TTL: 3600 // 1sec * 60 * 60 = 1h
  };

webPush.sendNotification(
    subscription, 
    payload,
    options
    ).then(function() {
      console.log('Send welcome push notification');
      res.status(200).send('subscribe');
      return;
    }).catch(err => {
      console.error('Unable to send welcome push notification', err );
      res.status(500).send('subscription not possible');
      return;
  });

})
</code></pre>
<p>В функции отправки подписки на сервер, получаем доступ к объекту subscription. В нем — значение endpoint и ключи доступа. Здесь я не буду останавливаться на вопросах работы с базой данных. Для примера укажу только, что для демо использована <a href="https://github.com/justmarkup/demos/blob/gh-pages/push-notifications/controllers/push.js#L19">*Mongo DB</a>*.</p>
<p><em>Прим. переводчика: endpoint — это уникальный URI, создаваемый для каждого пользователя индивидуально в соответствии <a href="https://random-push-service.com/some-kind-ofunique-id-1234/v2/">с паттерном</a>: p256dh — открытый ключ, auth — закрытый ключ.</em></p>
<p>Затем получаем наше первое уведомление — то, которое приветствует подписавшегося пользователя. Метод sendNotification() принимает три аргумента:</p>
<ul>
<li>
<p>данные подписки, получаемые от браузера;</p>
</li>
<li>
<p>информацию для пользователя (заголовок, сообщение, иконка — свойства title, body, icon соответственно);</p>
</li>
<li>
<p>объект options, <a href="https://github.com/web-push-libs/web-push#sendnotificationpushsubscription-payload-options">см. подробнее</a>.</p>
</li>
</ul>
<p><em>TTL (Time To Live) — срок жизни уведомления —по умолчанию четыре недели. Это значит, что оно будет ожидать появления пользователя онлайн в течение этого срока. Например, если вы отправили уведомление пользователю в оффлайне, и он подключится к сети только через две недели, сообщение все равно будет доставлено. В моем случае разумно изменить TTL на более короткий срок.</em></p>
<pre><code>app.post('/push/unsubscribe', function (req, res) {
  // remove from database
  Push.findOneAndRemove({endpoint: endpoint}, function (err,data) {
    if (err) { 
      console.error('error with unsubscribe', error);
      res.status(500).send('unsubscription not possible'); 
    }
    console.log('unsubscribed');
    res.status(200).send('unsubscribe');
  });
})
</code></pre>
<p>Если пользователь отменяет подписку, удаляем информацию о ней из базы.</p>
<h2>Дополнительно</h2>
<p>Вероятно, каждый из вас столкнется со своим случаем применения пуш-уведомлений, и просто скопировать код не получится. Однако я надеюсь, что этот урок поможет вам реализовать искомую функциональность как на стороне клиента, так и на стороне сервера.</p>
<p><a href="https://push-notifications-vwursywdxa.now.sh">Демо проекта</a>, исходный код опубликован на <a href="https://github.com/justmarkup/demos/tree/gh-pages/push-notifications">GitHub</a>.</p>
<p>Для более глубокого погружения в тему рекомендую бесплатную книгу <a href="https://web-push-book.gauntface.com">Web Push Book</a> и примеры на <a href="https://serviceworke.rs/">servicewore.rs</a>.</p>
<p>Если вам есть что спросить, или есть что добавить, пишите в <a href="https://twitter.com/justmarkup">Twitter</a> или по <a href="mailto:hallo@justmarkup.com">электронной почте</a>.</p>
<p><em>Перевод «<a href="https://justmarkup.com/log/2017/02/implementing-push-notifications/">Implementing push notifications on the front-end and back-end</a>» Майкла Шарналя. Перевод <a href="https://medium.com/@vlad_poe">Владислава Почепцова</a>, редактура <a href="https://medium.com/@pepelsbey">Вадима Макеева</a>.</em></p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-push-front-back-6f2","path":"/articles/push-front-back/"};window.dataPath="389/path---articles-push-front-back-6-f-2-d94-zVkPh9KQBzr91aFGqL1AIlEbH94";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>