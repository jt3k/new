<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/375/path---articles-boring-bits-of-css-907-894-Z5FlOMDmDq1UG0AT8ANP4J7FaE.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Как я научился любить скучные мелочи CSS</h1><div class="article__date">21 августа 2012</div><div class="article__content"><h1>Как я научился любить скучные мелочи CSS</h1>
<p><a href="http://www.broken-links.com">Питер Гастон</a> 21 августа 2012</p>
<p>В будущем CSS есть много того, чего нам стоит ожидать с нетерпением: с одной стороны, там будет целый спектр новых методов, которые произведут революцию в вёрстке; с другой стороны — новый набор графических эффектов, которые позволят создавать на лету фильтры и шейдеры. Людям всё это страшно нравится, в журналах и блогах пишется огромное количество статей об этих нововведениях.</p>
<p>Но если эти инструменты можно назвать выставочными лошадками CSS, тогда, думается мне, стоит обратить немного внимания и на рабочих лошадей: на те компоненты языка, которые являются его составными частями: селекторы, единицы измерения, функции. Я частенько называю их «скучными мелочами» — хотя на самом деле я это говорю с большой теплотой, и вам стоит, мне кажется, разделить моё доброе к ним отношение.</p>
<p>Почему? Давайте пробежимся по парочке лучших нововведений в CSS из разряда скучных мелочей — тех мелочей, над которыми работали в плохо освещенных лабораториях, вдали от блеска новых глянцевых штучек на витринах. Некоторые из этих мелочей уже какое-то время с нами, но заслуживают того, чтобы больше людей о них знали; другие, напротив, только начинают появляться в браузерах. Но тем не менее они произведут революцию в том, как мы работаем — причем тихо, скромно и без претензий.</p>
<h2>Относительные единицы измерения</h2>
<p>Скорее всего, вы, умный и предусмотрительный веб-разработчик, работаете с относительными единицами измерения — то есть с <code>em</code> или процентами — так что эта проблема вам должна быть знакома: вам наверняка приходится сидеть за калькулятором, чтобы вычислить размеры — из-за наследования. Например, сейчас вполне обычный прием — установить базовый размер шрифта для документа, а потом использовать относительные единицы, чтобы установить размер шрифта для всех остальных элементов на странице. В CSS это выглядит примерно так:</p>
<pre><code>html { font-size: 10px; }
p { font-size: 1.4em; }
</code></pre>
<p>Здесь всё отлично, и никакой проблемы нет, пока у вас не появляется дочерний элемент, которому вы хотите установить какой-нибудь другой размер шрифта. Например, в такой разметке:</p>
<pre><code>А и Б сидели на &#x3C;span>трубе&#x3C;/span>.
</code></pre>
<p>Если вы хотите, чтобы этот <code>&#x3C;span></code> было меньшего размера шрифта, например, <code>1.2em</code>, то что вам делать? Берите калькулятор и считайте, сколько будет 1,2 поделить на 1,4, и в итоге у вас получится:</p>
<pre><code>p span { font-size: 0.85714em; }
</code></pre>
<p>И проблема не ограничивается использованием <code>em</code>. Если вы разрабатываете тянущийся сайт с использованием ширин в процентах, то знаете, что эти проценты соотносятся с размерами контейнера элемента, так что если у вас есть элемент, которому вы хотите поставить ширину в 40% от его родительского элемента, ширина которого — 75%, тогда придется устанавливать ширину этого элемента в 53,33333%.</p>
<p>Мягко говоря, не идеально.</p>
<h2>Размеры относительно корневого элемента</h2>
<p>Чтобы побороть эту проблему с размерами шрифтов, теперь нам доступна новая единица измерения — <code>rem</code> (корневой <code>em</code>). Это всё ещё относительная единица измерения, но она всегда соотносится с фиксированным базовым значением, а именно — с размером шрифта корневого элемента документа (в случае HTML это всегда элемент <code>&#x3C;html></code>). Если предположить, что мы используем тот же самый размер шрифта для корневого элемента, что и в прошлый раз (<code>10px</code>), то нам потребуются для этого случая следующие CSS-правила:</p>
<pre><code>p { font-size: 1.4rem; }
p span { font-size: 1.2rem; }
</code></pre>
<p>Теперь оба правила соотносятся с размером шрифта корневого элемента — это куда более элегантно, да и работать с этим удобнее, особенно если у вас простое базовое значение, например, <code>10px</code> или <code>12px</code>. Это как если вернуться назад и использовать значения в пикселях, только с возможностью их масштабировать.</p>
<p>Это одна из функций, перечисленных в этой статье, которая поддерживается браузерами очень хорошо: все современные браузеры, включая IE9, поддерживают эту единицу, <a href="http://caniuse.com/#feat=rem">нет её пока только в Opera Mobile</a>.</p>
<h2>Размеры относительно вьюпорта</h2>
<p>Если вам кажется, что единица <code>rem</code> — крутая (а я так думаю!), то вы будете в восторге от того, что узнаете, что существует ещё и новый набор единиц измерения, который поможет победить проблему с процентами. Эти единицы работают примерно так же, как <code>rem</code>, за исключением того, что они соотносятся не с установленным пользователем значением на корневом элементе документа, а с самим вьюпортом, или областью просмотра устройства.</p>
<p>Две базовых единицы здесь — <code>vh</code> и <code>vw</code>; они соотносятся (соответственно) с высотой и шириной вьюпорта. Каждая единица является числом, и это число равняется соответствующему проценту от указанного измерения (ширины или высоты). Пока я ещё помню уроки в школе сценаристов, давайте я лучше не буду объяснять, а покажу:</p>
<pre><code>div { height: 50vh; }
</code></pre>
<p>В этом примере высота блока будет равна точно половине высоты вьюпорта; <code>1vh</code> — это 1% от высоты вьюпорта, так что равенство <code>50vh</code> = 50% от этой высоты выглядит вполне логичным.</p>
<p>Если размер окна просмотра изменяется, то изменяется и значение соответствующих единиц, и при этом вам не нужно беспокоиться о вложенных элементах: элемент с шириной <code>10vw</code> всегда будет этой ширины, вне зависимости от ширины его родительского элемента.</p>
<p>Также есть единица <code>vmin</code>, которая соответствует меньшему значению — <code>vh</code> или <code>vw</code>; кроме того, недавно стало известно, что в спецификацию добавится и соответствующая единица <code>vmax</code> (хотя на момент написания статьи этого пока не случилось).</p>
<p>Сейчас эти единицы поддерживаются в IE9+, Chrome и Safari 6.</p>
<h2>Рассчитываемые значения</h2>
<p>Если вы будете работать с тянущимся или адаптивным дизайном, вы, без сомнения, столкнетесь с проблемой смешивания единиц измерения — когда вы хотите, чтобы у вас на странице была сетка, ширина у которой задается в процентах, но при этом с фиксированными полями. Например:</p>
<pre><code>div {
    margin: 0 20px;
    width: 33%; 
}
</code></pre>
<p>Если в вашей верстке указаны только <code>padding</code> и <code>border</code>, тогда, в приницпе, можно решить проблему с помощью <code>box-sizing</code>, но с <code>margin</code> это не поможет. Есть лучший и более гибкий подход — использовать для значения функцию <code>calc()</code>, которая позволяет вам производить математические действия с разными единицами, скажем:</p>
<pre><code>div {
    margin: 0 20px;
    width: calc(33% - 40px);
}
</code></pre>
<p>Вы можете применяться её где угодно, не только для ширин, но и везде, где вам нужны единицы изменения. А если вы хотите зайти совсем далеко, то вы тоже можете даже использовать <code>calc()</code> внутри <code>calc()</code>.</p>
<p>В IE9+ эта функция поддерживается без префикса(!), в Firefox — с префиксом <code>-moz-</code> (в релизе 16 или 17 он должен быть отброшен), а в Chrome и Safari — с префиксом <code>-webkit-</code>. <a href="http://caniuse.com/#feat=calc">В мобильный Webkit он, увы, пока не включен.</a></p>
<h2>Загрузка подмножества символов</h2>
<p>Быстрая загрузка веб-страниц всегда была важна — но сейчас, с появлением на рынке широкого спектра мобильных устройств (с каждым из которых понятие «скорость соединения» становится всё более изменчивым и неопределенным) это, пожалуй, особенно важно. Один из способов ускорить загрузку страницы — сократить размер внешних подгружаемых файлов, и поэтому новое свойство внутри <code>@font-face</code>, которое позволяет делать именно это, — весьма полезное добавление.</p>
<p>Свойство, о котором идет речь — <code>unicode-range</code>, и в качестве значения оно принимает набор ссылок на юникод-символы. При загрузке внешних ресурсов из файла шрифта будут загружаться только эти символы, а не все символы, присутствующие в шрифте. Приведенный код показывает, как загрузить только три символа из файла foo.ttf:</p>
<pre><code>@font-face {
    font-family: foo;
    src: url('foo.ttf');
    unicode-range: U+31-33;
}
</code></pre>
<p>Особенно это полезно в том случае, если вы используете <a href="http://net.tutsplus.com/tutorials/html-css-techniques/quick-tip-ever-thought-about-using-font-face-for-icons/">иконки внутри шрифта</a> и хотите показывать на конкретной странице не все из них, а только конкретные. В одном тесте, который я провел, использование <code>unicode-range</code> сократило общее время загрузки файла шрифта в среднем на 0,85 секунды — а это вполне существенно. Конечно, у вас могут получиться и другие цифры.</p>
<p>Это свойство на данный момент поддерживается в IE9+ и браузерах на движке Webkit: Chrome и Safari.</p>
<h2>Новые псевдоклассы</h2>
<p>Единицы измерения и значения — это всё прекрасно, но особенно меня радуют селекторы и псевдоклассы. Когда у меня получается выдумать замысловатый селектор, даже если он в итоге будет запрятан там, где только немногие избранные смогут его найти, я всегда чувствовую себя мастером своего дела. <a href="http://hbr.org/2012/04/the-real-leadership-lessons-of-steve-jobs/">Перифразируя отца Стива Джобса</a>: ты должен сделать так, чтобы забор со стороны твоего дома выглядел так же хорошо, как со стороны улицы, даже если больше никто не будет знать, что это так — ведь ты будешь.</p>
<p>Для меня стало откровением, когда я впервые использовал <code>:nth-of-type()</code>, это было словно я вышиб ногой двери восприятия... Окей, я чуть-чуть преувеличиваю. Но есть несколько новых CSS-псевдоклассов, относительно которых действительно стоит испытывать энтузиазм.</p>
<h2>Псевдокласс отрицания</h2>
<p>Вы наверняка не поймете, насколько в действительности полезен новый (относительно) псевдокласс отрицания <code>:not()</code>, пока сами его не попробуете. В качестве аргумента <code>:not()</code> передается простой, а не составной селектор. Когда список элементов создается селектором, включающим <code>:not()</code>, все элементы, которые соответствуют аргументу, исключаются из этого списка. Знаю, звучит сложно, мне тоже так кажется. Но на самом деле всё довольно просто.</p>
<p>Представьте себе: у вас есть список, и вы хотите применить правило ко всем нечётным элементам в списке, но не к последнему. Вам придётся написать что-то вроде такого:</p>
<pre><code>li { color: #00F; }
li:nth-child(odd) { color: #F00; }
li:last-child { color: #00F; }
</code></pre>
<p>С псевдоклассом отрицания вы можете исключить последний элемент из списка, используя в качестве аргумента <code>:last-child</code>. Таким образом количество правил уменьшится, и с кодом станет легче работать:</p>
<pre><code>li { color: #00F; }
li:nth-child(odd):not(:last-child) { color: #F00; }
</code></pre>
<p>Ничего принципиально нового здесь нет, и, как я показал, вполне можно работать и без него, но — это довольно-таки полезно. У меня была возможность применить этот псевдокласс в проекте, где использовался встроенный Webkit, и я раз за разом убеждался в его пользе. Честно, это один из моих любимых псевдоклассов.</p>
<p>Всё верно, у меня есть любимые псевдоклассы.</p>
<p>Из всех функций, рассмотренных в этой статье, это самая широко поддерживамая; её поддерживают IE9+ и все современные браузеры — без префикса. Если вы работаете с jQuery, вполне возможно, что вы уже привыкли использовать этот синтаксис — в jQuery он есть начиная с версии 1.0, как и метод <code>not()</code>, который делает то же самое.</p>
<h2>Псевдокласс соответствия</h2>
<p>Псевдокласс соответствия <code>:matches()</code> принимает в качестве аргумента простой селектор, составной селектор, список, разделенный запятой, или любую комбинацию этих пунктов. Отлично! Но что же он делает?</p>
<p>Лучше всего он подходит для того, чтобы срезать лишнее с повторяющихся селекторов. В качестве сценария использования представьте себе, что у вас есть несколько элементов <code>&#x3C;p></code> в разных контейнерах, но вы хотите выбрать только некоторые из них; тогда правило в стилях будет выглядеть примерно так:</p>
<pre><code>.home header p,
.home footer p,
.home aside p {
    color: #F00;
}
</code></pre>
<p>С селектором <code>:matches()</code> вы можете значительно сократить его, найдя сходство в селекторах; в нашем примере у нас везде в начале стоит <code>.home</code>, а конце — <code>p</code>, так что мы можем использовать <code>:matches()</code> для того чтобы собрать все элементы между ними. Непонятно? Это выглядит вот так:</p>
<pre><code>.home :matches(header,footer,aside) p { color: #F00; }
</code></pre>
<p>В действительности это уже часть CSS4 (если быть совсем точными, спецификации CSS-селекторов уровня 4), и ещё в этой спецификации сказано, что вы сможете использовать такой же синтаксис — составные селекторы, разделенные запятой — в будущих версиях <code>:not()</code>. Здорово-то как!</p>
<p>На сегодняшний день <code>:matches()</code> есть в Chrome и Safari с префиксом <code>-webkit-</code>, а в Firefox он проходит под своим старым названием, <code>:any()</code>, с префиксом <code>-moz-</code>.</p>
<h2>Ну как, уже полюбили рабочих лошадок?</h2>
<p>Самое лучшее во всех этих новых возможностях — они решают совершенно реальные проблемы, от маленького, но раздражающего повторения селекторов до новых и появляющихся в настоящее время сложных задач, связанных с разработкой высокопроизводительных адаптивных сайтов. На самом деле, я могу легко представить, что регулярно использую каждое из этих нововведений.</p>
<p>Может быть, про новые возможности вроде фильтров больше пишут, но вы с гораздо большей вероятностью обнаружите, что именно те мелочи, которые представлены в этой статье, будут вам полезны в разработке.</p>
<p>Каждая из них сделает вашу профессиональную жизнь немножко проще, и в то же время расширит пространство ваших возможностей — а в этом ничего скучного, поверьте, нет.</p>
<p>Перевод оригинальной записи «<a href="http://www.alistapart.com/articles/love-the-boring-bits-of-css/">Learning to Love the Boring Bits of CSS</a>» Питера Гастона (Peter Gasston), опубликованной на сайте <a href="http://www.alistapart.com">A List Apart</a>. Переведено и опубликовано с разрешения автора.</p>
<p>Перевод выполнил <a href="http://www.facebook.com/vlad.andersen">Влад Андерсен</a>.</p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-boring-bits-of-css-907","path":"/articles/boring-bits-of-css/"};window.dataPath="375/path---articles-boring-bits-of-css-907-894-Z5FlOMDmDq1UG0AT8ANP4J7FaE";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>