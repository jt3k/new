<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/component---src-templates-article-jsx-45c82757c31814993ac5.js"/><link as="script" rel="preload" href="/app-d6d0aa46cc7a8319a706.js"/><link as="script" rel="preload" href="/webpack-runtime-49e87d415bc1f49f59fb.js"/><link rel="preload" href="/static/d/787/path---articles-promise-burger-party-569-a6d-rK6NpGC5vi7dxCjGnGR5uvx5Rg4.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="article"><h1 class="article__title">Обещание бургерной вечеринки</h1><div class="article__date">TODO</div><div class="article__content"><h1>Обещание бургерной вечеринки</h1>
<p>Перевод статьи «The Promise of a Burger Party» Марико Косаки.</p>
<p><em>Я написала этот пост как альтернативное введение в JavaScript-промисы. Я набросала его в своем блокноте во время чтения многочисленных статей на эту тему. Если вам нужно более глубокое руководство, в конце статьи есть список для дальнейшего изучения.</em></p>
<p>Пару недель назад я участвовала в обсуждении кое-какой функциональности на JavaScript. Она должна была работать асинхронно с использованием внешних данных. Я сказала: <em>«ладно, давайте используем fetch()… тогда в коде это… эм-м…» *И пока я молчала, пытаясь вспомнить *API Fetch</em>, мой собеседник сказал: «<em>он возвращает промис»</em>. Я впала в ступор и ответила: «<em>честно говоря, я не очень понимаю, что это значит…»</em></p>
<p>Я множество раз писала код на основе промисов, но в этот раз части почему-то не сложились в единую картину. Я поняла, что в действительности так и не разобралась с ними.</p>
<iframe src="https://medium.com/media/6843ee4f347528b7d397ac9dfab79a85" frameborder=0></iframe>
<p>Если вы читаете меня <a href="https://twitter.com/kosamari">в Twitter</a>, то знаете, что я учусь на визуальных примерах: беру <a href="https://twitter.com/kosamari/status/807303762188574720">объекты реального мира</a> как метафоры для сложных концепций в коде и изображаю их в виде <a href="https://twitter.com/kosamari/status/806941856777011200">рисунков</a>. Это позволяет мне совладать с двойным уровнем абстракции: языком программирования и английского как неродного языка. В общем, мне пришлось рисовать и в этот раз.</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*3U8UF-FdRnWK3RE44NGKyg.png"></p>
<p>А вот пример кода, с которым мы будем иметь дело в этой истории.</p>
<pre><code>*// Асинхронная операция*
function cookBurger (type) { ... }  

*// Обычная операция*
function makeMilkshake (type) { ... }

*// Функция оформления заказа, возвращает промис
*function order (type) {   
   return new Promise(function(resolve, reject) {
      var burger = cookBurger(type)
      burger.ready = function (err, burger) {
         if (err) {
            return reject(Error('Error while cooking'))
         }
         return resolve(burger)
      }
   })
}

order('JakeBurger')
   .then( burger => {
      const milkshake = makeMilkshake('vanila')
      return { burger: burger, shake: milkshake }
   })
   .then( foodItems => {
      console.log('BURGER PARTY !', foodItems)
   })
   .catch( err => {
     console.log(err)   
   })
</code></pre>
<h3>Устроим бургерную вечеринку!</h3>
<p>Добро пожаловать в парк Промис-Сквер, место встречи всех любителей бургеров — кафе «ДжейкШак». Бургеры ДжейкШака очень популярны в окру́ге, но в кафе мало кассовых аппаратов, и очередь из посетителей никогда не убывает. Несмотря на это, на кухне хватает рук, чтобы принимать множество заказов одновременно.</p>
<p><em>Если вы не в курсе: <a href="http://www.foodsmackdown.com/2011/08/shake-shack-new-york-madison-square-park/">кафе ShakeShak в парке Мэдисон-Сквер</a> — это место в Нью-Йорке. Кафе действительно отличное, но туда всегда длинная очередь .</em></p>
<h2>Пообещать сделать</h2>
<p>Чтобы принимать заказы максимально быстро, ДжейкШак использует систему сигнальных брелков. После оплаты заказа на кассе, сотрудник кафе выдает посетителю поднос и такой брелок.</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*Gh5Pv0ujTuikxGZMeANfCg.png"></p>
<p>Поднос — это промис*, *обещание ДжейкШака преподнести вам вкуснейший бургер, как только тот будет готов, а брелок — индикатор состояния вашего заказа. Брелок молчит? — значит заказ <strong>в процессе</strong> и лучшие повара трудятся над вашим бургером. Брелок загорелся красным и гудит? — значит заказ <strong>приготовлен</strong>.</p>
<p>Но есть небольшой нюанс: «приготовлен» — не значит «готов». Это значит, что работа поваров над заказом завершена, и они хотят, чтобы вы подошли и забрали его. Вы как клиент, вероятно, хотите просто получить свой бургер, но, в некоторых случаях, предпочтёте уйти. Дело ваше.</p>
<p>Давайте посмотрим, как это работает в коде. Когда вы вызываете функцию order (делаете заказ), она возвращает promise (выдает поднос и брелок как обещание выполнить заказ). Возвращённое значение (бургер) должен появиться на подносе, когда будет исполнен промис (данное вам обещание) и сработал колбэк. Подробнее об этом в следующем разделе!</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*-h3389QFwG0TG01piaFQjg.png"></p>
<h2>Добавьте обработчики промисов</h2>
<p>Ой, кажется брелок загудел. Пойдемте за стойку попросим заказ. На этом этапе возможны два сценария развития событий.</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*EvC0N4I6l5WWH7CM9f0THg.png"></p>
<p><strong>1. Заказ исполнен</strong></p>
<p>Ура-а! Ваш заказ готов, сотрудник кафе выносит свежий ароматный бургер. Обещание приготовить отличный бургер можно считать выполненным.</p>
<p><strong>2. Заказ отклонен</strong></p>
<p>Похоже, на кухне закончились котлеты. Обещание приготовить бургер выполнено не будет, оно отменяется. Не забудьте потребовать назад ваши деньги!</p>
<p>Посмотрим, как мы можем подготовиться к этим двум ситуациям в нашем коде.</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*XbbU9ZKSkEXPgkvFmULtIA.png"></p>
<p><em>Метод .then() принимает вторым аргументом функцию. Эта функция является обработчиком для reject. Но для простоты в своем примере я буду использовать для обработки ошибок только .catch(). Если вы хотите узнать подробнее о разнице, вам может пригодиться <a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises#error_handling">эта статья</a>.</em></p>
<h2>Связываем промисы</h2>
<p>Скажем, ваш заказ был успешно выполнен, но тут вы вспоминаете, что для фееричной бургерной вечеринки вам не хватает молочного коктейля… и вы идете в очередь «С» (специальная очередь за напитками, <a href="http://midtownlunch.com/2010/08/02/midtown-times-square-shake-shack-finally-add-a-c-line/">существует в ShakeShack на самом деле</a>, чтобы справиться с наплывом посетителей). При заказе коктейля кассир вручает вам другой поднос и еще один брелок. Так как напитки готовятся быстро, кассир сам выдает заказ, и не нужно ждать, когда загудит брелок (он уже гудит!).</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*WgzhaiCXhXQjrL04woAaEg.png"></p>
<p>Посмотрим, как это работает в коде. Чтобы соединить промисы в цепочку, достаточно всего лишь добавить еще один then(), он всегда возвращает промис. Просто запомните: каждый .then() возвращает поднос и брелок, а текущее возвращаемое значение передается аргументом в коллбэк.</p>
<p><img src="https://cdn-images-1.medium.com/max/5464/1*JogpJI8YjDS7kkhTGgdcaQ.png"></p>
<p>Теперь, когда у вас есть бургер и молочный коктейль, вы готовы к БУРГЕРНОЙ ВЕЧЕРИНКЕ 🎉!</p>
<h2>Другие трюки для вечеринок!</h2>
<p>У промисов есть и другие методы, которые позволяют делать классные трюки.</p>
<p>Promise.all() создает промис, принимающий массив промисов (<em>items</em>). Он исполняется, когда исполнены все элементы массива, каждый из которых тоже промис. Представим это так: вы заказали для друзей пять бургеров, но не хотите все пять раз бегать к стойке. Достаточно сделать это один раз, когда все бургеры будут готовы. Promise.all() в этом случае — отличное решение.</p>
<p>Promise.race() похож на Promise.all(), но исполнится или будет отклонен, как только будет исполнен или отклонен один из элементов массива промисов. Своего рода принцип «хватай и беги». Скажем, вы очень голодны и заказали бургер, чизбургер и хотдог одновременно, но заберёте только то, что быстрее приготовят. Обратите внимание, в этом случае, если на кухне закончились котлеты для бургеров, и отказ по бургеру вернется первым, то и все прочие заказы будут отменены.</p>
<p>Помимо этого, в JavaScript-промисах есть много других вещей для изучения. Ниже ссылки на материалы, которые я для этого рекомендую:</p>
<ul>
<li>
<p><a href="https://github.com/mattdesl/promise-cookbook/blob/master/README.md">promise-cookbook</a> — на английском, также доступна версия на китайском;</p>
</li>
<li>
<p><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">JavaScript Promises: an Introduction</a> — на английском;</p>
</li>
<li>
<p><a href="http://azu.github.io/promises-book/">JavaScript Promiseの本</a> — на японском, китайском и корейском языках.</p>
</li>
</ul>
<p>Спасибо Джейку Арчибальду и Нолану Лоусону за вычитку статьи и ценные советы, а также Крису Уитли за найденную в коде ошибку.</p>
<p><em>Перевод «<a href="http://kosamari.com/notes/the-promise-of-a-burger-party">The Promise of a Burger Party</a>» Марико Косаки. Перевод <a href="https://medium.com/@vlad_poe">Владислава Почепцова</a>, редактура <a href="https://medium.com/@pepelsbey">Вадима Макеева</a>. Опубликовано под лицензией <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</em></p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-promise-burger-party-569","path":"/articles/promise-burger-party/"};window.dataPath="787/path---articles-promise-burger-party-569-a6d-rK6NpGC5vi7dxCjGnGR5uvx5Rg4";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-d6d0aa46cc7a8319a706.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-b2857871934e9a044ec0.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-45c82757c31814993ac5.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-404-jsx-51366b521d977380588a.js"],"component---src-pages-articles-jsx":["/component---src-pages-articles-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-articles-jsx-108f450be88982059d31.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-events-jsx-60d370274f276520b18e.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx.4282b1e8f5a862472bb9.css","/component---src-pages-index-jsx-37c6ff1321838614c8ad.js"]};/*]]>*/</script><script src="/webpack-runtime-49e87d415bc1f49f59fb.js" async=""></script><script src="/app-d6d0aa46cc7a8319a706.js" async=""></script><script src="/component---src-templates-article-jsx-45c82757c31814993ac5.js" async=""></script></body></html>